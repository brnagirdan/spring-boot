= Spring Boot Reference Guide
:linkcss:
:toc:
:toclevels: 4
:source-highlighter: prettify
:copycss:
:numbered:
:icons: font
:spring-boot-version: 1.0.0.BUILD-SNAPSHOT
:spring-boot-repo: snapshot
:sc-ext: java
:dc-ext: html
:sc-root: http://github.com/spring-projects/spring-boot/tree/master
:dc-root: http://docs.spring.io/spring-boot/docs/1.0.0.RC4/api
:sc-spring-boot-autoconfigure: {sc-root}/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure
:dc-spring-boot-autoconfigure: {dc-root}/org/springframework/boot/autoconfigure
:sc-spring-boot-actuator: {sc-root}/spring-boot-actuator/src/main/java/org/springframework/boot/actuate
:dc-spring-boot-actuator: {dc-root}/org/springframework/boot/actuate
:author: Phillip Webb, Dave Syer, Josh Long

// FIXME look at this for inspiration http://media.readthedocs.org/pdf/django/1.6.x/django.pdf

== Spring Boot Documentation

=== Getting help
Having trouble with Spring Boot, We'd like to help!

* Try the How-to's -- they provide solutions to the most common questions
* Learn the Spring basics -- Spring Boot is builds on many other Spring projects, check
	the http://spring.io[spring.io] web-site for a wealth of reference documentation. If
	you are just starting out with Spring, try one of the http://spring.io/guides[guides]
* Ask a questions - we monitor http://stackoverflow.com[stackoverflow.com] for questions
	tagged with http://stackoverflow.com/tags/spring-boot[`spring-boot`]
* Report bugs with Spring Boot at https://github.com/spring-projects/spring-boot/issues


=== First steps
If you are just starting out...

* From scratch
* Tutorial
* Advanced tutorial

// FIXME



// FIXME overview of all the chapters here


== Getting started

=== Introducing Spring Boot
Spring Boot makes it easy to create stand-alone, production-grade Spring based
Applications that can you can ``just run''. We take an opinionated view of the Spring
platform and third-party libraries so you can get started with minimum fuss. Most Spring
Boot applications need very little Spring configuration.

You can use Spring Boot to create Java applications that can be started using `java -jar`
or more traditional WAR deployments. We also provide a command line tool that runs ``spring
scripts''.

Our primary goals are:

* Provide a radically faster and widely accessible getting started experience for all
Spring development
* Be opinionated out of the box, but get out of the way quickly as requirements start to
diverge from the defaults
* Provide a range of non-functional features that are common to large classes of projects
(e.g. embedded servers, security, metrics, health checks, externalized configuration)
* Absolutely no code generation and no requirement for XML configuration

=== Installing Spring Boot
Spring Boot can be used with ``classic'' Java development tools or installed as a command
line tool. Regardless, you will need http://www.java.com[Java SDK v1.6] or higher. You
should check your current Java installation before you begin:

[indent=0]
----
	$ java -version
----

If you are new to Java development, or if you just want to experiment with Spring Boot
you might want to try the Spring Boot CLI first, otherwise, read on for ``classic''
installation instructions.

TIP: Although Spring Boot is compatible with Java 1.6, if possible, you should consider
using the latest version of Java.

==== Installation instructions for the Java developer
You can use Spring Boot in the same way as any standard java library. Simply include the
appropriate `spring-boot-*.jar` files in your classpath. Spring Boot does not require
any special tool integration, so you can use any IDE or text editor; and there is nothing
special about a Spring Boot application, so you can run and debug as you would any other
Java program.

Although you _could_ just copy Spring Boot JARs, we generally recommend that you use a
build tool that support dependency management (such as Maven or Gradle).

===== Maven installation
Spring Boot is compatible with Apache Maven 3.0 or above. If you don't already have Maven
installed you can follow the instructions at http://maven.apache.org.

TIP: On many operating systems Maven can be installed via a package manager. If you're a
OSX Homebrew user try `brew install maven`. Ubuntu users can run `sudo apt-get install maven`.

Spring Boot dependencies use the `org.springframework.boot` `groupId`. Typically your
Maven POM file will inherit from the `spring-boot-starter-parent` project and declare
dependencies to one or more ``starter POMs''. Spring Boot also provides an optional Maven
plugin to create executable JARs.

// FIXME link to starter section

Here is a typical `pom.xml` file:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
		<modelVersion>4.0.0</modelVersion>

		<groupId>com.example</groupId>
		<artifactId>myproject</artifactId>
		<version>0.0.1-SNAPSHOT</version>

		<!-- Inherit defaults from Spring Boot -->
		<parent>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-parent</artifactId>
			<version>{spring-boot-version}</version>
		</parent>

		<!-- Add typical dependencies for a web application -->
		<dependencies>
			<dependency>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-starter-web</artifactId>
			</dependency>
		</dependencies>

		<!-- Package as an executable JAR -->
		<build>
			<plugins>
				<plugin>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-maven-plugin</artifactId>
				</plugin>
			</plugins>
		</build>

ifeval::["{spring-boot-repo}" != "release"]
		<!-- Add Spring repoistories -->
		<!-- (you don't need this if you are using a .RELEASE version) -->
		<repositories>
			<repository>
				<id>spring-snapshots</id>
				<url>http://repo.spring.io/snapshot</url>
				<snapshots><enabled>true</enabled></snapshots>
			</repository>
			<repository>
				<id>spring-milestones</id>
				<url>http://repo.spring.io/milestone</url>
			</repository>
		</repositories>
		<pluginRepositories>
			<pluginRepository>
				<id>spring-snapshots</id>
				<url>http://repo.spring.io/snapshot</url>
			</pluginRepository>
			<pluginRepository>
				<id>spring-milestones</id>
				<url>http://repo.spring.io/milestone</url>
			</pluginRepository>
		</pluginRepositories>
endif::[]
	</project>
----

// FIXME links here to later sections

===== Gradle installation
Spring Boot is compatible with Gradle 1.6 or above. If you don't already have Gradle
installed you can follow the instructions at http://www.gradle.org/.

Spring Boot dependencies can be declared using the `org.springframework.boot` `group`.
Typically your project will declare dependencies to one or more starter POMs. Spring Boot
provides a useful Gradle plugin that can be used to simplify dependency declarations
and to create executable JARs.

.Gradle Wrapper
****
The Gradle Wrapper provides a nice way of ``obtaining'' Gradle when you need to build a
project. It's a small script and library that you commit alongside your code to bootstrap
the build process. See http://www.gradle.org/docs/current/userguide/gradle_wrapper.html
for details.
****

Here is a typical `build.gradle` file:

[source,groovy,indent=0,subs="verbatim,quotes,attributes"]
----
	buildscript {
		repositories {
			mavenCentral()
ifndef::release[]
			maven { url "http://repo.spring.io/snapshot" }
			maven { url "http://repo.spring.io/milestone" }
endif::release[]
		}
		dependencies {
			classpath("org.springframework.boot:spring-boot-gradle-plugin:{spring-boot-version}")
		}
	}

	apply plugin: 'java'
	apply plugin: 'spring-boot'

	jar {
		baseName = 'myproject'
		version =  '0.0.1-SNAPSHOT'
	}

	repositories {
		mavenCentral()
ifndef::release[]
		maven { url "http://repo.spring.io/snapshot" }
		maven { url "http://repo.spring.io/milestone" }
endif::release[]
	}

	dependencies {
		compile("org.springframework.boot:spring-boot-starter-web")
		testCompile("junit:junit")
	}
----

// FIXME links to later on

==== Installing the Spring Boot CLI
The Spring Boot CLI is a command line tool that can be used if you want to quickly
prototype with Spring. It allows you to run http://groovy.codehaus.org/[Groovy] scripts,
which means that you have a familiar Java-like syntax, without so much boilerplate code.

You don't need to use the CLI to work with Spring Boot but it's definitely the quickest
way to get a Spring application off the ground.

===== Manual installation
You can download the Spring CLI distribution from the Spring software repository:

* http://repo.spring.io/{spring-boot-repo}/org/springframework/boot/spring-boot-cli/{spring-boot-version}/spring-boot-cli-{spring-boot-version}-bin.zip[spring-boot-cli-{spring-boot-version}-bin.zip]
* http://repo.spring.io/{spring-boot-repo}/org/springframework/boot/spring-boot-cli/{spring-boot-version}/spring-boot-cli-{spring-boot-version}-bin.tar.gz[spring-boot-cli-{spring-boot-version}-bin.tar.gz]

Cutting edge http://repo.spring.io/snapshot/org/springframework/boot/spring-boot-cli/[snapshot distributions]
are also available.

Once downloaded, follow the INSTALL instructions from the unpacked archive. In summary:
there is a `spring` script (`spring.bat` for Windows) in a `bin/` directory in the `.zip`
file, or alternatively you can use `java -jar` with the `.jar` file (the script helps you
to be sure that the classpath is set correctly).

===== Installation with GVM
GVM (the Groovy Environment Manager) can be used for managing multiple versions of
various Groovy and Java binary packages, including Groovy itself and the Spring Boot CLI.
Get `gvm` from http://gvmtool.net and install Spring Boot with

[indent=0,subs="verbatim,quotes,attributes"]
----
	$ gvm install springboot
	$ spring --version
	Spring Boot v{spring-boot-version}
----

If you are developing features for the CLI and want easy access to the version you just
built, follow these extra instructions.

[indent=0,subs="verbatim,quotes,attributes"]
----
	$ gvm install springboot dev /path/to/spring-boot/spring-boot-cli/target/spring-boot-cli-{spring-boot-version}-bin/spring-{spring-boot-version}/
	$ gvm use springboot dev
	$ spring --version
	Spring CLI v{spring-boot-version}
----

This will install a local instance of `spring` called the `dev` instance inside your gvm
repository. It points at your target build location, so every time you rebuild Spring
Boot, `spring` will be up-to-date.

You can see it by doing this:

[indent=0,subs="verbatim,quotes,attributes"]
----
	$ gvm ls springboot

	================================================================================
	Available Springboot Versions
	================================================================================
	> + dev
	* {spring-boot-version}

	================================================================================
	+ - local version
	* - installed
	> - currently in use
	================================================================================
----

===== OSX Homebrew installation
If you are on a Mac and using http://brew.sh/[Homebrew], all you need to do to install
the Spring Boot CLI is:

[indent=0]
----
	$ brew tap pivotal/tap
	$ brew install springboot
----

Homebrew will install `spring` to `/usr/local/bin`.

NOTE: If you don't see the formula, you're installation of brew might be out-of-date.
Just execute `brew update` and try again.

===== Quick start Spring CLI example
Here's a really simple web application that you can use to test you installation. Create
a file called `app.groovy`:

[source,groovy,indent=0,subs="verbatim,quotes,attributes"]
----
	@Controller
	class ThisWillActuallyRun {

		@RequestMapping("/")
		@ResponseBody
		String home() {
			return "Hello World!"
		}

	}
----

Then simply run it from a shell:

[indent=0]
----
	$ spring run app.groovy
----

NOTE: It will take some time when you first run the application as dependencies are
downloaded, subsequent runs will be much quicker.

Open http://localhost:8080 in your favorite web browser and you should see the following
output:

[indent=0]
----
	Hello World!
----

=== Developing your first Spring Boot application
Let's develop a simple ``Hello World!'' web application in Java that highlights some
of Spring Boot's key features. We'll use Maven to build this project since most IDEs
support it.

TIP: The http://spring.io[spring.io] web site contains many ``Getting Started'' guides
that use Spring Boot. If you're looking to solve a specific problem; check there first.

Before we begin, open a terminal to check that you have valid versions of Java and Maven
installed.

[indent=0]
----
	$ java -version
	java version "1.7.0_51"
	Java(TM) SE Runtime Environment (build 1.7.0_51-b13)
	Java HotSpot(TM) 64-Bit Server VM (build 24.51-b03, mixed mode)
----

[indent=0]
----
	$ mvn -v
	Apache Maven 3.1.1 (0728685237757ffbf44136acec0402957f723d9a; 2013-09-17 08:22:22-0700)
	Maven home: /Users/user/tools/apache-maven-3.1.1
	Java version: 1.7.0_51, vendor: Oracle Corporation
----

NOTE: This sample needs to be created in it's own folder. Subsequent instructions assume
that you have created a suitable folder and that it is your ``current directory''.

==== Creating the POM
We need to start by creating a Maven `pom.xml` file. The `pom.xml` is the recipe that
will be used to build your project. Open you favorite text editor and add the following:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
		<modelVersion>4.0.0</modelVersion>

		<groupId>com.example</groupId>
		<artifactId>myproject</artifactId>
		<version>0.0.1-SNAPSHOT</version>

		<parent>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-parent</artifactId>
			<version>{spring-boot-version}</version>
		</parent>

		<!-- Additional lines to be added here... -->

ifeval::["{spring-boot-repo}" != "release"]
		<!-- (you don't need this if you are using a .RELEASE version) -->
		<repositories>
			<repository>
				<id>spring-snapshots</id>
				<url>http://repo.spring.io/snapshot</url>
				<snapshots><enabled>true</enabled></snapshots>
			</repository>
			<repository>
				<id>spring-milestones</id>
				<url>http://repo.spring.io/milestone</url>
			</repository>
		</repositories>
		<pluginRepositories>
			<pluginRepository>
				<id>spring-snapshots</id>
				<url>http://repo.spring.io/snapshot</url>
			</pluginRepository>
			<pluginRepository>
				<id>spring-milestones</id>
				<url>http://repo.spring.io/milestone</url>
			</pluginRepository>
		</pluginRepositories>
endif::[]
	</project>
----

This should give you a working build, you can test it out by running `mvn package` (you
can ignore the _`JAR will be empty - no content was marked for inclusion!'_ warning for
now).

NOTE: At this point you could import the project into an IDE (most modern Java IDE's
include built-in support for Maven). For simplicity, we will continue to use a simple
text editor for this example.

==== Adding classpath dependencies
Spring Boot provides a number of ``Starter POMs'' that make easy to add JARs to your
classpath. Our sample application has already used `spring-boot-starter-parent` in the
`parent` section of the POM. The `spring-boot-starter-parent` is a special starter
that provides useful Maven defaults. It also provides a `dependency-management` section
so that you can omit `version` tags for blessed `dependencies`.

Other ``Starter POMs'' simply provide dependencies that you are likely to need to a
specific type of application. Since we are developing web application we will add a
`spring-boot-starter-web` dependency -- but before that, lets look at what we currently
have.

[indent=0]
----
	$ mvn dependency:tree

	[INFO] com.example:myproject:jar:0.0.1-SNAPSHOT
	[INFO] +- junit:junit:jar:4.11:test
	[INFO] |  \- org.hamcrest:hamcrest-core:jar:1.3:test
	[INFO] +- org.mockito:mockito-core:jar:1.9.5:test
	[INFO] |  \- org.objenesis:objenesis:jar:1.0:test
	[INFO] \- org.hamcrest:hamcrest-library:jar:1.3:test
----

The `mvn dependency:tree` command prints tree representation of your project dependencies.
You can see that `spring-boot-starter-parent` has already provides some useful test
dependencies. Lets edit our `pom.xml` and add the `spring-boot-starter-web` dependency
just below the `parent` section:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
	</dependencies>
----

If you run `mvn dependency:tree` again, you will see that there are now a number of
additional dependencies, including the Tomcat web server and Spring Boot itself.

==== Writing the code
To finish our application we need to create a single Java file. Maven will compile sources
from `src/main/java` so you need to create that folder structure, then add a file named
`src/main/java/Example.java`:

[source,java,indent=0]
----
	import org.springframework.boot.*;
	import org.springframework.boot.autoconfigure.*;
	import org.springframework.stereotype.*;
	import org.springframework.web.bind.annotation.*;

	@Controller
	@EnableAutoConfiguration
	public class Example {

		@RequestMapping("/")
		@ResponseBody
		String home() {
			return "Hello World!";
		}

		public static void main(String[] args) throws Exception {
			SpringApplication.run(Example.class, args);
		}

	}
----

Although there isn't much code here, quite a lot is going on. Lets step though the
important parts of the code.

===== The @Controller, @RequestMapping and @ResponseBody annotations
The first annotation on our `Example` class is `@Controller`. This is known as a
_stereotype_ annotation. It provides hints for people reading the code, and for Spring,
that the class plays a specific role. In this case, our class is web `@Controller` so
Spring will consider it when handling incoming web requests.

The `@RequestMapping` annotation provides ``routing'' information. It is telling Spring
that any HTTP request with the path "`/`" should be mapped to the method. The additional
`@ResponseBody` annotation tells Spring to render the resulting string directly back to
the caller.

TIP: The `@Controller`, `@RequestMapping` and `@ResponseBody` annotation are Spring MVC
annotations (they are not specific to Spring Boot). See the MVC section in the Spring
Reference Documentation for more details.

===== The @EnableAutoConfiguration annotation
The second class-level annotation is `@EnableAutoConfiguration`. This annotation tells
Spring Boot to ``guess'' how you will want to configure Spring based on the JAR
dependencies that you have added. Since `spring-boot-starter-web` added Tomcat and
Spring MVC, the auto-configuration will assume that you are developing a web application
and setup Spring accordingly.

.Starter POMs and Auto-Configuration
****
Auto-configuration is designed to work well with ``Starter POMs'', but the two concepts
are not directly tied. You are free to pick-and-choose JAR dependencies outside of the
starter POMs and Spring Boot will still do its best to auto-configure your application.
****

===== The ``main'' method
The final part of our application is the `main` method. This is just a standard method
that follows the Java convention for an application entry point. Our main method delegates
to Spring Boot's `SpringApplication` class by calling `run`. `SpringApplication` will
bootstrap our application, starting Spring which will in turn start the auto-configured
Tomcat web server. We need to pass `Example.class` as an argument to the `run` method to
tell `SpringApplication` which is the primary Spring component. The `args` array is also
passed though to expose any command-line arguments.

==== Running the example
At this point out application should work. Since we have used the
`spring-boot-starter-parent` POM we have a useful `run` goal that we can use to start
the application. Type `mvn spring-boot:run` from the root project directory to start the
application:

[indent=0,subs="attributes"]
----
	$ mvn spring-boot:run

	  .   ____          _            __ _ _
	 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
	( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
	 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
	  '  |____| .__|_| |_|_| |_\__, | / / / /
	 =========|_|==============|___/=/_/_/_/
	 :: Spring Boot ::  (v{spring-boot-version})
	....... . . .
	....... . . . (log output here)
	....... . . .
	........ Started Example in 2.222 seconds (JVM running for 6.514)
----

If you open a web browser to http://localhost:8080 you should see the following output:

[indent=0]
----
	Hello World!
----

To gracefully exist the application hit `ctrl-c`.

==== Creating an executable JAR
Lets finish our example by create a completely self-contained executable JAR file that
we could run in production. Executable JARs (sometimes called ``Fat JARs'') are archives
containing your compiled classes along with all of the JAR dependencies that your code
needs to run.

.Executable JARs and Java
****
Java does not provide any standard way to load nested jar files (i.e. jar files that are
themselves contained within a jar). This can be problematic if you are looking to
distribute a self contained application.

To solve this problem, many developers use ``shaded'' jars. A shaded jar simply packages
all classes, from all jars, into a single ``uber jar''. The problem with shaded jars is that
it becomes hard to see which libraries you are actually using in your application. It can
also be problematic if the the same filename is used (but with different content) in
multiple jars.

Spring Boot takes a different approach and allows you to actually nest jars directly.
****

To create an executable JAR we need to add the `spring-boot-maven-plugin` to our
`pom.xml`. Insert the following lines just below the `dependencies` section:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>
----

Save your `pom.xml` and run `mvn package` from the command line:

[indent=0,subs="attributes"]
----
	$ mvn package

	[INFO] Scanning for projects...
	[INFO]
	[INFO] ------------------------------------------------------------------------
	[INFO] Building myproject 0.0.1-SNAPSHOT
	[INFO] ------------------------------------------------------------------------
	[INFO] .... ..
	[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ myproject ---
	[INFO] Building jar: /Users/developer/example/spring-boot-example/target/myproject-0.0.1-SNAPSHOT.jar
	[INFO]
	[INFO] --- spring-boot-maven-plugin:{spring-boot-version}:repackage (default) @ myproject ---
	[INFO] ------------------------------------------------------------------------
	[INFO] BUILD SUCCESS
	[INFO] ------------------------------------------------------------------------
----

If you look in the `target` directory you should see `myproject-0.0.1-SNAPSHOT.jar`. The
file should be around 10 Mb in size. If you want to peek inside, you can use `jar tvf`:

[indent=0]
----
	$ jar tvf target/myproject-0.0.1-SNAPSHOT.jar
----

You should also see a much smaller file named `myproject-0.0.1-SNAPSHOT.jar.original`
in the `target` directory. This is the original JAR file that Maven created before it was
repackaged by Spring Boot.

To run that application, use the `java -jar` command:

[indent=0,subs="attributes"]
----
	$ java -jar target/myproject-0.0.1-SNAPSHOT.jar

	  .   ____          _            __ _ _
	 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
	( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
	 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
	  '  |____| .__|_| |_|_| |_\__, | / / / /
	 =========|_|==============|___/=/_/_/_/
	 :: Spring Boot ::  (v{spring-boot-version})
	....... . . .
	....... . . . (log output here)
	....... . . .
	........ Started Example in 3.236 seconds (JVM running for 3.764)
----

As before, to gracefully exist the application hit `ctrl-c`.

=== What to read next

// FIXME write this

== Using Spring Boot
This section provides a brief overview of best-practices when using Spring Boot. There
is nothing particularly special about Spring Boot, it is just another library that you
can consume. There are, however, a few recommendations that when followed will make your
development process just a little easier.

=== Build systems
It is strongly recommended that you choose a build system that supports _dependency
management_, and one that can consume artifacts published to the ``Maven Central''
repository. We would recommend that you choose Maven or Gradle. It is possible to get
Spring Boot to work with other build systems (Ant for example), but they would not be
particularly well supported.

==== Maven
Maven users can inherit from the `spring-boot-starter-parent` project to obtain sensible
defaults. The parent project provides the following features:

* Java 1.6 as the default compiler level
* UTF-8 source encoding
* A Dependency Management section, allowing you to omit `<version>` tags for common
  dependencies.
* Generally useful test dependencies (JUnit, Hamcrest, Mockito)
* Sensible resource filtering
* Sensible plugin configuration (exec plugin, surefire, git commit ID, shade)

===== Inheriting the starter parent
To configure your project to inherit from the `spring-boot-starter-parent` simply set
the `parent`:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<!-- Inherit defaults from Spring Boot -->
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>{spring-boot-version}</version>
	</parent>
----

NOTE: You should only need to specify the Spring Boot version number on this dependency.
if you import additional starters, you can safely omit the version number.

===== Using your own parent POM
If you don't want to use the Spring Boot starter parent, you can use your own and still
keep the benefit of the dependency management (but not the plugin management) using a
`scope=import` dependency:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<dependencyManagement>
 		<dependencies>
			<dependency>
				<!-- Import dependency management from Spring Boot -->
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-starter-parent</artifactId>
				<version>{spring-boot-version}</version>
		        <scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>
----

===== Changing the Java version
The `spring-boot-starter-parent` chooses fairly conservative Java compatibility. If you
want to follow our recommendation and use a later Java version you can add a
`java.version` property:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<properties>
		<java.version>1.8</java.version>
	</properties>
----

===== Using the Spring Boot Maven plugin
Spring Boot includes a Maven plugin that can package the project as an executable JAR, or
run it from source code. Add the plugin to your `<plugins>` section if you want to use it:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>
----

NOTE: You only need to add the plugin, there is no need for to configure it, unless you
want to change the settings in the parent.

// FIXME Link to maven plugin

==== Gradle
Gradle users can directly import ``starter POMs'' in their `dependencies` section. Unlike
Maven, there is no ``super parent'' to import.

[source,groovy,indent=0,subs="attributes"]
----
	apply plugin: 'java'

	repositories { mavenCentral() }
	dependencies {
		compile("org.springframework.boot:spring-boot-starter-web")
	}
----

The `spring-boot-gradle-plugin` is also available and provides tasks to create executable
JARs and run projects from source. It also adds a `ResolutionStrategy` that enables you
to omit the version number for common dependencies:


[source,groovy,indent=0,subs="attributes"]
----
	buildscript {
		repositories { mavenCentral() }
		dependencies {
			classpath("org.springframework.boot:spring-boot-gradle-plugin:${spring-boot-version}")
		}
	}

	apply plugin: 'java'
	apply plugin: 'spring-boot'

	repositories { mavenCentral() }
	dependencies {
		compile("org.springframework.boot:spring-boot-starter-web")
		testCompile("org.springframework.boot:spring-boot-starter-test")
	}
----

// FIXME Link to gradle plugin

====  Ant
It is possible to build a Spring Boot project using Apache Ant, however, no special
support or plugins are provided. Ant scripts can use the Ivy dependency system to import
starter POMs.

See XXX for more complete instructions.

// FIXME link

==== Starter POMs
Starter POMs are a set of convenient dependency descriptors that you can include in your
application. You get a one-stop-shop for all the Spring and related technology that you
need, without having to hunt through sample code and copy paste loads of dependency
descriptors. For example, if you want to get started using Spring and JPA for database
access, just include the `spring-boot-starter-data-jpa` dependency in your project, and
you are good to go.

The starters contain a lot of the dependencies that you need to get a project up and
running quickly and with a consistent, supported set of managed transitive dependencies.

.What's in a name
****
All starters follow a similar naming pattern; `spring-boot-starter-*`, where `*` is
a particular type of application. This naming structure is intended to help when you need
to find a starter. The Maven integration in many IDEs allow you to search dependencies by
name. For example, with the appropriate Eclipse or STS plugin installed, you can simply
hit `ctrl-space` in the POM editor and type ''spring-boot-starter'' for a complete list.
****

The following application starters are provided by Spring Boot under the
`org.springframework.boot` group:

.Spring Boot application starters
|===
| Name | Description

|`spring-boot-starter`
|The core Spring Boot starter, including auto-configuration support, logging and YAML.


|`spring-boot-starter-amqp`
|Support for the ``Advanced Message Queuing Protocol'' via `spring-rabbit`.

|`spring-boot-starter-aop`
|Full AOP programming support including `spring-aop` and AspectJ.

|`spring-boot-starter-batch`
|Support for ``Spring Batch'' including HSQLDB database.

|`spring-boot-starter-data-jpa`
|Full support for the ``Java Persistence API'' including `spring-data-jpa`, `spring-orm`
and Hibernate.

|`spring-boot-starter-data-mongodb`
|Support for the MongoDB NoSQL Database, including `spring-data-mongodb`,

|`spring-boot-starter-data-rest`
|Support for exposing Spring Data repositories over REST via `spring-data-rest-webmvc`.

|`spring-boot-starter-integration`
|Support for common `spring-integration` modules.

|`spring-boot-starter-jdbc`
|JDBC Database support

|`spring-boot-starter-mobile`
|Support for `spring-mobile`

|`spring-boot-starter-redis`
|Support for the REDIS key-value data store, including `spring-redis`.

|`spring-boot-starter-security`
|Support for `spring-security`

|`spring-boot-starter-test`
|Support for common test dependencies, including JUnit, Hamcrest and Mockito along with
 the `spring-test` module.

|`spring-boot-starter-thymeleaf`
|Support for the Thymeleaf templating engine, including integration with Spring.

|`spring-boot-starter-web`
|Support for full-stack web development, including Tomcat and `spring-webmvc`.

|`spring-boot-starter-websocket`
|Support for websocket development with Tomcat.
|===


In addition to the application starter, the following starters can be used to
add ``production ready'' features.

.Spring Boot ``production ready'' starters
|===
| Name | Description

|`spring-boot-starter-actuator`
|Adds production ready features such as metrics and monitoring.

|`spring-boot-starter-shell-remote`
|Adds remote `ssh` shell support.
|===

Finally, Spring Boot includes some starters that can be used if you want to exclude or
swap specific technical facets.

.Spring Boot technical starters
|===
| Name | Description

|`spring-boot-starter-jetty`
|Imports the Jetty HTTP engine (to be used as an alternative to Tomcat)

|`spring-boot-starter-log4j`
|Support the Log4J looggin framework

|`spring-boot-starter-logging`
|Import Spring Boot's default logging framework (Logback).

|`spring-boot-starter-tomcat`
|Import Spring Boot's default HTTP engine (Tomcat).
|===


=== Structuring your code
Spring Boot does not require any specific code layout to work, however, there are some
best practices that help.

==== Using the ``default'' package
When a class doesn't include a `package` declaration it is considered to be in the
``default package''. The use of the ``default package'' is generally discouraged, and
should be avoided. It can cause particular problems for Spring Boot applications that
use `@ComponentScan` or `@EntityScan` annotations, since every class from every jar,
will be read.

TIP: We recommend that you use the follow Java's recommended package naming conventions
and use a reversed domain name (for example, `com.example.project`).

==== Locating the main application class
We generally recommend that you locate your main application class in a root package
above other classes. The `@EnableAutoConfiguration` annotation is often placed on your
main class, and it implicitly defines a base ``search package'' for certain items. For
example, if you are writing a JPA application, the package of the
`@EnableAutoConfiguration` annotated class will be used to search for `@Entity` items.

Using a root package also allows the `@ComponentScan` annotation to be used without
needing to specify a `basePackage` attribute.

Here is a typical layout:

[indent=0]
----
	com
	 +- example
	     +- myproject
	         +- Application.java
	         |
	         +- domain
	         |   +- Customer.java
	         |   +- CustomerRepository.java
	         |
	         +- service
	         |   +- CustomerService.java
	         |
	         +- web
	             +- CustomerController.java
----

The `Application.java` file would declare the `main` method, along with the basic
`@Configuration`.

[source,java,indent=0]
----
	package com.example.myproject;

	import org.springframework.boot.SpringApplication;
	import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
	import org.springframework.context.annotation.ComponentScan;
	import org.springframework.context.annotation.Configuration;

	@Configuration
	@EnableAutoConfiguration
	@ComponentScan
	public class Application {

		public static void main(String[] args) {
			SpringApplication.run(Application.class, args);
		}

	}
----

=== @Configuration classes
Spring Boot favors Java-based configuration. Although it is possible to call
`SpringApplication.run()` with an XML source, we generally recommend that your primary
source is a `@Configuration` class. Usually the class that defines the `main` method
is also a good candidate as the primary `@Configuration`.

TIP: Many Spring configuration examples have been published that use XML configuration.
Always try to use the equivalent Java-base configuration if possible. Searching for
`enable*` annotations can be a good starting point.

==== Importing additional configuration classes
You don't need to put all your `@Configuration` into a single class. The `@Import`
annotation an be used to import additional configuration classes. Alternatively, you
can use `@ComponentScan` to automatically pickup all Spring components, including
`@Configuration` classes.

==== Importing XML configuration
If you absolutely must use XML based configuration we recommend that you still start
with a `@Configuration` class. You can then use an additional `@ImportResource`
annotation to load XML configuration files.

=== Auto-configuration
Spring Boot auto-configuration attempts to automatically configure your Spring
application based on the JAR dependencies that you have added. For example, If
`HSQLDB` is on your classpath, and you have not manually configured any database
connection beans, then we will auto-configure an in-memory database.

You need to opt-in to auto-configuration by adding the `@EnableAutoConfiguration`
annotation to one of your `@Configuration` classes.

TIP: You should only ever add one `@EnableAutoConfiguration` annotation. We generally
recommend that you add it to your primary `@Configuration` class.

==== Gradually replacing auto-configuration
Auto-configuration is noninvasive,  at any point you can start to define your own
configuration to replace specific parts of the auto-configuration. For example, if
you add your own `DataSource` bean, the default embedded database support will back away.

If you need to find out what auto-configuration is currently being applied, and why,
starting your application with the `--debug` switch. This will log an auto-configuration
report to the console.

// FIXME we need links here to a complete section.

==== Disabling specific auto-configuration
If you find that specific auto-configure classes are being applied that you don't want
you can use the exclude attribute of `@EnableAutoConfiguration` to disable them.

[source,java,indent=0]
----
	import org.springframework.boot.autoconfigure.*;
	import org.springframework.boot.autoconfigure.jdbc.*;
	import org.springframework.context.annotation.*;

	@Configuration
	@EnableAutoConfiguration(exclude={EmbeddedDatabaseConfiguration.class})
	public class MyConfiguration {
	}
----

=== Spring Beans and dependency injection
You are free to use any the standard Spring Framework techniques to defines your beans
and their injected dependencies. For simplicity, we often find that using `@ComponentScan`
to find your beans, in combination with `@Autowired` constructor injection works well.

If you structure your code as suggested above (locating your application class in a root
package), you can add `@ComponentScan` without any arguments. All of your application
components (`@Component`, `@Service`, `@Repoistory`, `@Controller` etc.) will be
automatically registered as Spring Beans.

Here is an example `@Service` Bean that uses constructor injection to obtain its'
required `RiskAssessor` bean.

[source,java,indent=0]
----
	package com.example.service;

	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.stereotype.Service;

	@Service
	public class DatabaseAccountService implements AccountService {

		private final RiskAssessor riskAssessor;

		@Autowired
		public DatabaseAccountService(RiskAssessor riskAssessor) {
			this.riskAssessor = riskAssessor;
		}

		// ...

	}
----

TIP: Notice how using constructor injection allows the `riskAssessor` field to be marked
as `final`, indicating that it cannot be subsequently changed.

=== Running your application
One of the biggest advantages of packaging your application as JAR and using an embedded
HTTP server is that you can run your application as you would any other. Debugging Spring
Boot applications is also easy; you don't need any special IDE plugins or extensions.

NOTE: This section only covers JAR pased packaging, If you choose to package your
application as a WAR file you should refer to your server and IDE documentation.

==== Running from an IDE
You can run a Spring Boot application from your IDE as a simple Java application, however,
first you will need to import your project. Import steps will vary depending on your IDE
and build system. Most IDEs can import Maven projects directly, for example Eclipse users
can select `Import...` -> `Existing Maven Projects` from the `File` menu.

If you can't directly import your project into your IDE, you may be able to generate IDE
meta-data using a build plugin. Maven includes plugins for
http://maven.apache.org/plugins/maven-eclipse-plugin/[Eclipse] and
http://maven.apache.org/plugins/maven-idea-plugin/[IDEA]; Gradle offers plugins
for http://www.gradle.org/docs/current/userguide/ide_support.html[various IDEs].

TIP: If you accidentally run a web application twice you will see a ``Port already in
use'' error. STS users can use the `Relauch` button rather than `Run` to ensure that
any existing instance is closed.

==== As a packaged application
If you use the Spring Boot Maven or Gradle plugins to create an executable JAR you can
run your application using `java -jar`. For example:

[indent=0,subs="attributes"]
----
	$ java -jar target/myproject-0.0.1-SNAPSHOT.jar
----

It is also possible to run a package application with remote debugging support enabled.
This allows you to attach a debugger to your packaged application:

[indent=0,subs="attributes"]
----
	$ java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n \
	       -jar target/myproject-0.0.1-SNAPSHOT.jar
----

==== Using the Maven plugin
The Spring Boot Maven plugin includes a `run` goal which can be used to quickly compile
and run your application. Applications run in an exploded form, and you can edit
resources for instant ``hot'' reload.

[indent=0,subs="attributes"]
----
	$ mvn spring-boot:run
----

// FIXME link to docs

==== Using the Gradle plugin
The Spring Boot Gradle plugin also includes a `run` goal which can be used to run
your application in an exploded form. The `bootRun` task is added whenever you import
the `spring-boot-plugin`

[indent=0,subs="attributes"]
----
	$ gradle bootRun
----

// FIXME link to docs

==== Hot swapping
Since Spring Boot applications are just plain Java application, JVM hot-swapping should
work out of the box. JVM hot swapping is somewhat limited with bytecode that it can
replace, for a more complete solution the
https://github.com/spring-projects/spring-loaded[Spring Loaded] project, or
http://zeroturnaround.com/software/jrebel/[JRebel] can be used.

See the Hot swapping ``How-to'' section for details.

// FIXME link
=== Packaging your application for production
Executable JARs can be used for production deployment. As they are self contained, they
are also ideally suited for cloud-based deployment.

For additional ``production ready'' features, such as health, auditing and metric REST
or JMX end-points; consider adding `spring-boot-actuator`. See XXX

// FIXME links

=== What to read next

// FIXME summary here, write this

== SpringApplication
The `SpringApplication` class provides a convenient way to bootstrap a Spring application
that will be started from a `main()` method. In many situations you can just delegate to
the static `SpringApplication.run` method:

[source,java,indent=0]
----
	public static void main(String[] args) {
		SpringApplication.run(MySpringConfiguration.class, args);
	}
----

When you application starts you should see something similar to the following:

[indent=0,subs="attributes"]
----
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::   v{spring-boot-version}

2013-07-31 00:08:16.117  INFO 56603 --- [           main] o.s.b.s.app.SampleApplication            : Starting SampleApplication v0.1.0 on mycomputer with PID 56603 (/apps/myapp.jar started by pwebb)
2013-07-31 00:08:16.166  INFO 56603 --- [           main] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@6e5a8246: startup date [Wed Jul 31 00:08:16 PDT 2013]; root of context hierarchy
2014-03-04 13:09:54.912  INFO 41370 --- [           main] .t.TomcatEmbeddedServletContainerFactory : Server initialized with port: 8080
2014-03-04 13:09:56.501  INFO 41370 --- [           main] o.s.b.s.app.SampleApplication            : Started SampleApplication in 2.992 seconds (JVM running for 3.658)
----

By default `INFO` logging messages will shown, including some relevant startup details
such as the user that launched the application.

=== Customizing SpringApplication
If the `SpringApplication` defaults aren't to your taste you can instead create a local
instance and customize it. For example, to turn off the banner you would write:

[source,java,indent=0]
----
	public static void main(String[] args) {
		SpringApplication app = new SpringApplication(MySpringConfiguration.class);
		app.setShowBanner(false);
		app.run(args);
	}
----

NOTE: The constructor arguments passed to `SpringApplication` are configuration sources
for spring beans. In most cases these will be references to `@Configuration` classes, but
they could also be references to XML configuration or to packages that should be scanned.

It is also possible to configure the `SpringApplication` using an `application.properties`
file. See XXX.

// FIXME Link

For a complete list of the configuration options, see the `SpringApplication` Javadoc.

=== Fluent builder API
If you need to build an `ApplicationContext` hierarchy (multiple contexts with a
parent/child relationship), or if you just prefer using a ``fluent'' builder API, you
can use the `SpringApplicationBuilder`.

The `SpringApplicationBuilder` allows you to chain together multiple method calls, and
includes `parent` and `child` methods that allow you to create a hierarchy.

For example:
[source,java,indent=0]
----
	new SpringApplicationBuilder()
		.showBanner(false)
		.sources(Parent.class)
		.child(Application.class)
		.run(args);
----

NOTE: There are some restrictions when creating an `ApplicationContext` hierarchy, e.g.
the parent application context is *not* a `WebApplicationContext`.  Both parent and child
are executed with the same `Environment` constructed in the usual way to include command
line arguments.  Any `ServletContextAware` components all have to go in the child
context, otherwise there is no way for Spring Boot to create the `ServletContext` in time.

=== Application events and listeners
In addition to the usual Spring Framework events, such as `ContextRefreshedEvent`, a
`SpringApplication` sends some additional application events. Some events are actually
triggered before the `ApplicationContext` is created.

You can register event listeners in a number of ways, the most common being
`SpringApplication.addListeners(...)` method (See XXX).

// FIXME

Application events are sent in the following order, as your application runs:

. An `ApplicationStartedEvent` is sent at the start of a run, but before any
  processing except the registration of listeners and initializers.
. An `ApplicationEnvironmentPreparedEvent` is sent when the `Environment` to be used in
  the context is known, but before the context is created.
. An `ApplicationPreparedEvent` is sent just before the refresh is started, but after bean
  definitions have been loaded.
. An `ApplicationFailedEvent` is sent if there is an exception on startup.

TIP: You often won't need to use application events, but it can be handy to know that they
exist. Internally, Spring Boot uses events to handle a variety of tasks.

=== Web environment
A `SpringApplication` will attempt to create the right type of `ApplicationContext` on
your behalf. By default, an `AnnotationConfigApplicationContext` or
`AnnotationConfigEmbeddedWebApplicationContext` will be used, depending on whether you
are developing a web application or not.

The algorithm used to determine a ``web environment'' is fairly simplistic (based on the
presence of a few classes). You can use `setWebEnvironment(boolean webEnvironment)` if
you need to override the default.

It is also possible to take complete control of the `ApplicationContext` type that will
be used by using `setApplicationContextClass(...)`.

TIP: It is often desirable call `setWebEnvironment(false)` when using `SpringApplication`
within a JUnit test.

=== Using the CommandLineRunner
If you want access to the raw command line argument, or you need to run some specific code
once the `SpringApplication` has started you can implement the `CommandLineRunner`
interface. The `run(String... args)` method will be called on all spring beans
implementing this interface.

[source,java,indent=0]
----
	import org.springframework.boot.*
	import org.springframework.stereotype.*

	@Component
	public class MyBean implements CommandLineRunner {

	    public void run(String... args) {
	        // Do something...
	    }

	}
----

You can additionally implement the `org.springframework.core.Ordered` interface or use the
`org.springframework.core.annotation.Order` annotation if several `CommandLineRunner`
beans are defined that must be called in a specific order.

=== Application exit
Each `SpringApplication` will register a shutdown hook with the JVM to ensure that the
`ApplicationContext` is closed gracefully on exit. All the standard Spring lifecycle
callbacks (such as the `DisposableBean` interface, or the `@PreDestroy` annotation) can
be used.

In addition, beans may implement the `org.springframework.boot.ExitCodeGenerator`
interface if they wish to return a specific exit code when the application ends.

== Externalized Configuration
Spring Boot likes you to externalize your configuration so you can work with the same
application code in different environments. You can use properties files, YAML files,
environment variables and command-line arguments to externalize configuration. Property
values can be injected directly into your beans using the `@Value` annotation, accessed
via Spring's `Environment` abstraction or bound to structured objects.

Spring Boot uses a very particular `PropertySource` order that is designed to allow
sensible overriding of values, properties are considered in the the following order:

. Command line argument
. Java System properties (`System.getProperties()`).
. OS environment variables.
. `@PropertySource` annotations on your `@Configuration` classes.
. Application properties outside of your packaged JAR (`application.properties`
  including YAML and profile variants)
. Application properties packaged inside your JAR (`application.properties`
  including YAML and profile variants)
. Default properties (specified using `SpringApplication.setDefaultProperties`)

To provide a concrete example, suppose you develop a `@Component` that uses a
`name` property:

[source,java,indent=0]
----
	import org.springframework.stereotype.*
	import org.springframework.beans.factory.annotation.*

	@Component
	public class MyBean {

	    @Value("${name}")
	    private String name;

	    // ...

	}
----

You can bundle an `application.properties` inside your jar that provides a sensible
default `name`. When running in production, an `application.properties` can be provided
outside of your JAR that overrides `name`; and for one off testing you can launch with
a specific command line switch (e.g. `java -jar app.jar --name="Spring"`).


=== Accessing command line properties
By default SpringApplication will convert any command line option arguments (starting
with ``--'', e.g. `--server.port=9000`) to a `PropertySource` and add it to the Spring
`Environment`. As mentioned above, command line properties always take precedence over
other property sources.

If you don't want command line properties to be added to the `Environment` you can disable
them using `SpringApplication.setAddCommandLineProperties(false)`.

=== Application property files
`SpringApplication` will load properties from `application.properties` files in the
following locations and add them to the Spring `Environment`:

. The current directory
. A `/config` subdir of the current directory.
. The classpath root
. A classpath `/config` package

The list is ordered by precedence (locations higher in the list override lower items).

NOTE: You can also use YAML ('.yml') files as an alternative to '.properties' (see below)

If you don't like `application.properties` as the configuration file name you can switch
to another by specifying `spring.config.name` environment property. You can also refer
to an explicit location using the `spring.config.location` environment property.

[indent=0]
----
	$ java -jar myproject.jar --spring.config.name=myproject
----

==== Profile specific properties
In addition to `application.properties` files, profile specific properties can also be
defined using the naming convention `application-{profile}.properties`.

Profile specific properties are loaded from the same locations as standard
`application.properties`, with profiles specific files overriding the default ones.

==== Placeholders in properties
The values in `application.properties` are filtered through the existing `Environment`
when they are used so you can refer back to previously defined values (e.g. from System
properties).

[indent=0]
----
	app.name: MyApp
	app.description: ${app.name} is a Spring Boot application
----

TIP: You can also use this technique to create `short` variants of existing Spring Boot
properties. See XXX


=== Using YAML instead of Properties
http://yaml.org[YAML] is a superset of JSON, and as such is a very convenient format
for specifying hierarchical configuration data. The `SpringApplication` class will
automatically support YAML as an alternative to properties whenever you have the
http://code.google.com/p/snakeyaml/[SnakeYAML] library on your classpath.

NOTE: If you use ``starter POMs'' SnakeYAML will be automatically provided via
`spring-boot-starter`.

==== Loading YAML
Spring Boot provides two convenient classes that can be used to load YAML documents. The
`YamlPropertiesFactoryBean` will load YAML as `Properties` and the `YamlMapFactoryBean`
will load YAML as a `Map`.

For example, the following YAML document:

[source,yaml,indent=0]
----
	dev:
		url: http://dev.bar.com
		name: Developer Setup
	prod:
		url: http://foo.bar.com
		name: My Cool App
----

Would be transformed into these properties:

[indent=0]
----
	environments.dev.url=http://dev.bar.com
	environments.dev.name=Developer Setup
	environments.prod.url=http://foo.bar.com
	environments.prod.name=My Cool App
----

YAML lists are represented as comma-separated values (useful for simple String values)
and also as property keys with `[index]` dereferencers, for example this YAML:

[source,yaml,indent=0]
----
	 servers:
 		- dev.bar.com
 		- foo.bar.com
----

Would be transformed into these properties:

[indent=0]
----
	servers=dev.bar.com,foo.bar.com
	servers[0]=dev.bar.com
	servers[1]=foo.bar.com
----

==== Exposing YAML as properties in the Spring Environment.
The `YamlPropertySourceLoader` class can be used to expose YAML as a `PropertySource`
in the Spring `Environment`. This allows you to the familiar `@Value` with placeholders
syntax to access YAML properties.

==== Multi-profile YAML documents
You can specify multiple profile-specific YAML document in a single file by
by using a `spring.profiles` key to indicate when the document applies. For example:

[source,yaml,indent=0]
----
	server:
		address: 192.168.1.100
	---
	spring:
		profiles: production
	server:
		address: 192.168.1.120
----

==== YAML shortcomings
YAML files can't be loaded via the `@PropertySource` annotation. So in the
case that you need to load values that way, you need to use a properties file.

=== Typesafe Configuration Properties
Using the `@Value("${property}")` annotation to inject configuration properties can
sometimes be cumbersome, especially if you are working with multiple properties or
your data is hierarchical in nature. Spring Boot provides an alternative method
of working with properties that allows strongly typed beans to govern and validate
the configuration of your application. For example:

[source,java,indent=0]
----
	@Component
	@ConfigurationProperties(name="connection")
	public class ConnectionSettings {

		private String username;

		private InetAddress remoteAddress;

		// ... getters and setters

	}
----

When the `@EnableConfigurationProperties` annotation is applied to your `@Configuration`,
any beans annotated with `@ConfigurationProperties` will automatically be configured
from the `Environment` properties. This style of configuration works particularly well
with the `SpringApplication` external YAML configuration:

[source,yaml,indent=0]
----
	# application.yml

	connection:
		username: admin
		remoteAddress: 192.168.1.1

	# additional configuration as required
----

To work with `@ConfigurationProperties` beans you can just inject them in the same way
as any other bean.

[source,java,indent=0]
----
	@Service
	public class MyService {

		@Autowired
		private ConnectionSettings connection;

	 	//...

		@PostConstruct
		public void openConnection() {
			Server server = new Server();
			this.connection.configure(server);
		}

	}
----

It is also possible to shortcut the registration of `@ConfigurationProperties` bean
definitions by simply listing the properties classes directly in the
`@EnableConfigurationProperties` annotation:

[source,java,indent=0]
----
	@Configuration
	@EnableConfigurationProperties(ConnectionSettings.class)
	public class MyConfiguration {
	}
----

==== Relaxed binding
Spring Boot uses some relaxed rules for binding `Environment` properties to
`@ConfigurationProperties` beans, so there doesn't need to be an exact match between
the `Environment` property name and the bean property name.  Common examples where this
is useful include underscore separated (e.g. `context_path` binds to `contextPath`), and
capitalized (e.g. `PORT` binds to `port`) environment properties.

Spring will attempt to coerce the external application properties to the right type when
it binds to the `@ConfigurationProperties` beans. If you need custom type conversion you
can provide a `ConversionService` bean (with bean id `conversionService`) or custom
property editors (via a `CustomEditorConfigurer` bean).

==== @ConfigurationProperties Validation
Spring Boot will attempt to validate external configuration, by default using JSR-303
(if it is on the classpath). You can simply add JSR-303 `javax.valididation` constraint
annotations to your `@ConfigurationProperties` class:

[source,java,indent=0]
----
	@Component
	@ConfigurationProperties(name="connection")
	public class ConnectionSettings {

		@NotNull
		private InetAddress remoteAddress;

		// ... getters and setters

	}
----

You can also add a custom Spring `Validator` by creating a bean definition called
`configurationPropertiesValidator`.

TIP: The `spring-boot-actuator` includes an end-point that exposes all
`@ConfigurationProperties` beans. Simply point your web browser to `/configprops`.

== Profiles
Spring Profiles are a way to segregate parts of the application configuration and make it
only available in certain environments.  Any `@Component` or `@Configuration` can be
marked with `@Profile` to limit when it is loaded:

[source,java,indent=0]
----
	@Configuration
	@Profile("production")
	public class ProductionConfiguraiton {

		// ...

	}
----

Spring Boot takes this a stage further, in that you can use a `spring.profiles.active`
`Environment` property to specify which profiles are active. You can specify the property
in any of the usual ways, for example you could include it in your
`application.properties`:

[indent=0]
----
	spring.profiles.active=dev,hsqldb
----

or specify on the command line using the switch `--spring.profiles.active=dev,hsqldb`.

=== Adding active profiles
The `spring.profiles.active` property follows the same ordering rules as other
properties, the highest `PropertySource` will win. This means that you can specify
active profiles in `application.properties` then *replace* them using the command line
switch.

Sometimes it is useful to have profile specific properties that *add* to the active
profiles rather than replace them. The `+` prefix can be used to add active profiles.

For example, when an application with following properties is run using the switch
`--spring.profiles.active=prod` the `proddb` and `prodmq` profiles will also be activated:

```yaml
---
my.property: fromyamlfile
---
spring.profiles: prod
spring.profiles.active: +proddb,+prodmq
```
=== Programmatically setting profiles
You can programmatically set active profiles by calling
`SpringApplication.setAdditionalProfiles(...)` before your application runs. It is also
possible to activate profiles using Spring's `ConfigurableEnvironment` interface.

=== Profile specific configuration files
Profile specific variants of both `application.properties` (or `application.yml`) and
files referenced via `@ConfigurationProperties` are considered as files are loaded.
See XXX and XXX for details.

== Logging
Spring Boot uses http://commons.apache.org/logging[Commons Logging] for all internal
logging, but leaves the underlying log implementation open. Default configurations are
provided for
http://docs.oracle.com/javase/7/docs/api/java/util/logging/package-summary.html[Java Util Logging],
http://logging.apache.org/log4j/[Log4J] and
http://logback.qos.ch/[Logback].
In each case there is console output and file output (rotating, 10 Mb file size).

By default, If you use the ``Starter POMs'', Logback will be used for logging. Appropriate
Logback routing is also included to ensure that dependent libraries that use
Java Util Logging, Commons Logging, Log4J or SLF4J will all work correctly.

TIP: There are a lot of logging frameworks available for Java. Don't worry if the above
list seems confusing, generally you won't need to change your logging dependencues and
the Spring Boot defaults will work just fine.

=== Log format
The default log output from Spring Boot looks like this:

[indent=0]
----
2014-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52
2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms
2014-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: 'dispatcherServlet' to [/]
2014-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]
----

The following items are output:

* Date and Time -- Millesecond precision and easily sortable
* Log Level -- `ERROR`, `WARN`, `INFO`, `DEBUG` or `TRACE`
* Process ID
* A `---` separator to distinguish the start of actual log messages
* Logger name -- This is usually the source class name (often abbreviated)
* The log message


=== Console output
The default log configuration will echo messages to the console as they written. By
default `ERROR`, `WARN` and `INFO` level messages are logged. To also log `DEBUG` level
messages to the console you can start your application with a `--debug` flag.

[indent=0]
----
	$ java -jar myapp.jar --debug
----

If your terminal supports ANSI, color output will be used to aid readability.

=== File output
By default, log files are written to `spring.log` in your `temp` directory and rotate at
10 Mb. You can easily customize the output folder by setting the `logging.path` property
(for example in your `application.properties`). It is also possible to change the filename
using a `logging.file` property.

As with console output, `ERROR`, `WARN` and `INFO` level messages are logged by default.

=== Custom log configuration

The various logging systems can be activated by including the appropriate libraries on
the classpath, and further customized by supported by providing a suitable configuration
file in the root of the classpath, or in a location specified by the Spring `Environment`
property `logging.config`.

Depending on your logging system, the following files will be loaded:

|===
|Logging System |Customization

|Logback
|`logback.xml`

|Log4j
|`log4j.properties` or `log4j.xml`

|JDK (Java Util Logging)
|`logging.properties`
|===

To help with the customization some other properties are transferred from the Spring
`Environment` to System properties:

|===
|Spring Environment |System Property |Comments

|`logging.file`
|`LOG_FILE`
|Used in default log configuration if defined

|`logging.path`
|`LOG_PATH`
|Used in default log configuration if defined

|`PID`
|`PID`
|The current process ID is discovered if possible and not already provided |
|===

All the logging systems supported can consult System properties when parsing their
configuration files.  See the default configurations in `spring-boot.jar` for examples.

WARNING: There are know classloading issues with Java Util Logging that cause problems
when running from an ``executable JAR''. We recommend that you avoid it if at all
possible.

== Developing web applications
Spring Boot is well suited for web application development. You can easily create a
self-contained HTTP server using embedded Tomcat or Jetty. Most web applications will
use the `spring-boot-starter-web` module to get up and running quickly.

If you haven't yet developed a Spring Boot web application you can follow the
"Hello World!" example in XXX

// FIXME

=== The ``Spring Web MVC framework''
The Spring Web MVC framework (often referred to as simply ``Spring MVC'') is a rich
``model view controller'' web framework. Spring MVC lets you create special `@Controller`
or `@RestController` beans to handle incoming HTTP requests. Methods in your controller
are mapped to HTTP using `@RequestMapping` annotations.

Here is a typical example `@RestController` to serve JSON data:

[source,java,indent=0]
----
	@RestController
	@RequestMapping(value="/users")
	public class MyRestController {

		@RequestMapping(value="/{user}", method=RequestMethod.GET)
		public User getUser(@PathVariable Long user) {
			// ...
		}

		@RequestMapping(value="/{user}/customers", method=RequestMethod.GET)
		List<Customer> getUserCustomers(@PathVariable Long user) {
			// ...
		}

		@RequestMapping(value="/{user}", method=RequestMethod.DELETE)
		public User deleteUser(@PathVariable Long user) {
			// ...
		}

	}
----

Spring MVC is part of the core Spring Framework and detailed information is available in
the reference documentation. There are also several guides available at
http://spring.io/guides that cover Spring MVC.

==== Spring MVC auto-configuration
Spring Boot provides auto-configuration for Spring MVC that works well with most
applications. If you want to take complete control of Spring MVC you can add your
own `@Configuration` annotated with `@EnableWebMvc`.

The auto-configuration adds the following features on top of Spring's defaults:

* Inclusion of `ContentNegotiatingViewResolver` and `BeanNameViewResolver` beans.
* Support for serving static resources, including support for WebJars (see below).
* Automatic registration of `Converter`, `GenericConverter`, `Formatter` beans.
* Support for `HttpMessageConverters` (see below).
* Static `index.html` support.
* Custom `Favicon` support.

==== HttpMessageConverters
Spring MVC uses the `HttpMessageConverter` interface to convert HTTP requests and
responses. Sensible defaults are included out of the box, for example Objects can be
automatically converted to JSON (using the Jackson library) or XML (using JAXB).

If you need to add or customize converters you can use Spring Boot's
`HttpMessageConverters` class:
[source,java,indent=0]
----
	import org.springframework.boot.autoconfigure.web.HttpMessageConverters;
	import org.springframework.context.annotation.*;
	import org.springframework.http.converter.*;

	@Configuration
	public class MyConfiguration {

		@Bean
		public HttpMessageConverters customConverters() {
			HttpMessageConverter<?> additional = ...
			HttpMessageConverter<?> another = ...
			return new HttpMessageConverters(additional, another);
		}

	}
----

==== Static Content
By default Spring Boot will serve static content from a folder called `/static` (or
`/public` or or `/resources` or `/META-INF/resources`) in the classpath or from the root
of the `ServeltContext`.  It uses the `ResourceHttpRequestHandler` from Spring MVC so you
can modify that behavior by adding your own `WebMvcConfigurerAdapter` and overriding the
`addResourceHandlers` method.

In a stand-alone web application the default servlet from the container is also
enabled, and acts as a fallback, serving content from the root of the `ServletContext` if
Spring decides not to handle it. Most of the time this will not happen unless you modify
the deafult MVC configuration because Spring will always be able to handle requests
through the `DispatcherServlet`.

In addition to the ``standard'' static resource locations above, a special case is made for
http://www.webjars.org/[Webjars content]. Any resources with a path in `/webjars/**` will
be served from jar files if they are packaged in the Webjars format.

TIP: Do not use the `src/main/webapp` folder if your application will be packaged as a
JAR. Although this folder is a common standard, it will *only* work with WAR packaging
and it will be silently ignored by most build tools if you generate a JAR.

==== Template engines
As well as REST web service, you can also use Spring MVC to service dynamic HTML content.
Spring MVC supports a variety of templating technologies including: velocity, freemarker,
and JSPs. Many other templating engines also ship their own Spring MVC integrations.

Spring Boot includes auto-configuration support for the Thymeleaf templating engine.
Thymeleaf is an XML/XHTML/HTML5 template engine that can work both in web and non-web
environments. If allows you to create natural templates, that can be correctly displayed
by browsers and therefore work also as static prototypes. Thymeleaf templates will be
picked up automatically from `src/main/resources/templates`.

TIP: JSPs should be avoided if possible, there are several known limitations when using
them with embdedded servlet containers.

=== Embedded servlet container support
Spring Boot includes support for embedded Tomcat and Jetty servers. Most developers will
simply use the appropriate ``Starter POM'' to obtain a fully configured instance. By
default both Tomcat and Jetty will listen for HTTP requests on port `8080`.

==== Servlets and Filters
When using an embedded servlet container you can register Servlets and Filters directly as
Spring beans. This can be particularly convenient if you want to refer to a value from
your `application.properties` during configuration.

By default, if the context contains only a single Servlet it will be mapped to `/`. In
the case of multiple Servlets beans the bean name will be used as a path prefix. Filters
will map to `/*`.

If convention based mapping is not flexible enough you can use the
`ServletRegistrationBean` and `FilterRegistrationBean` classes for complete control. You
can also register items directly if your bean implements the `ServletContextInitializer`
interface.

==== The EmbeddedWebApplicationContext
Under the hood Spring Boot uses a new type of `ApplicationContext` for embedded
servlet container support.  The `EmbeddedWebApplicationContext` is a special
type of `WebApplicationContext` that bootstraps itself by searching for a single
`EmbeddedServletContainerFactory` bean. Usually a `TomcatEmbeddedServletContainerFactory`
or `JettyEmbeddedServletContainerFactory` will have been auto-configured.

NOTE: You usually won't need to be aware of these implementation classes. Most
applications will be auto-configured and the appropriate `ApplicationContext` and
`EmbeddedServletContainerFactory` will be created on your behalf.


==== Customizing embedded servlet containers
Common servlet container settings can be configured using Spring `Environment`
properties. Usually you would define the properties in your `application.properties`
file.

Common server settings include:

* `server.port` -- The listen port for incoming HTTP requests.
* `server.address` -- The interface address to bind to/
* `server.sessionTimeout` -- A session timeout

See the `ServerProperties` class for a complete list.

===== Programmatic customization
If you need to configure your embdedded servlet container programmatically you can register
a Spring bean that implements the `EmbeddedServletContainerCustomizer` interface.
`EmbeddedServletContainerCustomizer` provides access to the
`ConfigurableEmbeddedServletContainerFactory` which includes numerous customization
setter methods.

[source,java,indent=0]
----
	import org.springframework.boot.context.embedded.*;
	import org.springframework.stereotype.Component;

	@Component
	public class CustomizationBean implements EmbeddedServletContainerCustomizer {

		@Override
		public void customize(ConfigurableEmbeddedServletContainer container) {
			container.setPort(9000);
		}

	}
----

===== Customizing ConfigurableEmbeddedServletContainerFactory directly
If the above customization techniques are too limited, you can register the
`TomcatEmbeddedServletContainerFactory` or `JettyEmbeddedServletContainerFactory` bean
yourself.

[source,java,indent=0]
----
	@Bean
	public EmbeddedServletContainerFactory servletContainer() {
		TomcatEmbeddedServletContainerFactory factory = new TomcatEmbeddedServletContainerFactory();
		factory.setPort(9000);
		factory.setSessionTimeout(10, TimeUnit.MINUTES);
		factory.addErrorPages(new ErrorPage(HttpStatus.404, "/notfound.html");
		return factory;
	}
----

Setters are provided for many configuration options. Several protected method
``hooks'' are also provided should you need to do something more exotic. See the
source code documentation for details.

==== JSP limitations
When running a Spring Boot application that uses an embedded servlet container (and is
packaged as an executable archive), there are some limitations in the JSP support.

* With Tomcat it should work if you use WAR packaging, i.e. an executable WAR will work,
  and will also be deployable to a standard container (not limited to, but including
  Tomcat). An executable JAR will not work because of a hard coded file pattern in Tomcat.

* Jetty does not currently work as an embedded container with JSPs.

There is a JSP sample so you can see how to set things up.
// FIXME link to sample
// FIXME  Create a deployable WAR file ?

== Working with SQL databases
The Spring Framework provides extensive support for working with SQL databases. From
direct JDBC access using `JdbcTemplate` though to complete ``object relational mapping''
technologies such as Hibernate. Spring Data provides an additional level of functionality,
creating `Repoistory` implementations directly from interfaces and using conventions to
generate queries from your method names.

=== Configure a DataSource
Java's `javax.sql.DataSource` interface provides a standard method of working with
database connections. Traditionally a DataSource uses a `URL` along with some
credentials to establish a database connection.

==== Embedded Database Support
It's often convenient develop applications using an in-memory embedded database.
Obviously, in-memory databases do not provide persistent storage; you will need to
populate your database when your application starts and be prepared to throw away
data when your application ends.

TIP: The ``How-to'' section includes a used section on how to initialize a database

// FIME XXX

Spring Boot can auto-configure embedded `H2`, `HSQL` and `Derby` databases. You don't
need to provide any connection URLs, simply include a build dependency to the
embedded database that you want to use.

For example, typical POM dependencies would be:

[source,xml,indent=0]
----
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-data-jpa</artifactId>
	</dependency>
	<dependency>
		<groupId>org.hsqldb</groupId>
		<artifactId>hsqldb</artifactId>
		<scope>runtime</scope>
	</dependency>
----

NOTE: You need a dependency on `spring-jdbc` for embedded database to be auto-configured.
In this example it's pulled in transitively via `spring-boot-starter-data-jpa`.

==== Connection to a production database
Production database connections can also be auto-configured using a pooling
`DataSource`.  Here's the algorithm for choosing a specific implementation.

* We prefer the Tomcat pooling `DataSource` for its performance and concurrency, so if
  that is available we always choose it.
* If commons-dbcp is available we will use that, but we don't recommend it in production.

If you use the `spring-boot-starter-jdbc` or `spring-boot-starter-data-jpa`
``starter POMs'' you will automcatically get a dependency to `tomcat-jdbc`.

NOTE: Additional connection pools can always be configured manually, if you define your
own `DataSource` bean that auto-configuration will not occur.

DataSource configuration controlled by external configuration properties in
`spring.datasource.*` for example, you might declare the following section
in `application.properties`:

[indent=0]
----
	spring.datasource.url: jdbc:mysql://localhost/test
	spring.datasource.username: dbuser
	spring.datasource.password: dbpass
	spring.datasource.driverClassName: com.mysql.jdbc.Driver
----

See `AbstractDataSourceConfiguration` for more of the supported options.

NOTE: For a pooling `DataSource` to be created we need to be able to verify that a valid
`Driver` class is available, so we check for that before doing anything. I.e. if you set
`spring.datasource.driverClassName=com.mysql.jdbc.Driver` then that class has to be
loadable.

=== Using JdbcTemplate
Spring's `JdbcTemplate` and `NamedParameterJdbcTemplate` classes are auto-configured and
you can `@Autowire` them directly into your own beans:

[source,java,indent=0]
----
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.jdbc.core.JdbcTemplate;
	import org.springframework.stereotype.Component;

	@Component
	public class MyBean {

		private final JdbcTemplate jdbcTemplate;

		@Autowired
		public MyBean(JdbcTemplate jdbcTemplate) {
			this.jdbcTemplate = jdbcTemplate;
		}

		// ...

	}
----

=== JPA and ``Spring Data''
The Java Persistence API is a standard technology that allows you to ``map'' objects to
relational databases. The `spring-boot-starter-data-jpa` POM provides a quick way to get
started. It provides the following key dependencies:

* Hibernate -- One of the most popular JPA implementations.
* Spring Data JPA -- Makes it easy to easily implement JPA based repositories.
* Spring ORMs -- Core ORM support from the Spring Framework.
* Hibernate Validator -- Annotation based validation for your entities.

TIP: We won't go into too many details of JPA or Spring Data here. You can follow the
``Accessing Data with JPA'' guide from http://spring.io and read the Spring Data JPA and
Hibernate reference documentation.

==== Entity Classes
Traditionally JPA ``Entity'' classes are specified in a `persistence.xml` file. With
Spring Boot this file is not necessary as it performs ``Entity Scanning''. By default
all packages below your main configuration class (the one annotated with
`@EnableAutoConfiguration`) will be searched.

Any classes annotated with `@Entity`, `@Embeddable` or `@MappedSuperclass` will be
considered. A typical entity class would look something like this:

[source,java,indent=0]
----
package com.example.myapp.domain;

import java.io.Serializable;
import javax.persistence.*;

@Entity
public class City implements Serializable {

	@Id
	@GeneratedValue
	private Long id;

	@Column(nullable = false)
	private String name;

	@Column(nullable = false)
	private String state;

	// ... additional members, often include @OneToMany mappings

	protected City() {
		// no-args constructor required by JPA spec
		// this one is protected since it shouldn't be used directly
	}

	public City(String name, String state) {
		this.name = name;
		this.country = country;
	}

	public String getName() {
		return this.name;
	}

	public String getState() {
		return this.state;
	}

	// ... etc

}
----

TIP: You can customize entity scanning locations using the `@EntityScan` annotation.
See XXX.

==== Spring Data JPA Repositories
Spring Data JPA repositories are interfaces that you can define to access data. JPA
queries are created automatically from your method names. For example, a `CityRepoistory`
interface might declare a `findAllByState(String state)` method to find all cities
in a given state.

For more complex queries you can annotate your method using the
`org.springframework.data.jpa.repository.Query` annotation.

Spring Data repositories usually extend from the
`org.springframework.data.repository.Repository` or
`org.springframework.data.repository.CrudRepository` interfaces. If you are using
auto-configuration, repositories will be searched from the package containing your
main configuration class (the one annotated with `@EnableAutoConfiguration`) down.

Here is a typical Spring Data repository:

[source,java,indent=0]
----
	package com.example.myapp.domain;

	import org.springframework.data.domain.*;
	import org.springframework.data.repository.*;

	public interface CityRepository extends Repository<City, Long> {

		Page<City> findAll(Pageable pageable);

		City findByNameAndCountryAllIgnoringCase(String name, String country);

	}
----

TIP: We have barely scratched the surface of Spring Data JPA. For complete details check
the reference documentation.

==== Validation
The `spring-boot-starter-data-jpa` ``Starter POM'' includes a dependency on
Hibernate Validator. This means that you can use JSR-303 annotations such
as `@NotNull`, `@Min`, `@Size` etc. directly on your `@Entity` class fields.

For more information refer to the Hibernate Validator reference documentation.

==== Creating and dropping JPA databases
By default JPA database will be automatically created *only* if you use an embedded
database (H2, HSQL or Derby). You can explicitly configure JPA settings using
`spring.jpa.*` properties. For example, to create and drop tables you can add the
following to your `application.properties`.

[indent=0]
----
	spring.jpa.hibernate.ddl-auto: create-drop
----

== Working with NoSQL technologies
Spring Data provides additional projects that help you access a variety of NoSQL
technologies including MongoDB, Neo4J, Redis, Gemfire, Couchbase and Cassandra.
Spring Boot provides auto-configuration for MongoDB; you can make use of the other
project, but you will need to configure them yourself. Refer to the appropriate
reference documentation at http://projects.spring.io/spring-data.

=== MongoDB
MongoDB is an open-source NoSQL document database that uses a JSON-like schema instead
of traditional table-based relational data. Spring Boot offers several conveniences
for working with MongoDB, including the The `spring-boot-starter-data-mongodb`
``Starter POM''.

==== Connecting to a MongoDB database
You can inject an auto-configured `com.mongodb.Mongo` instance as you would any other
Spring Bean. By default the instance will attempt to connect to a MongoDB server using
the URL `mongodb://localhost/test`:

[source,java,indent=0]
----
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.mongodb.Mongo;

@Component
public class MyBean {

	private final Mongo mongo;

	@Autowired
	public MyBean(Mongo mongo) {
		this.mongo = mongo;
	}

	// ...

}
----

You can set `spring.data.mongodb.url` property to change the `url`, or alternatively
specify a `host`/`port`. For example, you might declare the following in your
`application.properties`:

[indent=0]
----
	spring.data.mongodb.host = mongoserver
	spring.data.mongodb.port = 27017
----

TIP: If `spring.data.mongodb.port` is not specified the default of `27017` is used. You
could simply delete this line from the sample above.

You can also declare your own `Mongo` `@Bean` if you want to take complete control of
establishing the MongoDB connection.

==== MongoTemplate
Spring Data Mongo provides a `MongoTemplate` class that is very similar in its design to
Spring's `JdbcTemplate`. As with `JdbcTemplate` Spring Boot auto-configures a bean
for you to simply inject:

[source,java,indent=0]
----
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.data.mongodb.core.MongoTemplate;
	import org.springframework.stereotype.Component;

	@Component
	public class MyBean {

		private final MongoTemplate mongoTemplate;

		@Autowired
		public MyBean(MongoTemplate mongoTemplate) {
			this.mongoTemplate = mongoTemplate;
		}

		// ...

	}
----

See the `MongoOperations` Javadoc for complete details.

==== Spring Data MongoDB repositories
Spring Data includes repository support for MongoDB. As with the JPA repositories
discussed earlier, the basic principal is that queries are constructed for you
automatically based on method names.

In fact, both Spring Data JPA and Spring Data MongoDB share the same common
infrastructure; so you could take the JPA example from earlier and, assuming that
`City` is now a Mongo data class rather than a JPA `@Entity`, it will work in the
same way.

[source,java,indent=0]
----
	package com.example.myapp.domain;

	import org.springframework.data.domain.*;
	import org.springframework.data.repository.*;

	public interface CityRepository extends Repository<City, Long> {

		Page<City> findAll(Pageable pageable);

		City findByNameAndCountryAllIgnoringCase(String name, String country);

	}
----

TIP: For complete details of Spring Data MongoDB, including its rich object mapping
technologies, refer to the documentation.


== Testing
Spring Boot provides a number of useful tools for testing your application. The
`spring-boot-starter-parent` POM provides JUnit, Hamcrest and Mockito ``test'' `scope`
dependencies. There are also useful test utilities in the core `spring-boot` modules
under the `org.springframework.boot.test` package. There is also a
`spring-boot-starter-test` ``Starter POM''.

=== Test scope dependencies
If you extend your Maven project from the `spring-boot-starter-parent` POM, or use the
`spring-boot-starter-test` ``Starter POM'' (in the ``test'' `scope`), you will find
the following provided libraries:

* Junit -- The de-facto standard for unit testing Java applications.
* Hamcrest -- A library of matcher objects (also known as constraints or predicates)
  allowing `assertThat` style JUnit assertions.
* Mockito -- A Java mocking framework.

These are common libraries that we generally find useful when writing Tests. You are free
to add or replace them if they don't suit your needs.

=== Testing Spring applications
One of the major advantages of dependency injection is that it should make your code
easier to unit test. You can simply instantiate objects using the `new` operator without
even involving Spring. You can also use _mock objects_ instead of real dependencies.

Often you need to move beyond ``unit testing'' and start ``integration testing'' (with
a Spring `ApplicationContext` actually involved in the process). It's useful to be able
to perform integration testing without requiring deployment of your application or
needing to connect to other enterprise infrastructure.

The Spring Framework includes a dedicated test module for just such integration testing.
You can declare a dependency directly to `org.springframework:spring-test` or use the
`spring-boot-starter-test` ``Starter POM'' to pull it in transitively.

If you have not use the `spring-test` module before you should start by reading the
relevant section of the Spring Framework reference documentation.

=== Testing Spring Boot applications
A Spring Boot application is just a Spring `ApplicationContext` so nothing very special
has to be done to test it beyond what you would normally do with a vanilla Spring context.
One thing to watch out for though is that the external properties, logging and other
features of Spring Boot are only installed in the context by default if you use
`SpringApplication` to create it.

Spring Boot provides a `@SpringApplicationConfiguration` annotation as an alternative
to the standard `spring-test` `@ContextConfiguration` annotation. If you use
`@SpringApplicationConfiguration` to configure the `ApplicationContext` used in your
tests, it will be created via `SpringApplication` and you will get the additional Spring
Boot features.

For example:
[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	@RunWith(SpringJUnit4ClassRunner.class)
	@SpringApplicationConfiguration(classes = SampleDataJpaApplication.class)
	public class CityRepositoryIntegrationTests {

		@Autowired
		CityRepository repository;

		// ...

	}
----

TIP: The context loader guesses whether you want to test a web application or not (e.g. with
`MockMVC`) by looking for the `@WebAppConfiguration` annotation.  (`MockMVC` and
`@WebAppConfiguration` are part of `spring-test`).

=== Test utilities
A few test utility classes are packaged as part of `spring-boot` that are generally
useful when testing your application.

==== ConfigFileApplicationContextInitializer
`ConfigFileApplicationContextInitializer` is an `ApplicationContextInitializer` that
can apply to your tests to load Spring Boot `application.properties` files. You can use
when you don't need the full features provided by `@SpringApplicationConfiguration`.

[source,java,indent=0]
----
	@ContextConfiguration(classes = Config.class,
		initializers = ConfigFileApplicationContextInitializer.class)
----

==== EnvironmentTestUtils
`EnvironmentTestUtils` allows you to quickly add properties to a
`ConfigurableEnvironment` or `ConfigurableApplicationContext`. Simply call it with
`key=value` strings:

[source,java,indent=0]
----
EnvironmentTestUtils.addEnvironment(env, "org=Spring", "name=Boot");
----

==== OutputCapture
`OutputCapture` is a JUnit `Rule` that you can use to capture `System.out` and
`System.err` output. Simply declare the capture as a `@Rule` then use `toString()`
for assertions:

[source,java,indent=0]
----
import org.junit.Rule;
import org.junit.Test;
import org.springframework.boot.test.OutputCapture;

import static org.hamcrest.Matchers.*;
import static org.junit.Assert.*;

public class MyTest {

	@Rule
	public OutputCapture capture = new OutputCapture();

	@Test
	public void testName() throws Exception {
		System.out.println("Hello World!");
		assertThat(capture.toString(), containsString("World"));
	}

}
----

== Production-ready features
Spring Boot includes a number of additional features to help you monitor and manage your
application when it's pushed to production. You can choose to manage and monitor your
application using HTTP endpoints, with JMX or even by remote shell (SSH or Telnet).
Auditing, health and metrics gathering can be automatically applied to your application.

=== Enabling production-ready features.
The `spring-boot-actuator` project provides all of Spring Boot's production-ready
features. The simplist way to enable the features is to add a dependency to the
`spring-boot-starter-actuator` ``Starter POM''.

.Definition of Actuator
****
An actuator is a manufacturing term, referring to a mechanical device for moving or
controlling something. Actuators can generate a large amount of motion from a small
change.
****

To add the actuator to a Maven based project, add the following ``starter''
dependency:

[source,xml,indent=0]
----
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>
	</dependencies>
----

For Gradle, use the declaration:

[source,groovy,indent=0]
----
	dependencies {
		compile("org.springframework.boot:spring-boot-starter-actuator")
	}
----

=== Endpoints
Actuator endpoints allow you to monitor and interact with your application. Spring Boot
includes a number of built-in endpoints and you can also add your own. For example the
`health` endpoint provides basic application health information.

The way that enpoints are exposed will depend on the type of technology that choose.
Most applications choose HTTP monitoring, where the ID of the endpoint is mapped
to a URL. For example, by default, the `health` endpoint will be mapped to `/health`.

The following endpoints are available:

[cols="1,1,7"]
|===
| ID | Sensitive | Description

|`autoconfig`
|true
|Displays an auto-configuration report showing all auto-configuration candidates and the
 reason why they ``were'' or ``were not'' applied.

|`beans`
|true
|Displays a complete list of all the Spring Beans in your application.

|`configprops`
|true
|Displays a collated list of all `@ConfigurationProperties`.

|`dump`
|true
|Performs a thread dump

|`env`
|true
|Exposes properties from Spring's `ConfigurableEnvironment`.

|`health`
|false
|Shows application health information (defaulting to a simple ``OK'' message).

|`info`
|false
|Displays arbitrary application info.

|`metrics`
|true
|Shows ``metrics'' information for the current application.

|`mappings`
|true
|Displays a collated list of all `@RequestMapping` paths.

|`shutdown`
|true
|Allows the application to be gracefully shutdown (not enabled by default)

|`trace`
|true
|Displays trace information (by default the last few HTTP requests)

|===

NOTE: Depending on how an endpoint is exposed, the `sensitive` parameter may be used as
a security hint. For example, sensitive endpoints will require a username/password when
they are accessed over HTTP (or simply disabled if web security is not enabled).

==== Customizing endpoints
Endpoints can be customized using Spring properties. You can change the if an endpoint is
`enabled`, if it is considered `sensitive` and even its `id`.

For example, here is an `application.properties` that changes the sensitivity and id
of the `beans` endpoint and also enables `shutdown`.

[indent=0]
----
	endpoints.beans.id=springbeans
	endpoints.beans.sensitive=false
	endpoints.shutdown.enabled=true
----

NOTE: The prefix "`endpoints` + `.` + `name`" is used to uniquely identify the endpoint
that is being configured.

==== Custom health information
The default information exposed by the `health` endpoint is a simple ``OK'' message. It
is often useful to perform some additional health checks, for example you might check
that a database connection works, or that a remote REST endpoint is functioning.

To provide custom health information you can register a Spring bean that implements the
`HealthIndicator` interface.

[source,java,indent=0]
----
	import org.springframework.boot.actuate.health.HealthIndicator;
	import org.springframework.stereotype.Component;

	@Component
	public class MyHealth implements HealthIndicator<String> {

		@Override
		public String health() {
			// perform some specific health check
			return ...
		}

	}
----

Spring Boot also provides a `SimpleHealthIndicator` implementation that attempts a simple
database test.

==== Custom application info information
You can customize the data exposed by the `info` endpoint by settings `info.*` Spring
properties. All `Environment` properties under the info key will be automatically
exposed. For example, you could add the following to your `application.properties`:

[indent=0]
----
	info.app.name: MyService
	info.app.description: My awesome service
	info.app.version: 1.0.0
----

If you are using Maven, you can automatically populate info properties from the project
using resource filtering. In your `pom.xml` you have (inside the `<build/>` element):

[source,xml,indent=0]
----
    <resources>
        <resource>
            <directory>src/main/resources</directory>
            <filtering>true</filtering>
        </resource>
    </resources>
----

You can then refer to your Maven ``project properties'' via placeholders, e.g.

[indent=0]
----
	project.artifactId: myproject
	project.name: Demo
	project.version: X.X.X.X
	project.description: Demo project for info endpoint
	info.build.artifact: ${project.artifactId}
	info.build.name: ${project.name}
	info.build.description: ${project.description}
	info.build.version: ${project.version}
----

NOTE: In the above example we used `project.*` to set some values to be used as
fallbacks if the Maven resource filtering has for some reason not been switched on.

===== Git commit information
Another useful feature of the `info` endpoint is its ability to publish information
about the state of your `git` source code repository when the project was built. If a
`git.properties` file is contained in your JAR the `git.branch` and `git.commit`
properties will be loaded.

For Maven users the `spring-boot-starter-parent` POM includes a pre-configured plugin to
generate a `git.properties` file. Simply add the following declaration to your POM:

[source,xml,indent=0]
----
	<build>
		<plugins>
			<plugin>
				<groupId>pl.project13.maven</groupId>
				<artifactId>git-commit-id-plugin</artifactId>
			</plugin>
		</plugins>
	</build>
----

A similar https://github.com/ajoberstar/gradle-git[`gradle-git`] plugin is also available
for Gradle users, although a little more work is required to generate the properties file.

=== Monitoring and management over HTTP
If you are developing a Spring MVC application, Spring Boot Actuator will auto-configure
all non-sensitive endpoints to be exposed over HTTP. The default convention it to use the
`id` of the endpoint as the URL path. For example, `health` is exposed as `/health`.

==== Exposing sensitive endpoints
If you use ``Spring Security'' sensitive endpoints will also be exposed over HTTP. By
default ``basic'' authentication will be used with the username `user` and a generated
password.

TIP: Generated passwords a logged as the application starts. Search for ``Using default
password for application endpoints''.

You can use Spring properties to change the username and passsword and to change the
security role required to access the endpoints. For example, you might set the following
in your `application.properties`:

[indent=0]
----
	security.user.name=admin
	security.user.password=secret
	management.security.role=SUPERUSER
----

==== Customizing the management server context path
Sometimes it is useful to group all management endpoints under a single path. For example,
your application might already use `/info` for another purpose. You can use the
`management.contextPath` property to set a prefix for your manangement endpoint:

[indent=0]
----
	management.contextpath=/manage
----

The `application.properties` example above will change the endpoint from `/{id}` to
`/manage/{id}` (e.g. `/manage/info`).

==== Customizing the management server port
Exposing management endpoints using the default HTTP port is a sensible choice for cloud
based deployments. If, however, your application runs inside your own data center you
may prefer to expose endpoints using a different HTTP port.

The `management.port` property can be used to change the HTTP port. Since your management
port is often protected by a firewall, and not exposed to the public, you might also
want to disable management security:

[indent=0]
----
	management.port=8081
	management.security.enabled=false
----

==== Customizing the management server address
You can customize the address that the management endpoints are available on by
setting the `management.security.address` property. This can be useful if you want to
listen only on an internal or ops-facing network, or to only listen for connections from
`localhost`.


NOTE: You can only listen on a different address if the port is different to the
main server port.

Here is an example `application.properties` that will not allow remote management
connections:

[indent=0]
----
	management.port=8081
	management.address=127.0.0.1
----

==== Disabling HTTP endpoints
If you don't want to expose endpoints over HTTP you can set the management port to `-1`:

[indent=0]
----
	management.port=-1
----

=== Monitoring and management over JMX
Java Management Extensions (JMX) provide a standard mechanism to monitor and manage
applications. By default Spring Boot will expose management endpoints as JMX MBeans
under the `org.springframework.boot` domain.

==== Customizing MBean names
By default, the name of the MBean is generated from the `id` of the endpoint. For example
the `health` endpoint is exposed as `org.springframework.boot/Endpoint/HealthEndpoint`.

If your application contains more than one Spring `ApplicationContext` you may find that
names clash. To solve this problem you can set the `endpoints.jmx.uniqueNames` property
so that MBean names are always unique.

You can also customize the JMX domain under which endpoints are exposed. Here is an
example `application.properties`:

[indent=0]
----
	endpoints.jmx.domain=myapp
	endpoints.jmx.uniqueNames=true
----

==== Disabling JMX endpoints
If you don't want to expose endpoints over JMX you can set the `spring.jmx.enabled`
property:

[indent=0]
----
	spring.jmx.enabled=false
----

==== Using Jolokia for JMX over HTTP
Jolokia is a JMX-HTTP bridge giving an alternative method of accessing JMX beans. To
use Jolokia, simply include a dependency to `org.jolokia:jolokia-core`. For example,
using Maven you you add the following:

[source,xml,indent=0]
----
	<dependency>
		<groupId>org.jolokia</groupId>
		<artifactId>jolokia-core</artifactId>
 	</dependency>
----

Jolokia can then be accessed using `/jolokia` on your management HTTP server.

===== Customizing Jolokia
Jolokia has a number of settings that you would traditionally configure using servlet
parameters parameters. With Spring Boot you can use your `application.properties`, simply
prefix the paramter with `jolokia.config.`:

[indent=0]
----
	jolokia.config.debug=true
----

===== Disabling Jolokia
If you are using Jolokia but you don't want Spring Boot to configure it, simply set the
`endpoints.jolokia.enabled` property:

[indent=0]
----
	jolokia.config.enabled=false
----

=== Monitoring and management using a remote shell
Spring Boot supports an integrated Java shell called ``CRaSH''. You can use CRaSH to
`ssh` or `telnet` into your running application. To enable remote shell support add a
dependency to `spring-boot-starter-shell-remote`:

[source,xml,indent=0]
----
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-shell-remote</artifactId>
 	</dependency>
----

TIP: If you want to also enable telnet access your will additionally need a dependency
on `org.crsh:crsh.shell.telnet`.

==== Connecting to the remote shell
By default the remote shell will listen for connections on port `2000`. The default user
is `user` and the default password will be randomly generated and displayed in the log
output, you should see a message like this:

[indent=0]
----
	Using default password for shell access: ec03e16c-4cf4-49ee-b745-7c8255c1dd7e
----

Linux and OSX users can use `ssh` to connect to the remote shell, Windows users can
download and install PuTTY.

[indent=0,subs="attributes"]
----
	$ ssh -p 2000 user@localhost

	user@localhost's password:
	  .   ____          _            __ _ _
	 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
	( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
	 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
	  '  |____| .__|_| |_|_| |_\__, | / / / /
	 =========|_|==============|___/=/_/_/_/
	 :: Spring Boot ::  (v{spring-boot-version}) on myhost
----

Type `help` for a list of commands. Spring boot provides `metrics`, `beans` and
`autoconfig` commands. You can also use the `jmx` command to query endpoint data:

[indent=0]
----
	jmx find -p org.springframework.boot:type=Endpoint,name=healthEndpoint | jmx get Data
----

===== Remote shell credentials
You can use the `shell.auth.simple.username` and `shell.auth.simple.password` properties
to configure custom connection credentials. It is also possible to use a
``Spring Security'' `AuthenticationManager` to handle login duties. See the
`CrshAutoConfiguration` and `ShellProperties` Javadoc for full details.

==== Extending the remote shell
The remote shell can be extended in a number of interesting ways.

===== Commands
You can write additional shell commands using Groovy or Java (see the CRaSH documentation
for details). By default Spring Boot will search for commands in the following locations:

* `classpath*:/commands/**`
* `classpath*:/crash/commands/**`

TIP: You can change the search path by settings a `shell.commandpathpatterns` property.

Here is a simple hello world command that could be loaded from
`src/main/resources/commands/Hello.groovy`

[source,groovy,indent=0]
----
	package commands

	import org.springframework.boot.actuate.endpoint.BeansEndpoint

	class hello {

		@Usage("Say Hello")
		@Command
		def main(InvocationContext context) {
			return "Hello"
		}

	}
----

Spring Boot adds some additional attributes to `InvocationContext` that you can access
from your command:

[cols="1,3"]
|===
| Attribute Name | Description

|`spring.boot.version`
|The version of Spring Boot

|`spring.version`
|The version of the core Spring Framework

|`spring.beanFactory`
|Access to the Spring `BeanFactory`

|===

===== Plugins
In addition to new commands, it is also possible to extend other CRaSH shell features.
All Spring Beans that extends `org.crsh.plugin.CRaSHPlugin` will be automatically
registered with the shell.

For more information please refer to the CRaSH reference documentation.

=== Metrics
Spring Boot Actuator includes a metric service with ``gauge'' and ``counter'' support.
A ``gauge'' records a single value; and a ``counter'' records a delta (an increment or
decrement). Metrics for all HTTP requests are automatically recorded, so if you hit the
`metrics` endpoint should should see a response similar to this:

[source,json,indent=0]
----
	{
		"counter.status.200.root": 20,
		"counter.status.200.metrics": 3,
		"counter.status.401.root": 4,
		"gauge.response.root": 2,
		"gauge.response.metrics": 3,
		"mem": 466944,
		"mem.free": 410117,
		"processors": 8
	}
----

Here we can see basic `memory` and `processor` information along with some HTTP metrics.
In this instance the `root` (``/'') and `/metrics` URLs have returned `HTTP 200` responses
`20` and `3` times respectively. It also appears that the `root` URL returned `HTTP 401`
(unauthorized) `4` times.

The `gauge` shows the last response time for a request. So the last request to `root` took
`2ms` to respond and the last to `/metrics` took `3ms`.

NOTE: In this example we are actually accessing the endpoint over HTTP using the
`/metrics` URL, this explains why `metrics` appears in the response.

==== Recording your own metrics
To record your own metrics inject a
`org.springframework.boot.actuate.metrics.CounterService` and/or
`org.springframework.boot.actuate.metrics.GaugeService` into
your bean. The `CounterService` exposes `increment`, `decrement` and `reset` methods; the
`GaugeService` provides a `submit` method.

Here is a simple example that counts the number of times that a method is invoked:

[source,java,indent=0]
----
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.boot.actuate.metrics.CounterService;
	import org.springframework.stereotype.Service;

	@Service
	public class MyService {

		private final CounterService counterService;

		@Autowired
		public MyService(CounterService counterService) {
			this.counterService = counterService;
		}

		public void exampleMethod() {
			this.counterService.increment("services.system.myservice.invoked");
		}

	}
----

TIP: You can use any string as a metric name but you following guidelines of your chosen
store/graphing technology. Some good guidelines for Graphite are available on
http://matt.aimonetti.net/posts/2013/06/26/practical-guide-to-graphite-monitoring/[Matt Aimonetti's Blog].

==== Metric repositories
Metric service implementations are usually bound to a `MetricRepoistory`. A
`MetricRepoistory` is responsible for storing and retrieving metric information. Spring
Boot provides an `InMemoryMessageRespository` and a `RedisMetricRepository` out of the
box (the in-memory repository is the default) but you can also write your own. The
`MetricRepository` interface is actually composed of higher level `MetricReader` and
`MetricWriter` interfaced. For full details refer to the Javadoc.

==== Coda Hale Metrics
User of the Coda Hale ``Metrics'' library will automatically find the Spring Boot metrics
are published to `com.codahale.metrics.MetricRegistry`. A default
`com.codahale.metrics.MetricRegistry` Spring bean will be created when you declare a
dependency to the `com.codahale.metrics:metrics-core` library; you can also register you
own `@Bean` instance if you need customizations.

Users can create Codahale metrics by prefixing their metric names with the appropriate
type (e.g. `histogram.*`, `meter.*`).

==== Message channel integration
If the ``Spring Messaging'' JAR is on your classpath a `MessageChannel` called
`metricsChannel` is automatically created (unless one already exists). All metric update
events are additionally published as ``messages'' on that channel. Additional analysis or
actions can be taken by clients subscribing to that channel.

=== Auditing
Spring Boot Actuator has a flexible audit framework that will publish events once Spring
Security is in play (authentication success and failure and access denied exceptions by
default). This can be very useful for reporting, and also to implement a lock-out policy
based on authentication failures.

You can also choose to use the audit services for your own business events. To do that
you can either inject the existing `AuditEventRepository` into your own components and
use that directly, or you can simply publish `AuditApplicationEvent` via the Spring
`ApplicationContext` (using `ApplicationEventPublisherAware`).

=== Tracing
Tracing is automatically enable for all HTTP requests. You can view the `trace` endpoint
and obtain basic information about the last few requests:

[source,json,indent=0]
----
	[{
		"timestamp": 1394343677415,
		"info": {
			"method": "GET",
			"path": "/trace",
			"headers": {
				"request": {
					"Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
					"Connection": "keep-alive",
					"Accept-Encoding": "gzip, deflate",
					"User-Agent": "Mozilla/5.0 Gecko/Firefox",
					"Accept-Language": "en-US,en;q=0.5",
					"Cookie": "_ga=GA1.1.827067509.1390890128; ..."
					"Authorization": "Basic ...",
					"Host": "localhost:8080"
				},
				"response": {
					"Strict-Transport-Security": "max-age=31536000 ; includeSubDomains",
					"X-Application-Context": "application:8080",
					"Content-Type": "application/json;charset=UTF-8",
					"status": "200"
				}
			}
		}
	},{
		"timestamp": 1394343684465,
		...
    }]
----

==== Custom tracing
If you need to trace additional events you can inject a
`org.springframework.boot.actuate.trace.TraceRepository` into your Spring Beans.
The `add` method accepts a single `Map` structure that will be converted to JSON and
logged.

By default an `InMemoryTraceRepository` will be used that stores the last 100 events. You
can define your own instance of the `InMemoryTraceRepository` bean if you need to expand
the capacity. You can also create your own alternative `TraceRepository` implementation
if needed.

=== Error Handling

Spring Boot Actuator provides an `/error` mapping by default that handles all errors in a
sensible way.  If you want more specific error pages for some conditions, the embedded
servlet containers support a uniform Java DSL for customizing the error handling.

To do this you have to have picked a container implementation (by including either Tomcat
or Jetty on the classpath), but then the API is the same.

//FIXME TODO: finish this, possibly move.


== Spring Boot Gradle plugin

== Spring Boot Maven plugin

== Deploying to the cloud
Spring Boot's executable JARs are ready-made for most popular cloud PaaS
(platform-as-a-service) providers. These providers tend to require that you
_`bring your own container'_; they manage application processes (not Java applications
specifically), so they need some intermediary layer that adapts _your_ application to the
_cloud's_ notion of a running process.

Two popular cloud providers, Heroku and Cloud Foundry, employ a ``buildpack'' approach.
The buildpack wraps your deployed code in whatever is needed to _start_ your
application: it might be a JDK and a call to `java`, it might be an embedded webserver,
or it might be a full fledged application server. A buildpack is pluggable, but ideally
you should be able to get by with as few customizations to it as possible.
This reduces the footprint of functionality that is not under your control. It minimizes
divergence between deployment and production environments.

Ideally, your application, like a Spring Boot executable JAR, has everything that it needs
to run packaged within it.

In this section we'll look at what it takes to get the simple Boot application that we
developed in the Getting Started section up and running on Cloud Foundry and Heroku.

=== Cloud Foundry
Cloud Foundry provides default buildpacks that come into play if no other buildpack is
specified. The Cloud Foundry buildpack has excellent support for Spring applications,
including Spring Boot.  You can deploy stand-alone executable JAR applications as well as
traditional `WAR` packaged applications.

Once you've built your application (using, for example, `mvn clean install`) and
http://docs.cloudfoundry.org/devguide/installcf/[installed the `cf` command line tool],
simply answer the `cf push` command's prompts as follows:

[indent=0,subs="verbatim,quotes,attributes"]
----
	$ cf push --path target/demo-0.0.1-SNAPSHOT.jar

	Name> *_$YOURAPP_*
	Instances> *1*
	Memory Limit> *256M*

	Creating _$YOURAPP_... *OK*

	1: _$YOURAPP_
	2: none
	Subdomain> *_$YOURAPP_*

	1: cfapps.io
	2: none
	Domain> *cfapps.io*

	Creating route _$YOURAPP_.cfapps.io... OK
	Binding _$YOURAPP_.cfapps.io to _$YOURAPP_... OK

	Create services for application?> *n*
	Bind other services to application?> *n*
	Save configuration?> *y*
----

At this point `cf` will start uploading your application:

[indent=0,subs="verbatim,quotes,attributes"]
----
	Saving to manifest.yml... *OK*
	Uploading $YOURAPP... *OK*
	Preparing to start _$YOURAPP_... *OK*
	-----> Downloaded app package (8.7M)
	-----> Java Buildpack source: system
	-----> Downloading Open JDK 1.7.0_51 from .../openjdk-1.7.0_51.tar.gz (*1.4s*)
	       Expanding Open JDK to .java-buildpack/open_jdk (*1.3s*)
	-----> Downloading Spring Auto Reconfiguration 0.8.7 from .../auto-reconfiguration-0.8.7.jar (*0.0s*)
	-----> Uploading droplet (*43M*)
	Checking status of app '_$YOURAPP_'...
	 0 of 1 instances running (1 starting)
	 0 of 1 instances running (1 starting)
	 1 of 1 instances running (1 running)
	Push successful! App '_$YOURAPP_' available at http://_$YOURAPP_.cfapps.io
----

Here I'm substituting `$YOURAPP` for whatever value you give `cf` when it asks for the
`name` of your application.

Once Cloud Foundry acknowledges that your application has been deployed, you should be
able to hit the application at the URI provided:
`http://$YOURAPP.cfapps.io/`.

==== Binding to services
By default, meta-data about the running application as well as service connection
information is exposed to the application as environment variables (for example:
`$VCAP_SERVICES`). This architecture decision is due to Cloud Foundry's polyglot
(any language and platform that can be supported as a buildpack) nature; process-scoped
environment variables are language agnostic.

Environment variables don't always make for the easiest API so Spring Boot automatically
extracts then and flattens the data into properties that can be accessed through
Spring's `Environment` abstraction:

[source,java,indent=0]
----
	@Component
	class MyBean implements EnvironmentAware {

		private String instanceId;

		@Override
		public void setEnvironment(Environment environment) {
			this.instanceId = environment.getProperty("vcap.application.instance_id");
		}

		// ...

	}
----

All Cloud Foundry properties are prefixed with `vcap`. You can use vcap properties to
access application information (such as the public URL of the application) and service
information (such as database credentials). See `VcapApplicationListener` Javdoc for
complete details.

TIP: The http://spring.io/projects/spring-cloud[Spring Cloud] project is a better fit
for tasks such as configuring a DataSource; and you can also use Spring Cloud with
Heroku too!

=== Heroku
Heroku is another popular PaaS platform. To customize Heroku builds, you provide a
`Procfile`, which provides the incantation required to deploy an application. Heroku
assigns a `port` for the Java application to use and then ensures that routing to the
external URI works.

You must configure your application listen to the correct port. This is a breeze with
Spring Boot. Here's the `Procfile` for our starter REST application:

[indent=0]
----
	web: java -Dserver.port=$PORT -jar target/demo-0.0.1-SNAPSHOT.jar
----

Spring Boot makes `-D` arguments available as properties accessible from a Spring
`Environment` instance. The `server.port` configuration property is fed to the embedded
Tomcat or Jetty instance which then uses it when it starts up. The `$PORT` environment
variable is assigned to us by the Heroku PaaS.

Heroku by default will use Java 1.6. This is fine as long as your Maven or Gradle build
is set to use the same version (Maven users can use the `java.version` property). If you
want to use JDK 1.7, create a new file adjacent to your `pom.xml` and `Procfile`,
called `system.properties`. In this file add the following:

[source,java]
----
java.runtime.version=1.7
----

This should be everything you need. The most common workflow for Heroku deployments is to
`git push` the code to production.

[indent=0,subs="verbatim,quotes,attributes"]
----
	$ git push heroku master

	Initializing repository, *done*.
	Counting objects: 95, *done*.
	Delta compression using up to 8 threads.
	Compressing objects: 100% (78/78), *done*.
	Writing objects: 100% (95/95), 8.66 MiB | 606.00 KiB/s, *done*.
	Total 95 (delta 31), reused 0 (delta 0)

	-----> Java app detected
	-----> Installing OpenJDK 1.7... *done*
	-----> Installing Maven 3.0.3... *done*
	-----> Installing settings.xml... *done*
	-----> executing /app/tmp/cache/.maven/bin/mvn -B
	       -Duser.home=/tmp/build_0c35a5d2-a067-4abc-a232-14b1fb7a8229
	       -Dmaven.repo.local=/app/tmp/cache/.m2/repository
	       -s /app/tmp/cache/.m2/settings.xml -DskipTests=true clean install

	       [INFO] Scanning for projects...
	       Downloading: http://repo.spring.io/...
	       Downloaded: http://repo.spring.io/... (818 B at 1.8 KB/sec)
			....
	       Downloaded: http://s3pository.heroku.com/jvm/... (152 KB at 595.3 KB/sec)
	       [INFO] Installing /tmp/build_0c35a5d2-a067-4abc-a232-14b1fb7a8229/target/...
	       [INFO] Installing /tmp/build_0c35a5d2-a067-4abc-a232-14b1fb7a8229/pom.xml ...
	       [INFO] ------------------------------------------------------------------------
	       [INFO] *BUILD SUCCESS*
	       [INFO] ------------------------------------------------------------------------
	       [INFO] Total time: 59.358s
	       [INFO] Finished at: Fri Mar 07 07:28:25 UTC 2014
	       [INFO] Final Memory: 20M/493M
	       [INFO] ------------------------------------------------------------------------

	-----> Discovering process types
	       Procfile declares types -> *web*

	-----> Compressing... *done*, 70.4MB
	-----> Launching... *done*, v6
	       http://agile-sierra-1405.herokuapp.com/ *deployed to Heroku*

	To git@heroku.com:agile-sierra-1405.git
	 * [new branch]      master -> master
----

That should be it! Your application should be up and running on Heroku.


== Extending Spring Boot

=== Conditions

== Spring Boot CLI

== Executable JARs
// FIXME do we want this here?


== ``How-to'' guides
This section provides answers to some common ``how do I do that...'' types of questions.

=== Spring Boot application

==== Troubleshoot auto-configuration
The Spring Boot auto-configuration tries it's best to ``do the right thing'', but
sometimes things fail and it can be hard to tell why.

There is a really useful `AutoConfigurationReport` available in any Spring Boot
`ApplicationContext`. You will see it if you enable `DEBUG` logging output. If you use
the Actuator there is also an endpoint `/autoconfig` that renders the report in JSON.
Use that to debug the application and see what features have been added (and which not) by
Spring Boot at runtime.

// FIXME link to full auto-config list + link to actuator

Many more questions can be answered by looking at the source code and Javadocs. Some
rules of thumb:

* Look for classes called `*AutoConfiguration` and read their sources, in particular the
  `@Conditional*` annotations to find out what features they enable and when. Add
  `--debug` to the command line or a System property `-Ddebug` to get a printout on the
  console of all the autoconfiguration decisions that were made in your app. In a running
  Actuator app look at the `/autoconfig` endpoint (or the JMX equivalent) for the same
  information.
* Look for classes that are `@ConfigurationProperties` (e.g.
  https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java?source=c[`ServerProperties`]
  and read from there the available external configuration options. The
  `@ConfigurationProperties` has a `name` attribute which acts as a prefix to external
  properties, thus `ServerProperties` has `name="server"` and its configuration properties
  are `server.port`, `server.address` etc. In a running Actuator app look at the
  `/configprops` endpoint or JMX equivalent.
* Look for use of `RelaxedEnvironment` to pull configuration values explicitly out of the
  `Environment`. It often is used with a prefix.
* Look for `@Value` annotations that bind directly to the `Environment`. This is less
  flexible than the `RelaxedEnvironment` approach, but does allow some relaxed binding,
  specifically for OS environment variables (so `CAPITALS_AND_UNDERSCORES` are synonyms
  for `period.separated`).
* Look for `@ConditionalOnExpression` annotations that switch features on and off in
  response to SpEL expressions, normally evaluated with place-holders resolved from the
  `Environment`.

==== Customize the Environment or ApplicationContext before it starts
A `SpringApplication` has `ApplicationListeners` and `ApplicationContextInitializers` that
are used to apply customizations to the context or environment. Spring Boot loads a number
of such customizations for use internally from `META-INF/spring.factories`. There is more
than one way to register additional ones:

* Programmatically per application by calling the `addListeners` and `addInitializers`
  methods on `SpringApplication` before you run it.
* Declaratively per application by setting `context.initializer.classes` or
  `context.listener.classes`.
* Declarative for all applications by adding a `META-INF/spring.factories` and packaging
  a jar file that the applications all use as a library.

The `SpringApplication` sends some special `ApplicationEvents` to the listeners (even
some before the context is created), and then registers the listeners for events published
by the `ApplicationContext` as well. See XXX for a complete list.

// FIXME


[[build-hierarchy]]
==== Build an ApplicationContext hierarchy (adding a parent or root context)

// FIXME see ApplicationBuilder section

==== Create a non-web application
Not all Spring applications have to be web applications (or web services). If you want to
execute some code in a `main` method, but also bootstrap a Spring application to set up
the infrastructure to use, then it's easy with the `SpringApplication` features of Spring
Boot. A `SpringApplication` changes its `ApplicationContext` class depending on whether it
thinks it needs a web application or not. The first thing you can do to help it is to just
leave the servlet API dependencies off the classpath. If you can't do that (e.g. you are
running 2 applications from the same code base) then you can explicitly call
`SpringApplication.setWebEnvironment(false)`, or set the `applicationContextClass`
property (through the Java API or with external properties).
Application code that you want to run as your business logic can be implemented as a
`CommandLineRunner` and dropped into the context as a `@Bean` definition.

=== Properties & configuration


==== Externalize the configuration of SpringApplication
A `SpringApplication` has bean properties (mainly setters) so you can use its Java API as
you create the application to modify its behavior. Or you can externalize the
configuration using properties in `spring.main.*`. E.g. in `application.properties` you
might have.

[indent=0,subs="verbatim,quotes,attributes"]
----
	spring.main.web_environment: false
	spring.main.show_banner: false
----

and then the Spring Boot banner will not be printed on startup, and the application will
not be a web application.

==== Change the location of external properties of an application
By default properties from different sources are added to the Spring `Environment` in a
defined order, and the precedence for resolution is:

. commandline
. filesystem (current working directory) `application.properties`
. classpath `application.properties`.

A nice way to augment and modify this is to add `@PropertySource` annotations to your
application sources. Classes passed to the `SpringApplication` static convenience
methods, and those added using `setSources()` are inspected to see if they have
`@PropertySources` and if they do those properties are added to the `Environment` early
enough to be used in all phases of the `ApplicationContext` lifecycle. Properties added
in this way have precendence over any added using the default locations, but have lower
priority than system properties, environment variables or the command line.

You can also provide System properties (or environment variables) to change the behavior:

* `spring.config.name` (`SPRING_CONFIG_NAME`), defaults to `application` as the root of
  the file name.
* `spring.config.location` (`SPRING_CONFIG_LOCATION`) is file to load (e.g. a classpath
  resource or a URL). A separate `Environment` property source is set up for this document
  and it can be overridden by system properties, environment variables or the
  command line.

No matter what you set in the environment, Spring Boot will always load
`application.properties` as described above. If YAML is used then files with the ``.yml''
extension are also added to the list by default.

See `ConfigFileApplicationListener` for more detail.

==== Use ``short'' command line arguments
Some people like to use (for example) `--port=9000` instead of `--server.port=9000` to
set configuration properties on the command line. You can easily enable this by using
placeholders in `application.properties`, e.g.

[indent=0,subs="verbatim,quotes,attributes"]
----
	server.port: ${port:8080}
----

NOTE: In this specific case the port binding will work in a PaaS environment like Heroku
and Cloud Foundry, since in those two platforms the `PORT` environment variable is set
automatically and Spring can bind to capitalized synonyms for `Environment` properties.

==== Use YAML for external properties
YAML is a superset of JSON and as such is a very convenient syntax for storing external
properties in a hierarchical format. E.g.

[source,yaml,indent=0,subs="verbatim,quotes,attributes"]
----
	spring:
		application:
			name: cruncher
		datasource:
			driverClassName: com.mysql.jdbc.Driver
			url: jdbc:mysql://localhost/test
	server:
		port: 9000
----

Create a file called `application.yml` and stick it in the root of your classpath, and
also add `snakeyaml` to your classpath (Maven co-ordinates `org.yaml:snakeyaml`, already
included if you use a Spring Boot Starter). A YAML file is parsed to a Java
`Map<String,Object>` (like a JSON object), and Spring Boot flattens the maps so that it
is 1-level deep and has period-separated keys, a lot like people are used to with
`Properties` files in Java.

The example YAML above corresponds to an `application.properties` file

[indent=0,subs="verbatim,quotes,attributes"]
----
	spring.application.name: cruncher
	spring.datasource.driverClassName: com.mysql.jdbc.Driver
	spring.datasource.url: jdbc:mysql://localhost/test
	server.port: 9000
----

==== Set the active Spring profiles
The Spring `Environment` has an API for this, but normally you would set a System profile
(`spring.profiles.active`) or an OS environment variable (`SPRING_PROFILES_ACTIVE`). E.g.
launch your application with a `-D...` argument (remember to put it before the main class
or jar archive):

[indent=0,subs="verbatim,quotes,attributes"]
----
	$ java -jar -Dspring.profiles.active=production demo-0.0.1-SNAPSHOT.jar
----

In Spring Boot you can also set the active profile in `application.properties`, e.g.

[indent=0,subs="verbatim,quotes,attributes"]
----
	spring.profiles.active=production
----

A value set this way is replaced by the System property or environment variable setting,
but not by the `SpringApplicationBuilder.profiles()` method. Thus the latter Java API can
be used to augment the profiles without changing the defaults.


==== Change configuration depending on the environment
A YAML file is actually a sequence of documents separated by `---` lines, and each
document is parsed separately to a flattened map.

If a YAML document contains a `spring.profiles` key, then the profiles value
(comma-separated list of profiles) is fed into the Spring
`Environment.acceptsProfiles()` and if any of those profiles is active that document is
included in the final merge (otherwise not).

Example:

[source,yaml,indent=0,subs="verbatim,quotes,attributes"]
----
	server:
		port: 9000
	---

	spring:
		profiles: development
	server:
		port: 9001

	---

	spring:
		profiles: production
	server:
		port: 0
----

In this example the default port is 9000, but if the Spring profile ``development'' is
active then the port is 9001, and if ``production'' is active then it is 0.

The YAML documents are merged in the order they are encountered (so later values override
earlier ones).

To do the same thing with properties files you can use `application-${profile}.properties`
to specify profile-specific values.




[[discover-options]]
==== Discover built-in options for external properties
Spring Boot binds external properties from `application.properties` (or `.yml`) (and
other places) into an application at runtime.  There is not (and technically cannot be)
an exhaustive list of all supported properties in a single location because contributions
can come from additional JAR files on your classpath.

A running application with the Actuator features has a `/configprops` endpoint that shows
all the bound and bindable properties available through `@ConfigurationProperties` (also
exposed through JMX if you don't have a web endpoint).

There is a sample
https://github.com/spring-projects/spring-boot/blob/master/docs/application.yml[`application.yml`]
with a non-exhaustive and possibly inaccurate list of properties supported by Spring Boot
vanilla with autoconfiguration. The definitive list comes from searching the source code
for `@ConfigurationProperties` and `@Value` annotations, as well as the occasional use of
`RelaxedEnvironment` (c.f. https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaAutoConfiguration.java?source=c#L65[here]).




=== Embedded servlet containers

==== Add a Servlet, Filter or ServletContextListener to an application
`Servlet`, `Filter`, `ServletContextListener` and the other listeners supported by the
Servlet spec can be added to your application as `@Bean` definitions. Be very careful that
they don't cause eager initialization of too many other beans because they have to be
installed in th container very early in the application lifecycle (e.g. it's not a good
idea to have them depend on your `DataSource` or JPA configuration). You can work around
restrictions like that by initializing them lazily when first used instead of on
initialization.

In the case of `Filters` and `Servlets` you can also add mappings and init parameters by
adding a `FilterRegistrationBean` or `ServletRegistrationBean` instead of or as well as
the underlying component.

==== Change the HTTP port
In a standalone application the main HTTP port defaults to 8080, but can be set with
`server.port` (e.g. in `application.properties` or as a System property). Thanks to
relaxed binding of `Environment` values you can also use `SERVER_PORT` (e.g. as an OS
environment variable).

To switch off the HTTP endpoints completely, but still create a `WebApplicationContext`,
use `server.port=-1` (this is sometimes useful for testing).

For more detail look at the https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java?source=c[`ServerProperties`]
source code.

==== Use a random unassigned HTTP port
To scan for a free port (using OS natives to prevent clashes) use `server.port=0`.

==== Discover the HTTP port at runtime
You can access the port the server is running on from log output or from the
`EmbeddedWebApplicationContext` via its `EmbeddedServletContainer`. The best way to get
that and be sure that it has initialized is to add a `@Bean` of type
`ApplicationListener<EmbeddedServletContainerInitializedEvent>` and pull the container
out of the event wehen it is published.


==== Configure Tomcat
Generally you can follow the advice from <<discover-options>> about
`@ConfigurationProperties` (`ServerProperties` is the main one here), but also look at
`EmbeddedServletContainerCustomizer` and various Tomcat specific `*Customizers` that you
can add in one of those. The Tomcat APIs are quite rich so once you have access to the
`TomcatEmbeddedServletContainerFactory` you can modify it in a number of ways. Or the
nuclear option is to add your own `TomcatEmbeddedServletContainerFactory`.

==== Terminate SSL in Tomcat
Add a `EmbeddedServletContainerCustomizer` and in that add a `TomcatConnectorCustomizer`
that sets up the connector to be secure:

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	@Bean
	public EmbeddedServletContainerCustomizer containerCustomizer(){
		return new MyCustomizer();
	}

	// ...

	private static class MyCustomizer implements EmbeddedServletContainerCustomizer {

		@Override
		public void customize(ConfigurableEmbeddedServletContainerFactory factory) {
			if(factory instanceof TomcatEmbeddedServletContainerFactory) {
				customizeTomcat((TomcatEmbeddedServletContainerFactory) factory));
			}
		}

		public void customizeTomcat(TomcatEmbeddedServletContainerFactory factory) {
			factory.addConnectorCustomizers(new TomcatConnectorCustomizer() {
				@Override
				public void customize(Connector connector) {
					connector.setPort(serverPort);
					connector.setSecure(true);
					connector.setScheme("https");
					connector.setAttribute("keyAlias", "tomcat");
					connector.setAttribute("keystorePass", "password");
					try {
						connector.setAttribute("keystoreFile",
							ResourceUtils.getFile("src/ssl/tomcat.keystore").getAbsolutePath());
					} catch (FileNotFoundException e) {
						throw new IllegalStateException("Cannot load keystore", e);
					}
					connector.setAttribute("clientAuth", "false");
					connector.setAttribute("sslProtocol", "TLS");
					connector.setAttribute("SSLEnabled", true);
				}
			});
		}

	}
----

==== Use Jetty instead of Tomcat
The Spring Boot starters (`spring-boot-starter-web` in particular) use Tomcat as an
embedded container by default. You need to exclude those dependencies and include the
Jetty ones to use that container. Spring Boot provides Tomcat and Jetty dependencies
bundled together as separate startes to help make this process as easy as possible.

Example in Maven:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-web</artifactId>
		<exclusions>
			<exclusion>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-starter-tomcat</artifactId>
			</exclusion>
		</exclusions>
	</dependency>
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-jetty</artifactId>
	</dependency>
----

Example in Gradle:

[source,groovy,indent=0,subs="verbatim,quotes,attributes"]
----
	configurations {
		compile.exclude module: 'spring-boot-starter-tomcat'
	}

	dependencies {
		compile("org.springframework.boot:spring-boot-starter-web:1.0.0.RC3")
		compile("org.springframework.boot:spring-boot-starter-jetty:1.0.0.RC3")
		// ...
	}
----

==== Configure Jetty
Generally you can follow the advice [here](#discover.options) about
`@ConfigurationProperties` (`ServerProperties` is the main one here), but also look at
`EmbeddedServletContainerCustomizer`. The Jetty APIs are quite rich so once you have
access to the `JettyEmbeddedServletContainerFactory` you can modify it in a number
of ways. Or the nuclear option is to add your own `JettyEmbeddedServletContainerFactory`.





==== Use Tomcat 8
Tomcat 8 works with Spring Boot, but the default is to use Tomcat 7 (so we can support
Java 1.6 out of the box). You should only need to change the classpath to use Tomcat 8
for it to work. The https://github.com/spring-projects/spring-boot/blob/master/spring-boot-samples/spring-boot-sample-websocket/pom.xml[websocket sample]
shows you how to do that in Maven.



==== Use Jetty 9
Jetty 9 works with Spring Boot, but the default is to use Jetty 8 (so we can support
Java 1.6 out of the box). You should only need to change the classpath to use Jetty 9
for it to work.

If you are using the starter poms and parent you can just add the Jetty starter and
change the version properties, e.g. for a simple webapp or service:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<properties>
		<java.version>1.7</java.version>
		<jetty.version>9.1.0.v20131115</jetty.version>
		<servlet-api.version>3.1.0</servlet-api.version>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
			<exclusions>
				<exclusion>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-starter-tomcat</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-jetty</artifactId>
		</dependency>
	</dependencies>
----




=== Spring MVC

==== Write a JSON REST service
Any Spring `@RestController` in a Spring Boot application should render JSON response by
default as long as Jackson2 is on the classpath. For example:

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	@RestController
	public class MyController {

		@RequestMapping("/thing")
		public MyThing thing() {
				return new MyThing();
		}

	}
----

As long as `MyThing` can be serialized by Jackson2 (e.g. a normal POJO or Groovy object)
then `http://localhost:8080/thing` will serve a JSON representation of it by default.
Sometimes in a browser you might see XML responses (but by default only if `MyThing` was
a JAXB object) because browsers tend to send accept headers that prefer XML.



==== Customize the Jackson ObjectMapper
Spring MVC (client and server side) uses `HttpMessageConverters` to negotiate content
conversion in an HTTP exchange. If Jackson is on the classpath you already get a default
converter with a vanilla `ObjectMapper`. Spring Boot has some features to make it easier
to customize this behavior.

The smallest change that might work is to just add beans of type `Module` to your context.
They will be registered with the default `ObjectMapper` and then injected into the default
message converter. To replace the default `ObjectMapper` completely, define a `@Bean` of
that type and mark it as `@Primary`.

In addition, if your context contains any beans of type `ObjectMapper` then all of the
`Module` beans will be registered with all of the mappers. So there is a global mechanism
for contributing custom modules when you add new features to your application.

Finally, if you provide any `@Beans` of type `MappingJackson2HttpMessageConverter` then
they will replace the default value in the MVC configuration. Also, a convenience bean is
provided of type `HttpMessageConverters` (always available if you use the default MVC
configuration) which has some useful methods to access the default and user-enhanced
message converters.

See also the <<message-converters, section on `HttpMessageConverters`>> and the
`WebMvcAutoConfiguration` source code for more details.



[[message-converters]]
==== Customize the @ResponseBody rendering
Spring uses `HttpMessageConverters` to render `@ResponseBody` (or responses from
`@RestControllers`). You can contribute additional converters by simply adding beans of
that type in a Spring Boot context. If a bean you add is of a type that would have been
included by default anyway (like `MappingJackson2HttpMessageConverter` for JSON
conversions) then it will replace the default value. A convenience bean is provided of
type `HttpMessageConverters` (always available if you use the default MVC configuration)
which has some useful methods to access the default and user-enhanced message converters
(useful, for example if you want to manually inject them into a custom `RestTemplate`).

As in normal MVC usage, any `WebMvcConfigurerAdapter` beans that you provide can also
contribute converters by overriding the `configureMessageConverters` method, but unlike
with normal MVC, you can supply only additional converters that you need (because Spring
Boot uses the same mechanism to contribute its defaults). Finally, if you opt out of the
Spring Boot default MVC configuration by providing your own `@EnableWebMvc` configuration,
then you can take control completely and do everything manually using
`getMessageConverters` from `WebMvcConfigurationSupport`.

See the `WebMvcAutoConfiguration` source code for more details.

==== Switch off the Spring MVC DispatcherServlet
Spring Boot wants to serve all content from the root of your application `/` down. If you
would rather map your own servlet to that URL you can do it, but of course you may lose
some of the other Boot MVC features. To add your own servlet and map it to the root
resource just declare a `@Bean` of type `Servlet` and give it the special bean name
`dispatcherServlet`. (You can also create a bean of a different type with that name if
you want to switch it off and not replace it.)

==== Switch off the Default MVC configuration
The easiest way to take complete control over MVC configuration is to provide your own
`@Configuration` with the `@EnableWebMvc` annotation. This will leave all MVC
configuration in your hands.


=== Logging

==== Configure Logback for logging
Spring Boot has no mandatory logging dependence, except for the `commons-logging` API, of
which there are many implementations to choose from. To use http://logback.qos.ch[Logback]
you need to include it, and some bindings for `commons-logging` on the classpath. The
simplest way to do that is through the starter poms which all depend on
`spring-boot-start-logging`.  For a web application you only need the web starter since it
depends transitively on the logging starter. E.g. in Maven:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-web</artifactId>
	</dependency>
----

Spring Boot has a `LoggingSystem` abstraction that attempts to select a system depending
on the contents of the classpath. If Logback is available it is the first choice. So if
you put a `logback.xml` in the root of your classpath it will be picked up from there.
Spring Boot provides a default base configuration that you can include if you just want
to set levels, e.g.

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<configuration>
		<include resource="org/springframework/boot/logging/logback/base.xml"/>
		<logger name="org.springframework.web" level="DEBUG"/>
	</configuration>
----

If you look at the default `logback.xml` in the spring-boot JAR you will see that it uses
some useful System properties which the `LoggingSystem` takes care of creating for you.
These are:

* `${PID}` the current process ID.
* `${LOG_FILE}` if `logging.file` was set in Boot's external configuration.
* `${LOG_PATH` if `logging.path` was set (representing a directory for
	log files to live in).

Spring Boot also provides some nice ANSI colour terminal output on a console (but not in
a log file) using a custom Logback converter. See the default `base.xml` configuration
for details.

If Groovy is on the classpath you should be able to configure Logback with
`logback.groovy` as well (it will be given preference if present).

==== Configure Log4j for logging
Spring Boot supports http://logging.apache.org/log4j/1.x/[Log4j] for logging
configuration, but it has to be on the classpath. If you are using the starter poms for
assembling dependencies that means you have to exclude logback and then include log4j
back. If you aren't using the starter poms then you need to provide `commons-logging`
(at least) in addition to Log4j.

The simplest path to using Log4j is probably through the starter poms, even though it
requires some jiggling with excludes, e.g. in Maven:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-web</artifactId>
		<exclusions>
				<exclusion>
						<groupId>${project.groupId}</groupId>
						<artifactId>spring-boot-starter-logging</artifactId>
				</exclusion>
		</exclusions>
	</dependency>
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-log4j</artifactId>
	</dependency>
----

NOTE: The use of the log4j starter to gather together the dependencies for common logging
requirements (e.g. including having Tomcat use `java.util.logging` but configure the
output using Log4j). See the Actuator Log4j Sample for more detail and to see it in
action.




=== Data Access

==== Configure a DataSource
See XXX.

To override the default settings just define a `@Bean` of your own of type `DataSource`.
See https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceAutoConfiguration.java[`DataSourceAutoConfiguration`]
for more details.

==== Use Spring Data repositories
Spring Data can create implementations for you of `@Repository` interfaces of various
flavours. Spring Boot will handle all of that for you as long as those `@Repositories`
are included in the same package (or a sub-package) of your `@EnableAutoConfiguration`
class.

For many applications all you will need is to put the right Spring Data dependencies on
your classpath (there is a `spring-boot-starter-data-jpa` for JPA and for Mongodb you
only need to add `spring-datamongodb`), create some repository interfaces to handle your
`@Entity` objects. Examples are in the https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-data-jpa[JPA sample]
or the https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-data-mongodb[Mongodb sample].

Spring Boot tries to guess the location of your `@Repository` definitions, based on the
`@EnableAutoConfiguration` it finds. To get more control, use the `@EnableJpaRepositories`
annotation (from Spring Data JPA).

==== Separate @Entity definitions from Spring configuration
Spring Boot tries to guess the location of your `@Entity` definitions, based on the
`@EnableAutoConfiguration` it finds. To get more control, you can use the `@EntityScan`
annotation, e.g.

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	@Configuration
	@EnableAutoConfiguration
	@EntityScan(basePackageClasses=City.class)
	public class Application {

		//...

	}
----

==== Configure JPA properties
Spring JPA already provides some vendor-independent configuration options (e.g. for SQL
logging) and Spring Boot exposes those, and a few more for hibernate as external
configuration properties. The most common options to set are:

[indent=0,subs="verbatim,quotes,attributes"]
----
	spring.jpa.hibernate.ddl-auto: create-drop
	spring.jpa.hibernate.naming_strategy: org.hibernate.cfg.ImprovedNamingStrategy
	spring.jpa.database: H2
	spring.jpa.show-sql: true
----

(Because of relaxed data binding hyphens or underscores should work equally well as
property keys.)  The `ddl-auto` setting is a special case in that it has different
defaults depending on whether you are using an embedded database (`create-drop`) or not
(`none`). In addition all properties in `spring.jpa.properties.*` are passed through as
normal JPA properties (with the prefix stripped) when the local `EntityManagerFactory` is
created.

See https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaAutoConfiguration.java[`HibernateJpaAutoConfiguration`]
and https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/orm/jpa/JpaBaseConfiguration.java[`JpaBaseConfiguration`]
for more details.

==== Use a traditional persistence.xml
Spring doesn't require the use of XML to configure the JPA provider, and Spring Boot
assumes you want to take advantage of that feature. If you prefer to use `persistence.xml`
then you need to define your own `@Bean` of type `LocalEntityManagerFactoryBean`, and set
the persistence unit name there.

See
https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/orm/jpa/JpaBaseConfiguration.java[`JpaBaseConfiguration`]
for the default settings.

=== Database initialization
An SQL database can be initialized in different ways depending on what your stack is. Or
of course you can do it manually as long as the database is in a server.

==== Initialize a database using JPA
JPA has features for DDL generation, and these can be set up to run on startup against the
database. This is controlled through two external properties:

* `spring.jpa.generate-ddl` (boolean) switches the feature on and off and is vendor
  independent.
* `spring.jpa.hibernate.ddl-auto` (enum) is a Hibernate feature that controls the
  behavior in a more fine-grained way. See below for more detail.

==== Initialize a database using Hibernate
You can set `spring.jpa.hibernate.ddl-auto` explicitly and the standard Hibernate property
values are `none`, `validate`, `update`, `create-drop`. Spring Boot chooses a default
value for you based on whether it thinks your database is embedded (default `create-drop`)
or not (default `none`). An embedded database is detected by looking at the `Connection`
type: `hsqldb`, `h2` and `derby` are embedded, the rest are not. Be careful when switching
from in-memory to a ``real'' database that you don't make assumptions about the existence of
the tables and data in the new platform. You either have to set `ddl-auto` expicitly, or
use one of the other mechanisms to initialize the database.

In addition, a file named `import.sql` in the root of the classpath will be executed on
startup. This can be useful for demos and for testing if you are carefuil, but probably
not something you want to be on the classpath in production. It is a Hibernate feature
(nothing to do with Spring).

==== Initialize a database using Spring JDBC
Spring JDBC has a `DataSource` initializer feature. Spring Boot enables it by default and
loads SQL from the standard locations `schema.sql` and `data.sql` (in the root of the
classpath). In addition Spring Boot will load a file `schema-${platform}.sql` where
`platform` is the vendor name of the database (`hsqldb`, `h2`, `oracle`, `mysql`,
`postgresql` etc.). Spring Boot enables the failfast feature of the Spring JDBC
initializer by default, so if the scripts cause exceptions the application will fail.

To disable the failfast you can set `spring.datasource.continueOnError=true`. This can be
useful once an application has matured and been deployed a few times, since the scripts
can act as ``poor man's migrations'' - inserts that fail mean that the data is already
there, so there would be no need to prevent the application from running, for instance.

==== Initialize a Spring Batch database
If you are using Spring Batch then it comes pre-packaged with SQL initialization scripts
for most popular database platforms. Spring Boot will detect your database type, and
execute those scripts by default, and in this case will switch the fail fast setting to
false (errors are logged but do not prevent the application from starting). This is
because the scripts are known to be reliable and generally do not contain bugs, so errors
are ignorable, and ignoring them makes the scripts idempotent. You can switch off the
initialization explicitly using `spring.batch.initializer.enabled=false`.

==== Use a higher level datababse migration tool
Spring Boot works fine with higher level migration tools http://flywaydb.org/[Flyway]
(SQL-based) and http://www.liquibase.org/[Liquibase] (XML). In general we prefer
Flyway because it is easier on the eyes, and it isn't very common to need platform
independence: usually only one or at most couple of platforms is needed.

=== Batch applications

==== Execute Spring Batch jobs on startup
Spring Batch autoconfiguration is enabled by adding `@EnableBatchProcessing`
(from Spring Batch) somewhere in your context.

By default it executes *all* `Jobs` in the application context on startup (see
https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/batch/JobLauncherCommandLineRunner.java[JobLauncherCommandLineRunner]
for details). You can narrow down to a specific job or jobs by specifying
`spring.batch.job.names` (comma separated job name patterns).

If the application context includes a `JobRegistry` then the jobs in
`spring.batch.job.names` are looked up in the regsitry instead of bein autowired from the
context. This is a common pattern with more complex systems where multiple jobs are
defined in child contexts and registered centrally.

See
https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/batch/BatchAutoConfiguration.java[BatchAutoConfiguration]
and
https://github.com/spring-projects/spring-batch/blob/master/spring-batch-core/src/main/java/org/springframework/batch/core/configuration/annotation/EnableBatchProcessing.java[@EnableBatchProcessing]
for more details.


=== Actuator

==== Change the HTTP port or address of the actuator endpoints
In a standalone application the Actuator HTTP port defaults to the same as the main HTTP
port. To make the application listen on a different port set the external property
`management.port`. To listen on a completely different network address (e.g. if you have
an internal network for management and an external one for user applications) you can
also set `management.address` to a valid IP address that the server is able to bind to.

For more detail look at the
https://github.com/spring-projects/spring-boot/blob/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/properties/ManagementServerProperties.java?source=c[`ManagementServerProperties`]
source code.

==== Customize the ``whitelabel'' error page
The Actuator installs a ``whitelabel'' error page that you will see in browser client if
you encounter a server error (machine clients consuming JSON and other media types should
see a sensible response with the right error code). To switch it off you can set
`error.whitelabel.enabled=false`, but normally in addition or alternatively to that you
will want to add your own error page replacing the whitelabel one. If you are using
Thymeleaf you can do this by adding an `error.html` template. In general what you need is
a `View` that resolves with a name of `error`, and/or a `@Controller` that handles the
`/error` path. Unless you replaced some of the default configuration you should find a
`BeanNameViewResolver` in your `ApplicationContext` so a `@Bean` with id `error` would be
a simple way of doing that.  Look at `ErrorMvcAutoConfiguration` for more options.

=== Security

==== Secure an application
Web applications will be secure by default (with Basic authentication on all endpoints) if
Spring Security is on the classpath. To add method-level security to a web application you
can simply `@EnableGlobalMethodSecurity` with your desired settings.

The default `AuthenticationManager` has a single user (username ``user'' and password
random, printed at INFO when the application starts up). You can change the password by
providing a `security.user.password`. This and other useful properties are externalized
via `SecurityProperties`.

==== Switch off the Spring Boot security configuration
If you define a `@Configuration` with `@EnableWebSecurity` anywhere in your application
it will switch off the default webapp security settings in Spring Boot. To tweak the
defaults try setting properties in `security.*` (see
https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/SecurityProperties.java[`SecurityProperties`]
for details of available settings).

==== Change the AuthenticationManager and add user accounts
If you provide a `@Bean` of type `AuthenticationManager` the default one will not be
created, so you have the full feature set of Spring Security available (e.g.
http://docs.spring.io/spring-security/site/docs/3.2.1.RELEASE/reference/htmlsingle/#jc-authentication[various authentication options]).

Spring Security also provides a convenient `AuthenticationManagerBuilder` which can be
used to build an `AuthenticationManager` with common options. The recommended way to
use this in a webapp is to inject it into a void method in a
`WebSecurityConfigurerAdapter`, e.g.

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	@Configuration
	@Order(0)
	public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

		@Autowired
		protected void init(AuthenticationManagerBuilder builder) {
				builder.inMemoryAuthentication().withUser("barry"); // ...  etc.
		}

		// ... other stuff for application security

	}
----

The configuration class that does this should declare an `@Order` so that it is used
before the default one in Spring Boot (which has very low precedence).

==== Enable HTTPS
Ensuring that all your main endpoints are only available over HTTPS is an important
chore for any application.  If you are using Tomcat as a servlet container, then the
Spring Boot will add Tomcat's own `RemoteIpValve` automatically if it detects some
environment settings, and you should be able to rely on the `HttpServletRequest` to
report whether or not it is secure (even downstream of the real SSL termination). The
standard behavior is determined by the presence or absence of certain request headers
(`x-forwarded-for` and `x-forwarded-proto`), whose names are conventional, so it should
work with most front end proxies.  You switch on the valve by adding some entries to
`application.properties`, e.g.

[indent=0]
----
	server.tomcat.remote_ip_header: x-forwarded-for
	server.tomcat.protocol_header: x-forwarded-proto
----

(The presence of either of those properties will switch on the valve. Or you can add the
`RemoteIpValve` yourself by adding a `TomcatEmbeddedServletContainerFactory` bean.)

Spring Security can also be configured to require a secure channel for all (or some
requests). To switch that on in a Spring Boot application you just need to set
`security.require_https` to `true` in `application.properties`.









=== Hot swapping

==== Reload static content
There are several options. Running in an IDE (especially with debugging on) is a good way
to do development (all modern IDEs allow reloading of static resources and usually also
hot-swapping of Java class changes). The Maven and Gradle tooling also support running
from the command line with reloading of static files. You can use that with an external
css/js compiler process if you are writing that code with higher level tools.

// FIXME links to Maven/Gradle plugins

==== Reload Thymeleaf templates without restarting the container
If you are using Thymeleaf, then set `spring.thymeleaf.cache=false`. See
`ThymeleafAutoConfiguration` for other template customization options.

==== Reload Java classes without restarting the container
Modern IDEs (Eclipse, IDEA etc.) all support hot swapping of bytecode, so if you make a
change that doesn't affect class or method signatures it should reload cleanly with no
side effects.

https://github.com/spring-projects/spring-loaded[Spring Loaded] goes a little further in
that it can reload class definitions with changes in the method signatures. With some
customization it can force an `ApplicationContext` to refresh itself (but there is no
general mechanism to ensure that would be safe for a running application anyway, so it
would only ever be a development time trick probably).



=== Build

==== Build an executable archive with Ant
To build with Ant you need to grab dependencies and compile and then create a JAR or WAR
archive as normal.  To make it executable:

1. Use the appropriate launcher as a `Main-Class`,
e.g. `org.springframework.boot.loader.JarLauncher` for a JAR file, and
specify the other stuff it needs as manifest entries, principally a
`Start-Class`.

2. Add the runtime dependencies in a nested "lib" directory (for a
JAR) and the "provided" (embedded container) dependencies in a nested
"lib-provided" directory. Remember *not* to compress the entries in
the archive.

3. Add the `spring-boot-loader` classes at the root of the archive (so
the `Main-Class` is available).

Example

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<target name="build" depends="compile">
		<copy todir="target/classes/lib">
			<fileset dir="lib/runtime" />
		</copy>
		<jar destfile="target/spring-boot-sample-actuator-${spring-boot.version}.jar" compress="false">
			<fileset dir="target/classes" />
			<fileset dir="src/main/resources" />
			<zipfileset src="lib/loader/spring-boot-loader-jar-${spring-boot.version}.jar" />
			<manifest>
				<attribute name="Main-Class" value="org.springframework.boot.loader.JarLauncher" />
				<attribute name="Start-Class" value="${start-class}" />
			</manifest>
		</jar>
	</target>
----

The Actuator Sample has a `build.xml` that should work if you run it with

[indent=0,subs="verbatim,quotes,attributes"]
----
	$ ant -lib <path_to>/ivy-2.2.jar
----

after which you can run the application with

[indent=0,subs="verbatim,quotes,attributes"]
----
	$ java -jar target/*.jar
----


=== Traditional deployment

==== Create a deployable WAR file
Use the `SpringBootServletInitializer` base class, which is picked up by Spring's
Servlet 3.0 support on deployment. Add an extension of that to your project and build a
WAR file as normal. For more detail, see the
http://spring.io/guides/gs/convert-jar-to-war[``Converting a JAR Project to a WAR''] guide
on the spring.io website.

The WAR file can also be executable if you use the Spring Boot build tools. In that case
the embedded container classes (to launch Tomcat for instance) have to be added to the
WAR in a `lib-provided` directory. The tools will take care of that as long as the
dependencies are marked as "provided" in Maven or Gradle. Here's a Maven example
https://github.com/spring-projects/spring-boot/blob/master/spring-boot-samples/spring-boot-sample-traditional/pom.xml[in the Boot Samples].

==== Create a deployable WAR file for older servlet containers
Older Servlet containers don't have support for the `ServletContextInitializer` bootstrap
process used in Servlet 3.0. You can still use Spring and Spring Boot in these containers
but you are going to need to add a `web.xml` to your application and configure it to load
an `ApplicationContext` via a `DispatcherServlet`.

//FIXME add some detail.

==== Convert an existing application to Spring Boot
For a non-web application it should be easy (throw away the code that creates your
`ApplicationContext` and replace it with calls to `SpringApplication` or
`SpringApplicationBuilder`). Spring MVC web applications are generally amenable to first
creating a deployable WAR application, and then migrating it later to an executable WAR
and/or JAR.  Useful reading is in the http://spring.io/guides/gs/convert-jar-to-war/[Getting
Started Guide on Converting a JAR to a WAR].

Create a deployable WAR by extending `SpringBootServletInitializer` (e.g. in a class
called `Application`), and add the Spring Boot `@EnableAutoConfiguration` annotation.
Example:

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	@Configuration
	@EnableAutoConfiguration
	@ComponentScan
	public class Application extends SpringBootServletInitializer {

		@Override
		protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
			return application.sources(Application.class);
		}

	}
----

Remember that whatever you put in the `sources` is just a Spring `ApplicationContext` and
normally anything that already works should work here. There might be some beans you can
remove later and let Spring Boot provide its own defaults for them, but it should be
possible to get something working first.

Static resources can be moved to `/public` (or `/static` or `/resources` or
`/META-INFO/resources`) in the classpath root. Same for `messages.properties` (Spring Boot
detects this automatically in the root of the classpath).

Vanilla usage of Spring `DispatcherServlet` and Spring Security should require no further
changes. If you have other features in your application, using other servlets or filters,
for instance then you may need to add some configuration to your `Application` context,
replacing those elements from the `web.xml` as follows:

* A `@Bean` of type `Servlet` or `ServletRegistrationBean` installs that bean in the
  container as if it was a `<servlet/>` and `<servlet-mapping/>` in `web.xml`.
* A `@Bean` of type `Filter` or `FilterRegistrationBean` behaves similarly (like a
  `<filter/>` and `<filter-mapping/>`.
* An `ApplicationContext` in an XML file can be added to an `@Import` in your
  `Application`. Or simple cases where annotation configuration is heavily used already
  can be recreated in a few lines as `@Bean` definitions.

Once the WAR is working we make it executable by adding a `main` method to our
`Application`, e.g.

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}
----

Applications can fall into more than one category:

* Servlet 3.0 applications with no `web.xml`.
* Applications with a `web.xml`.
* Applications with a context hierarchy.
* Applications without a context hierarchy.

All of these should be amenable to translation, but each might require slightly different
tricks.

Servlet 3.0 applications might translate pretty easily if they already use the Spring
Servlet 3.0 initializer support classes. Normally all the code from an existing
`WebApplicationInitializer` can be moved into a `SpringBootServletInitializer`. If your
existing application has more than one `ApplicationContext` (e.g. if it uses
`AbstractDispatcherServletInitializer`) then you might be able to squish all your context
sources into a single `SpringApplication`. The main complication you might encounter is if
that doesn't work and you need to maintain the context hierarchy. See the
<<build.hierarchy, entry on building a hierarchy>> for examples. An existing parent
context that contains web-specific features will usually need to be broken up so that all
the `ServletContextAware` components are in the child context.

Applications that are not already Spring applications might be convertible to a Spring
Boot application, and the guidance above might help, but your mileage may vary.



// FIXME how to change the git.properties file using spring.git.properties
// FIXME how to use lombok










// FIXME add security section

:numbered!:

[appendix]
== Common application properties
Various properties can be specific inside your `application.properties`/`application.yml`
file or as command line switches. This section provides a list common Spring Boot
properties and references to the underlying classes that consume them.

NOTE: Property contributions can come from additional JAR files on your classpath so
you should no consider this an exhaustive list. It is also perfectly legal to define
your own properties.

WARNING: This sample file is meant as a guide only. DO NOT COPY/PASTE the entire content
into your application; rather pick only the properties that you need.

[source,properties,indent=0,subs="attributes"]
----
# ===================================================================
# COMMON SPRING BOOT PROPERTIES
#
# This sample file is provided as a guideline. Do NOT copy it in its
# entirety to your own application.               ^^^
# ===================================================================

# ----------------------------------------
# CORE PROPERTIES
# ----------------------------------------

# SPRING CONFIG (ConfigFileApplicationListner)
spring.config.name= # config file name (default to 'application')
spring.config.location= # location of config file

# PROFILES
spring.profiles= # comma list of active profiles

# APPLICATION SETTINGS (SpringApplication_
spring.main.sources=
spring.main.web-environment= # detect by default
spring.main.show-bannder=true
spring.main.... # see class for all properties

# IDENTITY (ContextIdApplicationContextInitializer)
spring.application.name=
vcap.application.name=

# EMBEDDED SERVER CONFIGURATION (ServerProperties)
server.port=8080
server.address= # bind to a specific NIC
server.session-timeout= # session timeout in sections
server.context-path= # the context path, defaults to '/'
server.servlet-path= # the servlet path, defaults to '/'
server.tomcat.access-log-pattern= # log pattern of the access log
server.tomcat.access-log-enabled=false # is access logging enabled
server.tomcat.protocol-header="x-forwarded-proto" # ssl forward headers
server.tomcat.remote-ip-header="x-forwarded-for"
server.tomcat.basedir="/tmp" # base dir (usually not needed, defaults to tmp)
server.tomcat.background-processor-delay=30; # in seconds
server.tomcat.max-threads = 0 # number of threads in protocol handler

# SPRING MVC (HttpMapperProperties)
http.mappers.json-pretty-print=false # pretty print JSON
spring.view.prefix= # MVC view prefix
spring.view.suffix= # ... and suffix
spring.resources.cache-period # cache timeouts in headers sent to browser

# THYMELEAF (ThymeleafAutoConfiguration)
spring.thymeleaf.prefix="classpath:/templates/"
spring.thymeleaf.suffix=".html"
spring.thymeleaf.mode="HTML5"
spring.thymeleaf.encoding="UTF-8"
spring.thymeleaf.cache=true # set to false for hot refresh

# INTERNATIONALIZATION (MessageSourceAutoConfiguration)
spring.messages.basename="messages"
spring.messages.encoding="UTF-8"

# SECURITY (SecurityProperties)
security.user.name="user" # login username
security.user.password= # login password
security.user.role="USER" # role assigned to the user
security.require-ssl=false # advanced settings ...
security.enable-csrf=false
security.basic.enabled=true
security.basic.realm="Spring"
security.basic.path="/**"
security.headers.xss=false
security.headers.cache=false
security.headers.frame=false
security.headers.contentType=false
security.headers.hsts=all # none / domain / all
security.sessions=stateless # always / never / if_required / stateless
security.ignored=false

# DATASOURCE (DataSourceAutoConfiguration & AbstractDataSourceConfiguration)
spring.datasource.name= # name of the data source
spring.datasource.intialize=true # populate using data.sql
spring.datasource.schema= # a schema resource reference
spring.datasource.continueOnError=false # continue even if can't be initialized
spring.datasource.driverClassName= # JDBC Settings...
spring.datasource.url=
spring.datasource.username=
spring.datasource.password=
spring.datasource.max-active=100 # Advanced configuration...
spring.datasource.max-idle=8
spring.datasource.min-idle=8
spring.datasource.initial-size=10
spring.datasource.validation-query
spring.datasource.test-on-borrow=false
spring.datasource.test-on-return=false

# MONGODB (MongoProperties)
spring.data.mongodb.host= # the db host
spring.data.mongodb.port=27017 # the connection port (defaults to 27107)
spring.data.mongodb.uri=mongodb://localhost/test # connection URL

# JPA (JpaBaseConfiguration, HibernateJpaAutoConfiguration)
spring.jpa.properties.*= # properties to set on the JPA connection
spring.jpa.openInView=true
spring.jpa.show-sql=true
spring.jpa.database-platform=
spring.jpa.database=
spring.jpa.generate-ddl=
spring.jpa.hibernate.naming-strategy= # naming classname
spring.jpa.hibernate.ddl-auto= # defaults to create-drop for embedded dbs

# JMX
spring.jmx.enabled=true # Expose MBeans from Spring

# RABBIT (RabbitProperties)
spring.rabbitmq.host= # connection host
spring.rabbitmq.port= # connection port
spring.rabbitmq.username= # login user
spring.rabbitmq.password= # login password
spring.rabbitmq.virtualhost=
spring.rabbitmq.dynamic=

# REDIS (RedisProperties)
spring.redis.host="localhost" # server host
spring.redis.password= # server password
spring.redis.port=6379 # connection port
spring.redis.pool.max-idle=8 # pool settings ...
spring.redis.pool.min-idle=0
spring.redis.pool.max-active=8
spring.redis.pool.max-wait=-1

# ACTIVEMQ (ActiveMQProperties)
spring.activemq.broker-url="tcp://localhost:61616" # connection URL
spring.activemq.in-memory=true
spring.activemq.pooled=false

# JMS (JmsTemplateProperties)
spring.jms.pub-sub-domain=

# SPRING BATCH (BatchDatabaseInitializer)
spring.batch.job.names="job1,job2"
spring.batch.job.enabled=true
spring.batch.initializer.enabled=true
spring.batch.schema= # batch schema to load

# AOP
spring.aop.auto=
spring.aop.proxyTargetClass=

# FILE ENCODING (FileEncodingApplicationListener)
spring.mandatory-file-encoding=false

# ----------------------------------------
# ACTUATOR PROPERTIES
# ----------------------------------------

# MANAGEMENT HTTP SERVER (ManagementServerProperties)
management.port= # defaults to 'server.port'
management.address= # bind to a specific NIC
management.contextPath= # default to '/'

# ENDPOINTS (AbstractEndpoint subclasses)
endpoints.autoconfig.id="autoconfig"
endpoints.autoconfig.sensitive=true
endpoints.autoconfig.enabled=true
endpoints.beans.id="beans"
endpoints.beans.sensitive=true
endpoints.beans.enabled=true
endpoints.configprops.id="configprops"
endpoints.configprops.sensitive=true
endpoints.configprops.enabled=true
endpoints.configprops.keys-to-sanitize="password,secret"
endpoints.dump.id="dump"
endpoints.dump.sensitive=true
endpoints.dump.enabled=true
endpoints.env.id="env"
endpoints.env.sensitive=true
endpoints.env.enabled=true
endpoints.health.id="health"
endpoints.health.sensitive=false
endpoints.health.enabled=true
endpoints.info.id="info"
endpoints.info.sensitive=false
endpoints.info.enabled=true
endpoints.metrics.id="metrics"
endpoints.metrics.sensitive=true
endpoints.metrics.enabled=true
endpoints.shutdown.id="shutdown"
endpoints.shutdown.sensitive=true
endpoints.shutdown.enabled=false
endpoints.trace.id="trace"
endpoints.trace.sensitive=true
endpoints.trace.enabled=true

# MVC ONLY ENDPOINTS
endpoints.jolokia.path="jolokia"
endpoints.jolokia.sensitive=true
endpoints.jolokia.enabled=true # when using Jolokia
endpoints.error.path="/error"

# JMX ENDPOINT (EndpointMBeanExportProperties)
endpoints.jmx.enabled=true
endpoints.jmx.domain= # the JMX domain, defaults to 'org.springboot'
endpoints.jmx.unique-names=false
endpoints.jmx.enabled=true
endpoints.jmx.staticNames=

# JOLOKIA (JolokiaProperties)
jolokia.config.*= # See Jolokia manual

# REMOTE SHELL
shell.auth=simple # jaas, key, simple, spring
shell.command-refresh-interval=-1
shell.command-path-pattern="classpath*:/commands/**, classpath*:/crash/commands/**"
shell.config-path-patterns="classpath*:/crash/*"
shell.disabled-plugins=false # don't expose plugins
shell.ssh.enabled= # ssh settings ...
shell.ssh.keyPath=
shell.ssh.port=
shell.telnet.enabled= # telnet settings ...
shell.telnet.port=
shell.auth.jaas.domain= # authentication settings ...
shell.auth.key.path=
shell.auth.simple.user.name=
shell.auth.simple.user.password=
shell.auth.spring.roles=

# GIT INFO
spring.git.properties= # resource ref to generated git info properties file
----

[appendix]
== Auto-configuration classes
Here is a list of all auto configuration classes provided by Spring Boot with links to
documentation and source code. Remember to also look at the autoconfig report in your
application for more details of which features are switched on in that specific use case
(start the app with "--debug" or "-Ddebug", or in an Actuator app go to "/autoconfig").

=== From the ``spring-boot-autoconfigure'' module
The following auto-configuration classes are from the `spring-boot-autoconfigure` module:

|===
|Configuration Class | Links

|{sc-spring-boot-autoconfigure}/MessageSourceAutoConfiguration.{sc-ext}[MessageSourceAutoConfiguration]
|{dc-spring-boot-autoconfigure}/MessageSourceAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-autoconfigure}/PropertyPlaceholderAutoConfiguration.{sc-ext}[PropertyPlaceholderAutoConfiguration]
|{dc-spring-boot-autoconfigure}/PropertyPlaceholderAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-autoconfigure}/amqp/RabbitAutoConfiguration.{sc-ext}[RabbitAutoConfiguration]
|{dc-spring-boot-autoconfigure}/amqp/RabbitAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-autoconfigure}/aop/AopAutoConfiguration.{sc-ext}[AopAutoConfiguration]
|{dc-spring-boot-autoconfigure}/aop/AopAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-autoconfigure}/batch/BatchAutoConfiguration.{sc-ext}[BatchAutoConfiguration]
|{dc-spring-boot-autoconfigure}/batch/BatchAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-autoconfigure}/data/JpaRepositoriesAutoConfiguration.{sc-ext}[JpaRepositoriesAutoConfiguration]
|{dc-spring-boot-autoconfigure}/data/JpaRepositoriesAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-autoconfigure}/data/MongoRepositoriesAutoConfiguration.{sc-ext}[MongoRepositoriesAutoConfiguration]
|{dc-spring-boot-autoconfigure}/data/MongoRepositoriesAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-autoconfigure}/data/MongoTemplateAutoConfiguration.{sc-ext}[MongoTemplateAutoConfiguration]
|{dc-spring-boot-autoconfigure}/data/MongoTemplateAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-autoconfigure}/jdbc/DataSourceAutoConfiguration.{sc-ext}[DataSourceAutoConfiguration]
|{dc-spring-boot-autoconfigure}/jdbc/DataSourceAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-autoconfigure}/jdbc/DataSourceTransactionManagerAutoConfiguration.{sc-ext}[DataSourceTransactionManagerAutoConfiguration]
|{dc-spring-boot-autoconfigure}/jdbc/DataSourceTransactionManagerAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-autoconfigure}/jms/JmsTemplateAutoConfiguration.{sc-ext}[JmsTemplateAutoConfiguration]
|{dc-spring-boot-autoconfigure}/jms/JmsTemplateAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-autoconfigure}/jmx/JmxAutoConfiguration.{sc-ext}[JmxAutoConfiguration]
|{dc-spring-boot-autoconfigure}/jmx/JmxAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-autoconfigure}/mobile/DeviceResolverAutoConfiguration.{sc-ext}[DeviceResolverAutoConfiguration]
|{dc-spring-boot-autoconfigure}/mobile/DeviceResolverAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-autoconfigure}/mongo/MongoAutoConfiguration.{sc-ext}[MongoAutoConfiguration]
|{dc-spring-boot-autoconfigure}/mongo/MongoAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-autoconfigure}/orm/jpa/HibernateJpaAutoConfiguration.{sc-ext}[HibernateJpaAutoConfiguration]
|{dc-spring-boot-autoconfigure}/orm/jpa/HibernateJpaAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-autoconfigure}/reactor/ReactorAutoConfiguration.{sc-ext}[ReactorAutoConfiguration]
|{dc-spring-boot-autoconfigure}/reactor/ReactorAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-autoconfigure}/redis/RedisAutoConfiguration.{sc-ext}[RedisAutoConfiguration]
|{dc-spring-boot-autoconfigure}/redis/RedisAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-autoconfigure}/security/SecurityAutoConfiguration.{sc-ext}[SecurityAutoConfiguration]
|{dc-spring-boot-autoconfigure}/security/SecurityAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-autoconfigure}/thymeleaf/ThymeleafAutoConfiguration.{sc-ext}[ThymeleafAutoConfiguration]
|{dc-spring-boot-autoconfigure}/thymeleaf/ThymeleafAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-autoconfigure}/web/DispatcherServletAutoConfiguration.{sc-ext}[DispatcherServletAutoConfiguration]
|{dc-spring-boot-autoconfigure}/web/DispatcherServletAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-autoconfigure}/web/EmbeddedServletContainerAutoConfiguration.{sc-ext}[EmbeddedServletContainerAutoConfiguration]
|{dc-spring-boot-autoconfigure}/web/EmbeddedServletContainerAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-autoconfigure}/web/HttpMessageConvertersAutoConfiguration.{sc-ext}[HttpMessageConvertersAutoConfiguration]
|{dc-spring-boot-autoconfigure}/web/HttpMessageConvertersAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-autoconfigure}/web/MultipartAutoConfiguration.{sc-ext}[MultipartAutoConfiguration]
|{dc-spring-boot-autoconfigure}/web/MultipartAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-autoconfigure}/web/ServerPropertiesAutoConfiguration.{sc-ext}[ServerPropertiesAutoConfiguration]
|{dc-spring-boot-autoconfigure}/web/ServerPropertiesAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-autoconfigure}/web/WebMvcAutoConfiguration.{sc-ext}[WebMvcAutoConfiguration]
|{dc-spring-boot-autoconfigure}/web/WebMvcAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-autoconfigure}/websocket/WebSocketAutoConfiguration.{sc-ext}[WebSocketAutoConfiguration]
|{dc-spring-boot-autoconfigure}/websocket/WebSocketAutoConfiguration.{dc-ext}[javadoc]
|===


=== From the ``spring-boot-actuator'' module
The following auto-configuration classes are from the `spring-boot-actuator` module:

|===
|Configuration Class |Links

|{sc-spring-boot-actuator}/autoconfigure/AuditAutoConfiguration.{sc-ext}[AuditAutoConfiguration]
|{dc-spring-boot-actuator}/autoconfigure/AuditAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-actuator}/autoconfigure/CrshAutoConfiguration.{sc-ext}[CrshAutoConfiguration]
|{dc-spring-boot-actuator}/autoconfigure/CrshAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-actuator}/autoconfigure/EndpointAutoConfiguration.{sc-ext}[EndpointAutoConfiguration]
|{dc-spring-boot-actuator}/autoconfigure/EndpointAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-actuator}/autoconfigure/EndpointMBeanExportAutoConfiguration.{sc-ext}[EndpointMBeanExportAutoConfiguration]
|{dc-spring-boot-actuator}/autoconfigure/EndpointMBeanExportAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-actuator}/autoconfigure/EndpointWebMvcAutoConfiguration.{sc-ext}[EndpointWebMvcAutoConfiguration]
|{dc-spring-boot-actuator}/autoconfigure/EndpointWebMvcAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-actuator}/autoconfigure/ErrorMvcAutoConfiguration.{sc-ext}[ErrorMvcAutoConfiguration]
|{dc-spring-boot-actuator}/autoconfigure/ErrorMvcAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-actuator}/autoconfigure/JolokiaAutoConfiguration.{sc-ext}[JolokiaAutoConfiguration]
|{dc-spring-boot-actuator}/autoconfigure/JolokiaAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-actuator}/autoconfigure/ManagementSecurityAutoConfiguration.{sc-ext}[ManagementSecurityAutoConfiguration]
|{dc-spring-boot-actuator}/autoconfigure/ManagementSecurityAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-actuator}/autoconfigure/ManagementServerPropertiesAutoConfiguration.{sc-ext}[ManagementServerPropertiesAutoConfiguration]
|{dc-spring-boot-actuator}/autoconfigure/ManagementServerPropertiesAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-actuator}/autoconfigure/MetricFilterAutoConfiguration.{sc-ext}[MetricFilterAutoConfiguration]
|{dc-spring-boot-actuator}/autoconfigure/MetricFilterAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-actuator}/autoconfigure/MetricRepositoryAutoConfiguration.{sc-ext}[MetricRepositoryAutoConfiguration]
|{dc-spring-boot-actuator}/autoconfigure/MetricRepositoryAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-actuator}/autoconfigure/TraceRepositoryAutoConfiguration.{sc-ext}[TraceRepositoryAutoConfiguration]
|{dc-spring-boot-actuator}/autoconfigure/TraceRepositoryAutoConfiguration.{dc-ext}[javadoc]

|{sc-spring-boot-actuator}/autoconfigure/TraceWebFilterAutoConfiguration.{sc-ext}[TraceWebFilterAutoConfiguration]
|{dc-spring-boot-actuator}/autoconfigure/TraceWebFilterAutoConfiguration.{dc-ext}[javadoc]
|===

