<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>

<article lang="en">
<articleinfo>
    <title>Spring Boot Reference Guide</title>
    <author>
        <firstname>Phillip Webb, Dave Syer</firstname>
    </author>
    <authorinitials>P</authorinitials>
</articleinfo>
<section id="_spring_boot_documentation">
<title>Spring Boot Documentation</title>
<section id="_getting_help">
<title>Getting help</title>
<simpara>Having trouble with Spring Boot, We&#8217;d like to help!</simpara>
<itemizedlist>
<listitem>
<simpara>
Try the How-to&#8217;s&#8201;&#8212;&#8201;they provide solutions to the most common questions
</simpara>
</listitem>
<listitem>
<simpara>
Learn the Spring basics&#8201;&#8212;&#8201;Spring Boot is builds on many other Spring projects, check
        the <ulink url="http://spring.io">spring.io</ulink> web-site for a wealth of reference documentation. If
        you are just starting out with Spring, try one of the <ulink url="http://spring.io/guides">guides</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
Ask a questions - we monitor <ulink url="http://stackoverflow.com">stackoverflow.com</ulink> for questions
        tagged with <ulink url="http://stackoverflow.com/tags/spring-boot"><literal>spring-boot</literal></ulink>
</simpara>
</listitem>
<listitem>
<simpara>
Report bugs with Spring Boot at <ulink url="https://github.com/spring-projects/spring-boot/issues">https://github.com/spring-projects/spring-boot/issues</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_first_steps">
<title>First steps</title>
<simpara>If you are just starting out&#8230;</simpara>
<itemizedlist>
<listitem>
<simpara>
From scratch
</simpara>
</listitem>
<listitem>
<simpara>
Tutorial
</simpara>
</listitem>
<listitem>
<simpara>
Advanced tutorial
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="_getting_started">
<title>Getting started</title>
<section id="_introducing_spring_boot">
<title>Introducing Spring Boot</title>
<simpara>Spring Boot makes it easy to create stand-alone, production-grade Spring based
Applications that can you can &#8220;just run&#8221;. We take an opinionated view of the Spring
platform and third-party libraries so you can get started with minimum fuss. Most Spring
Boot applications need very little Spring configuration.</simpara>
<simpara>You can use Spring Boot to create Java applications that can be started using <literal>java -jar</literal>
or more traditional WAR deployments. We also provide a command line tool that runs &#8220;spring
scripts&#8221;.</simpara>
<simpara>Our primary goals are:</simpara>
<itemizedlist>
<listitem>
<simpara>
Provide a radically faster and widely accessible getting started experience for all
Spring development
</simpara>
</listitem>
<listitem>
<simpara>
Be opinionated out of the box, but get out of the way quickly as requirements start to
diverge from the defaults
</simpara>
</listitem>
<listitem>
<simpara>
Provide a range of non-functional features that are common to large classes of projects
(e.g. embedded servers, security, metrics, health checks, externalized configuration)
</simpara>
</listitem>
<listitem>
<simpara>
Absolutely no code generation and no requirement for XML configuration
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_installing_spring_boot">
<title>Installing Spring Boot</title>
<simpara>Spring Boot can be used with &#8220;classic&#8221; Java development tools or installed as a command
line tool. Regardless, you will need <ulink url="http://www.java.com">Java SDK v1.6</ulink> or higher. You
should check your current Java installation before you begin:</simpara>
<screen>        $ java -version</screen>
<simpara>If you are new to Java development, or if you just want to experiment with Spring Boot
you might want to try the Spring Boot CLI first, otherwise, read on for &#8220;classic&#8221;
installation instructions.</simpara>
<tip><simpara>Although Spring Boot is compatible with Java 1.6, if possible, you should consider
using the latest version of Java.</simpara></tip>
<section id="_installation_instructions_for_the_java_developer">
<title>Installation instructions for the Java developer</title>
<simpara>You can use Spring Boot in the same way as any standard java library. Simply include the
appropriate <literal>spring-boot-*.jar</literal> files in your classpath. Spring Boot does not require
any special tool integration, so you can use any IDE or text editor; and there is nothing
special about a Spring Boot application, so you can run and debug as you would any other
Java program.</simpara>
<simpara>Although you <emphasis>could</emphasis> just copy Spring Boot JARs, we generally recommend that you use a
build tool that support dependency management (such as Maven or Gradle).</simpara>
<section id="_maven_installation">
<title>Maven installation</title>
<simpara>Spring Boot is compatible with Apache Maven 3.0 or above. If you don&#8217;t already have Maven
installed you can follow the instructions at <ulink url="http://maven.apache.org">http://maven.apache.org</ulink>.</simpara>
<tip><simpara>On many operating systems Maven can be installed via a package manager. If you&#8217;re a
OSX Homebrew user try <literal>brew install maven</literal>. Ubuntu users can run <literal>sudo apt-get install maven</literal>.</simpara></tip>
<simpara>Spring Boot dependencies use the <literal>org.springframework.boot</literal> <literal>groupId</literal>. Typically your
Maven POM file will inherit from the <literal>spring-boot-starter-parent</literal> project and declare
dependencies to one or more &#8220;starter POMs&#8221;. Spring Boot also provides an optional Maven
plugin to create executable JARs.</simpara>
<simpara>Here is a typical <literal>pom.xml</literal> file:</simpara>
<programlisting language="xml" linenumbering="indent=0">        &lt;?xml version="1.0" encoding="UTF-8"?&gt;
        &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
                &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

                &lt;groupId&gt;com.example&lt;/groupId&gt;
                &lt;artifactId&gt;myproject&lt;/artifactId&gt;
                &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

                &lt;!-- Inherit defaults from Spring Boot --&gt;
                &lt;parent&gt;
                        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
                        &lt;version&gt;{spring-boot-version}&lt;/version&gt;
                &lt;/parent&gt;

                &lt;!-- Add typical dependencies for a web application --&gt;
                &lt;dependencies&gt;
                        &lt;dependency&gt;
                                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                                &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
                        &lt;/dependency&gt;
                &lt;/dependencies&gt;

                &lt;!-- Package as an executable JAR --&gt;
                &lt;build&gt;
                        &lt;plugins&gt;
                                &lt;plugin&gt;
                                        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                                        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                                &lt;/plugin&gt;
                        &lt;/plugins&gt;
                &lt;/build&gt;

                &lt;!-- Add Spring repoistories --&gt;
                &lt;!-- (you don't need this if you are using a .RELEASE version) --&gt;
                &lt;repositories&gt;
                        &lt;repository&gt;
                                &lt;id&gt;spring-snapshots&lt;/id&gt;
                                &lt;url&gt;http://repo.spring.io/snapshot&lt;/url&gt;
                                &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;
                        &lt;/repository&gt;
                        &lt;repository&gt;
                                &lt;id&gt;spring-milestones&lt;/id&gt;
                                &lt;url&gt;http://repo.spring.io/milestone&lt;/url&gt;
                        &lt;/repository&gt;
                &lt;/repositories&gt;
                &lt;pluginRepositories&gt;
                        &lt;pluginRepository&gt;
                                &lt;id&gt;spring-snapshots&lt;/id&gt;
                                &lt;url&gt;http://repo.spring.io/snapshot&lt;/url&gt;
                        &lt;/pluginRepository&gt;
                        &lt;pluginRepository&gt;
                                &lt;id&gt;spring-milestones&lt;/id&gt;
                                &lt;url&gt;http://repo.spring.io/milestone&lt;/url&gt;
                        &lt;/pluginRepository&gt;
                &lt;/pluginRepositories&gt;
        &lt;/project&gt;</programlisting>
</section>
<section id="_gradle_installation">
<title>Gradle installation</title>
<simpara>Spring Boot is compatible with Gradle 1.6 or above. If you don&#8217;t already have Gradle
installed you can follow the instructions at <ulink url="http://www.gradle.org/">http://www.gradle.org/</ulink>.</simpara>
<simpara>Spring Boot dependencies can be declared using the <literal>org.springframework.boot</literal> <literal>group</literal>.
Typically your project will declare dependencies to one or more starter POMs. Spring Boot
provides a useful Gradle plugin that can be used to simplify dependency declarations
and to create executable JARs.</simpara>
<sidebar>
<title>Gradle Wrapper</title>
<simpara>The Gradle Wrapper provides a nice way of &#8220;obtaining&#8221; Gradle when you need to build a
project. It&#8217;s a small script and library that you commit alongside your code to bootstrap
the build process. See <ulink url="http://www.gradle.org/docs/current/userguide/gradle_wrapper.html">http://www.gradle.org/docs/current/userguide/gradle_wrapper.html</ulink>
for details.</simpara>
</sidebar>
<simpara>Here is a typical <literal>build.gradle</literal> file:</simpara>
<programlisting language="groovy" linenumbering="indent=0">        buildscript {
                repositories {
                        mavenCentral()
                        maven { url "http://repo.spring.io/snapshot" }
                        maven { url "http://repo.spring.io/milestone" }
                }
                dependencies {
                        classpath("org.springframework.boot:spring-boot-gradle-plugin:{spring-boot-version}")
                }
        }

        apply plugin: 'java'
        apply plugin: 'spring-boot'

        jar {
                baseName = 'myproject'
                version =  '0.0.1-SNAPSHOT'
        }

        repositories {
                mavenCentral()
                maven { url "http://repo.spring.io/snapshot" }
                maven { url "http://repo.spring.io/milestone" }
        }

        dependencies {
                compile("org.springframework.boot:spring-boot-starter-web")
                testCompile("junit:junit")
        }</programlisting>
</section>
</section>
<section id="_installing_the_spring_boot_cli">
<title>Installing the Spring Boot CLI</title>
<simpara>The Spring Boot CLI is a command line tool that can be used if you want to quickly
prototype with Spring. It allows you to run <ulink url="http://groovy.codehaus.org/">Groovy</ulink> scripts,
which means that you have a familiar Java-like syntax, without so much boilerplate code.</simpara>
<simpara>You don&#8217;t need to use the CLI to work with Spring Boot but it&#8217;s definitely the quickest
way to get a Spring application off the ground.</simpara>
<section id="_manual_installation">
<title>Manual installation</title>
<simpara>You can download the Spring CLI distribution from the Spring software repository:</simpara>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://repo.spring.io/snapshot/org/springframework/boot/spring-boot-cli/1.0.0.BUILD-SNAPSHOT/spring-boot-cli-1.0.0.BUILD-SNAPSHOT-bin.zip">spring-boot-cli-1.0.0.BUILD-SNAPSHOT-bin.zip</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://repo.spring.io/snapshot/org/springframework/boot/spring-boot-cli/1.0.0.BUILD-SNAPSHOT/spring-boot-cli-1.0.0.BUILD-SNAPSHOT-bin.tar.gz">spring-boot-cli-1.0.0.BUILD-SNAPSHOT-bin.tar.gz</ulink>
</simpara>
</listitem>
</itemizedlist>
<simpara>Cutting edge <ulink url="http://repo.spring.io/snapshot/org/springframework/boot/spring-boot-cli/">snapshot distributions</ulink>
are also available.</simpara>
<simpara>Once downloaded, follow the INSTALL instructions from the unpacked archive. In summary:
there is a <literal>spring</literal> script (<literal>spring.bat</literal> for Windows) in a <literal>bin/</literal> directory in the <literal>.zip</literal>
file, or alternatively you can use <literal>java -jar</literal> with the <literal>.jar</literal> file (the script helps you
to be sure that the classpath is set correctly).</simpara>
</section>
<section id="_installation_with_gvm">
<title>Installation with GVM</title>
<simpara>GVM (the Groovy Environment Manager) can be used for managing multiple versions of
various Groovy and Java binary packages, including Groovy itself and the Spring Boot CLI.
Get <literal>gvm</literal> from <ulink url="http://gvmtool.net">http://gvmtool.net</ulink> and install Spring Boot with</simpara>
<screen>        $ gvm install springboot
        $ spring --version
        Spring Boot v1.0.0.BUILD-SNAPSHOT</screen>
<simpara>If you are developing features for the CLI and want easy access to the version you just
built, follow these extra instructions.</simpara>
<screen>        $ gvm install springboot dev /path/to/spring-boot/spring-boot-cli/target/spring-boot-cli-1.0.0.BUILD-SNAPSHOT-bin/spring-1.0.0.BUILD-SNAPSHOT/
        $ gvm use springboot dev
        $ spring --version
        Spring CLI v1.0.0.BUILD-SNAPSHOT</screen>
<simpara>This will install a local instance of <literal>spring</literal> called the <literal>dev</literal> instance inside your gvm
repository. It points at your target build location, so every time you rebuild Spring
Boot, <literal>spring</literal> will be up-to-date.</simpara>
<simpara>You can see it by doing this:</simpara>
<screen>        $ gvm ls springboot

        ================================================================================
        Available Springboot Versions
        ================================================================================
        &gt; + dev
        * 1.0.0.BUILD-SNAPSHOT

        ================================================================================
        + - local version
        * - installed
        &gt; - currently in use
        ================================================================================</screen>
</section>
<section id="_osx_homebrew_installation">
<title>OSX Homebrew installation</title>
<simpara>If you are on a Mac and using <ulink url="http://brew.sh/">Homebrew</ulink>, all you need to do to install
the Spring Boot CLI is:</simpara>
<screen>        $ brew tap pivotal/tap
        $ brew install springboot</screen>
<simpara>Homebrew will install <literal>spring</literal> to <literal>/usr/local/bin</literal>.</simpara>
<note><simpara>If you don&#8217;t see the formula, you&#8217;re installation of brew might be out-of-date.
Just execute <literal>brew update</literal> and try again.</simpara></note>
</section>
<section id="_quick_start_spring_cli_example">
<title>Quick start Spring CLI example</title>
<simpara>Here&#8217;s a really simple web application that you can use to test you installation. Create
a file called <literal>app.groovy</literal>:</simpara>
<programlisting language="groovy" linenumbering="indent=0">        @Controller
        class ThisWillActuallyRun {

                @RequestMapping("/")
                @ResponseBody
                String home() {
                        return "Hello World!"
                }

        }</programlisting>
<simpara>Then simply run it from a shell:</simpara>
<screen>        $ spring run app.groovy</screen>
<note><simpara>It will take some time when you first run the application as dependencies are
downloaded, subsequent runs will be much quicker.</simpara></note>
<simpara>Open <ulink url="http://localhost:8080">http://localhost:8080</ulink> in your favorite web browser and you should see the following
output:</simpara>
<screen>        Hello World!</screen>
</section>
</section>
</section>
<section id="_developing_your_first_spring_boot_application">
<title>Developing your first Spring Boot application</title>
<simpara>Let&#8217;s develop a simple &#8220;Hello World!&#8221; web application in Java that highlights some
of Spring Boot&#8217;s key features. We&#8217;ll use Maven to build this project since most IDEs
support it.</simpara>
<tip><simpara>The <ulink url="http://spring.io">spring.io</ulink> web site contains many &#8220;Getting Started&#8221; guides
that use Spring Boot. If you&#8217;re looking to solve a specific problem; check there first.</simpara></tip>
<simpara>Before we begin, open a terminal to check that you have valid versions of Java and Maven
installed.</simpara>
<screen>        $ java -version
        java version "1.7.0_51"
        Java(TM) SE Runtime Environment (build 1.7.0_51-b13)
        Java HotSpot(TM) 64-Bit Server VM (build 24.51-b03, mixed mode)</screen>
<screen>        $ mvn -v
        Apache Maven 3.1.1 (0728685237757ffbf44136acec0402957f723d9a; 2013-09-17 08:22:22-0700)
        Maven home: /Users/user/tools/apache-maven-3.1.1
        Java version: 1.7.0_51, vendor: Oracle Corporation</screen>
<note><simpara>This sample needs to be created in it&#8217;s own folder. Subsequent instructions assume
that you have created a suitable folder and that it is your &#8220;current directory&#8221;.</simpara></note>
<section id="_creating_the_pom">
<title>Creating the POM</title>
<simpara>We need to start by creating a Maven <literal>pom.xml</literal> file. The <literal>pom.xml</literal> is the recipe that
will be used to build your project. Open you favorite text editor and add the following:</simpara>
<programlisting language="xml" linenumbering="indent=0">        &lt;?xml version="1.0" encoding="UTF-8"?&gt;
        &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
                &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

                &lt;groupId&gt;com.example&lt;/groupId&gt;
                &lt;artifactId&gt;myproject&lt;/artifactId&gt;
                &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

                &lt;parent&gt;
                        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
                        &lt;version&gt;{spring-boot-version}&lt;/version&gt;
                &lt;/parent&gt;

                &lt;!-- Additional lines to be added here... --&gt;

                &lt;!-- (you don't need this if you are using a .RELEASE version) --&gt;
                &lt;repositories&gt;
                        &lt;repository&gt;
                                &lt;id&gt;spring-snapshots&lt;/id&gt;
                                &lt;url&gt;http://repo.spring.io/snapshot&lt;/url&gt;
                                &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;
                        &lt;/repository&gt;
                        &lt;repository&gt;
                                &lt;id&gt;spring-milestones&lt;/id&gt;
                                &lt;url&gt;http://repo.spring.io/milestone&lt;/url&gt;
                        &lt;/repository&gt;
                &lt;/repositories&gt;
                &lt;pluginRepositories&gt;
                        &lt;pluginRepository&gt;
                                &lt;id&gt;spring-snapshots&lt;/id&gt;
                                &lt;url&gt;http://repo.spring.io/snapshot&lt;/url&gt;
                        &lt;/pluginRepository&gt;
                        &lt;pluginRepository&gt;
                                &lt;id&gt;spring-milestones&lt;/id&gt;
                                &lt;url&gt;http://repo.spring.io/milestone&lt;/url&gt;
                        &lt;/pluginRepository&gt;
                &lt;/pluginRepositories&gt;
        &lt;/project&gt;</programlisting>
<simpara>This should give you a working build, you can test it out by running <literal>mvn package</literal> (you
can ignore the <emphasis>`JAR will be empty - no content was marked for inclusion!'</emphasis> warning for
now).</simpara>
<note><simpara>At this point you could import the project into an IDE (most modern Java IDE&#8217;s
include built-in support for Maven). For simplicity, we will continue to use a simple
text editor for this example.</simpara></note>
</section>
<section id="_adding_classpath_dependencies">
<title>Adding classpath dependencies</title>
<simpara>Spring Boot provides a number of &#8220;Starter POMs&#8221; that make easy to add JARs to your
classpath. Our sample application has already used <literal>spring-boot-starter-parent</literal> in the
<literal>parent</literal> section of the POM. The <literal>spring-boot-starter-parent</literal> is a special starter
that provides useful Maven defaults. It also provides a <literal>dependency-management</literal> section
so that you can omit <literal>version</literal> tags for blessed <literal>dependencies</literal>.</simpara>
<simpara>Other &#8220;Starter POMs&#8221; simply provide dependencies that you are likely to need to a
specific type of application. Since we are developing web application we will add a
<literal>spring-boot-starter-web</literal> dependency&#8201;&#8212;&#8201;but before that, lets look at what we currently
have.</simpara>
<screen>        $ mvn dependency:tree

        [INFO] com.example:myproject:jar:0.0.1-SNAPSHOT
        [INFO] +- junit:junit:jar:4.11:test
        [INFO] |  \- org.hamcrest:hamcrest-core:jar:1.3:test
        [INFO] +- org.mockito:mockito-core:jar:1.9.5:test
        [INFO] |  \- org.objenesis:objenesis:jar:1.0:test
        [INFO] \- org.hamcrest:hamcrest-library:jar:1.3:test</screen>
<simpara>The <literal>mvn dependency:tree</literal> command prints tree representation of your project dependencies.
You can see that <literal>spring-boot-starter-parent</literal> has already provides some useful test
dependencies. Lets edit our <literal>pom.xml</literal> and add the <literal>spring-boot-starter-web</literal> dependency
just below the <literal>parent</literal> section:</simpara>
<programlisting language="xml" linenumbering="indent=0">        &lt;dependencies&gt;
                &lt;dependency&gt;
                        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
                &lt;/dependency&gt;
        &lt;/dependencies&gt;</programlisting>
<simpara>If you run <literal>mvn dependency:tree</literal> again, you will see that there are now a number of
additional dependencies, including the Tomcat web server and Spring Boot itself.</simpara>
</section>
<section id="_writing_the_code">
<title>Writing the code</title>
<simpara>To finish our application we need to create a single Java file. Maven will compile sources
from <literal>src/main/java</literal> so you need to create that folder structure, then add a file named
<literal>src/main/java/Example.java</literal>:</simpara>
<programlisting language="java" linenumbering="indent=0">        import org.springframework.boot.*;
        import org.springframework.boot.autoconfigure.*;
        import org.springframework.stereotype.*;
        import org.springframework.web.bind.annotation.*;

        @Controller
        @EnableAutoConfiguration
        public class Example {

                @RequestMapping("/")
                @ResponseBody
                String home() {
                        return "Hello World!";
                }

                public static void main(String[] args) throws Exception {
                        SpringApplication.run(Example.class, args);
                }

        }</programlisting>
<simpara>Although there isn&#8217;t much code here, quite a lot is going on. Lets step though the
important parts of the code.</simpara>
<section id="_the_controller_requestmapping_and_responsebody_annotations">
<title>The @Controller, @RequestMapping and @ResponseBody annotations</title>
<simpara>The first annotation on our <literal>Example</literal> class is <literal>@Controller</literal>. This is known as a
<emphasis>stereotype</emphasis> annotation. It provides hints for people reading the code, and for Spring,
that the class plays a specific role. In this case, our class is web <literal>@Controller</literal> so
Spring will consider it when handling incoming web requests.</simpara>
<simpara>The <literal>@RequestMapping</literal> annotation provides &#8220;routing&#8221; information. It is telling Spring
that any HTTP request with the path "<literal>/</literal>" should be mapped to the method. The additional
<literal>@ResponseBody</literal> annotation tells Spring to render the resulting string directly back to
the caller.</simpara>
<tip><simpara>The <literal>@Controller</literal>, <literal>@RequestMapping</literal> and <literal>@ResponseBody</literal> annotation are Spring MVC
annotations (they are not specific to Spring Boot). See the MVC section in the Spring
Reference Documentation for more details.</simpara></tip>
</section>
<section id="_the_enableautoconfiguration_annotation">
<title>The @EnableAutoConfiguration annotation</title>
<simpara>The second class-level annotation is <literal>@EnableAutoConfiguration</literal>. This annotation tells
Spring Boot to &#8220;guess&#8221; how you will want to configure Spring based on the JAR
dependencies that you have added. Since <literal>spring-boot-starter-web</literal> added Tomcat and
Spring MVC, the auto-configuration will assume that you are developing a web application
and setup Spring accordingly.</simpara>
<sidebar>
<title>Starter POMs and Auto-Configuration</title>
<simpara>Auto-configuration is designed to work well with &#8220;Starter POMs&#8221;, but the two concepts
are not directly tied. You are free to pick-and-choose JAR dependencies outside of the
starter POMs and Spring Boot will still do its best to auto-configure your application.</simpara>
</sidebar>
</section>
<section id="_the_8220_main_8221_method">
<title>The &#8220;main&#8221; method</title>
<simpara>The final part of our application is the <literal>main</literal> method. This is just a standard method
that follows the Java convention for an application entry point. Our main method delegates
to Spring Boot&#8217;s <literal>SpringApplication</literal> class by calling <literal>run</literal>. <literal>SpringApplication</literal> will
bootstrap our application, starting Spring which will in turn start the auto-configured
Tomcat web server. We need to pass <literal>Example.class</literal> as an argument to the <literal>run</literal> method to
tell <literal>SpringApplication</literal> which is the primary Spring component. The <literal>args</literal> array is also
passed though to expose any command-line arguments.</simpara>
</section>
</section>
<section id="_running_the_example">
<title>Running the example</title>
<simpara>At this point out application should work. Since we have used the
<literal>spring-boot-starter-parent</literal> POM we have a useful <literal>run</literal> goal that we can use to start
the application. Type <literal>mvn spring-boot:run</literal> from the root project directory to start the
application:</simpara>
<screen>        $ mvn spring-boot:run

          .   ____          _            __ _ _
         /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
        ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
         \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
          '  |____| .__|_| |_|_| |_\__, | / / / /
         =========|_|==============|___/=/_/_/_/
         :: Spring Boot ::  (v1.0.0.BUILD-SNAPSHOT)
        ....... . . .
        ....... . . . (log output here)
        ....... . . .
        ........ Started Example in 2.222 seconds (JVM running for 6.514)</screen>
<simpara>If you open a web browser to <ulink url="http://localhost:8080">http://localhost:8080</ulink> you should see the following output:</simpara>
<screen>        Hello World!</screen>
<simpara>To gracefully exist the application hit <literal>ctrl-c</literal>.</simpara>
</section>
<section id="_creating_an_executable_jar">
<title>Creating an executable JAR</title>
<simpara>Lets finish our example by create a completely self-contained executable JAR file that
we could run in production. Executable JARs (sometimes called &#8220;Fat JARs&#8221;) are archives
containing your compiled classes along with all of the JAR dependencies that your code
needs to run.</simpara>
<sidebar>
<title>Executable JARs and Java</title>
<simpara>Java does not provide any standard way to load nested jar files (i.e. jar files that are
themselves contained within a jar). This can be problematic if you are looking to
distribute a self contained application.</simpara>
<simpara>To solve this problem, many developers use &#8220;shaded&#8221; jars. A shaded jar simply packages
all classes, from all jars, into a single &#8220;uber jar&#8221;. The problem with shaded jars is that
it becomes hard to see which libraries you are actually using in your application. It can
also be problematic if the the same filename is used (but with different content) in
multiple jars.</simpara>
<simpara>Spring Boot takes a different approach and allows you to actually nest jars directly.</simpara>
</sidebar>
<simpara>To create an executable JAR we need to add the <literal>spring-boot-maven-plugin</literal> to our
<literal>pom.xml</literal>. Insert the following lines just below the <literal>dependencies</literal> section:</simpara>
<programlisting language="xml" linenumbering="indent=0">        &lt;build&gt;
                &lt;plugins&gt;
                        &lt;plugin&gt;
                                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                        &lt;/plugin&gt;
                &lt;/plugins&gt;
        &lt;/build&gt;</programlisting>
<simpara>Save your <literal>pom.xml</literal> and run <literal>mvn package</literal> from the command line:</simpara>
<screen>        $ mvn package

        [INFO] Scanning for projects...
        [INFO]
        [INFO] ------------------------------------------------------------------------
        [INFO] Building myproject 0.0.1-SNAPSHOT
        [INFO] ------------------------------------------------------------------------
        [INFO] .... ..
        [INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ myproject ---
        [INFO] Building jar: /Users/pwebb/tmp/spring-boot-example/target/myproject-0.0.1-SNAPSHOT.jar
        [INFO]
        [INFO] --- spring-boot-maven-plugin:1.0.0.BUILD-SNAPSHOT:repackage (default) @ myproject ---
        [INFO] ------------------------------------------------------------------------
        [INFO] BUILD SUCCESS
        [INFO] ------------------------------------------------------------------------</screen>
<simpara>If you look in the <literal>target</literal> directory you should see <literal>myproject-0.0.1-SNAPSHOT.jar</literal>. The
file should be around 10 Mb in size. If you want to peek inside, you can use <literal>jar tvf</literal>:</simpara>
<screen>        $ jar tvf target/myproject-0.0.1-SNAPSHOT.jar</screen>
<simpara>You should also see a much smaller file named <literal>myproject-0.0.1-SNAPSHOT.jar.original</literal>
in the <literal>target</literal> directory. This is the original JAR file that Maven created before it was
repackaged by Spring Boot.</simpara>
<simpara>To run that application, use the <literal>java -jar</literal> command:</simpara>
<screen>        $ java -jar target/myproject-0.0.1-SNAPSHOT.jar

          .   ____          _            __ _ _
         /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
        ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
         \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
          '  |____| .__|_| |_|_| |_\__, | / / / /
         =========|_|==============|___/=/_/_/_/
         :: Spring Boot ::  (v1.0.0.BUILD-SNAPSHOT)
        ....... . . .
        ....... . . . (log output here)
        ....... . . .
        ........ Started Example in 3.236 seconds (JVM running for 3.764)</screen>
<simpara>As before, to gracefully exist the application hit <literal>ctrl-c</literal>.</simpara>
</section>
</section>
<section id="_what_to_read_next">
<title>What to read next</title>
</section>
</section>
<section id="_using_spring_boot">
<title>Using Spring Boot</title>
<simpara>This section provides a brief overview of best-practices when using Spring Boot. There
is nothing particularly special about Spring Boot, it is just another library that you
can consume. There are, however, a few recommendations that when followed will make your
development process just a little easier.</simpara>
<section id="_build_systems">
<title>Build systems</title>
<simpara>It is strongly recommended that you choose a build system that supports <emphasis>dependency
management</emphasis>, and one that can consume artifacts published to the &#8220;Maven Central&#8221;
repository. We would recommend that you choose Maven or Gradle. It is possible to get
Spring Boot to work with other build systems (Ant for example), but they would not be
particularly well supported.</simpara>
<section id="_maven">
<title>Maven</title>
<simpara>Maven users can inherit from the <literal>spring-boot-starter-parent</literal> project to obtain sensible
defaults. The parent project provides the following features:</simpara>
<itemizedlist>
<listitem>
<simpara>
Java 1.6 as the default compiler level
</simpara>
</listitem>
<listitem>
<simpara>
UTF-8 source encoding
</simpara>
</listitem>
<listitem>
<simpara>
A Dependency Management section, allowing you to omit <literal>&lt;version&gt;</literal> tags for common
  dependencies.
</simpara>
</listitem>
<listitem>
<simpara>
Generally useful test dependencies (JUnit, Mockito, Hamcrest)
</simpara>
</listitem>
<listitem>
<simpara>
Sensible resource filtering
</simpara>
</listitem>
<listitem>
<simpara>
Sensible plugin configuration (exec plugin, surefire, git commit ID, shade)
</simpara>
</listitem>
</itemizedlist>
<section id="_inheriting_the_starter_parent">
<title>Inheriting the starter parent</title>
<simpara>To configure your project to inherit from the <literal>spring-boot-starter-parent</literal> simply set
the <literal>parent</literal>:</simpara>
<programlisting language="xml" linenumbering="indent=0">        &lt;!-- Inherit defaults from Spring Boot --&gt;
        &lt;parent&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
                &lt;version&gt;{spring-boot-version}&lt;/version&gt;
        &lt;/parent&gt;</programlisting>
<note><simpara>You should only need to specify the Spring Boot version number on this dependency.
if you import additional starters, you can safely omit the version number.</simpara></note>
</section>
<section id="_using_your_own_parent_pom">
<title>Using your own parent POM</title>
<simpara>If you don&#8217;t want to use the Spring Boot starter parent, you can use your own and still
keep the benefit of the dependency management (but not the plugin management) using a
<literal>scope=import</literal> dependency:</simpara>
<programlisting language="xml" linenumbering="indent=0">        &lt;dependencyManagement&gt;
                &lt;dependencies&gt;
                        &lt;dependency&gt;
                                &lt;!-- Import dependency management from Spring Boot --&gt;
                                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                                &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
                                &lt;version&gt;{spring-boot-version}&lt;/version&gt;
                        &lt;scope&gt;import&lt;/scope&gt;
                        &lt;/dependency&gt;
                &lt;/dependencies&gt;
        &lt;/dependencyManagement&gt;</programlisting>
</section>
<section id="_changing_the_java_version">
<title>Changing the Java version</title>
<simpara>The <literal>spring-boot-starter-parent</literal> chooses fairly conservative Java compatibility. If you
want to follow our recommendation and use a later Java version you can add a
<literal>java.version</literal> property:</simpara>
<programlisting language="xml" linenumbering="indent=0">        &lt;properties&gt;
                &lt;java.version&gt;1.8&lt;/java.version&gt;
        &lt;/properties&gt;</programlisting>
</section>
<section id="_using_the_spring_boot_maven_plugin">
<title>Using the Spring Boot Maven plugin</title>
<simpara>Spring Boot includes a Maven plugin that can package the project as an executable JAR, or
run it from source code. Add the plugin to your <literal>&lt;plugins&gt;</literal> section if you want to use it:</simpara>
<programlisting language="xml" linenumbering="indent=0">        &lt;build&gt;
                &lt;plugins&gt;
                        &lt;plugin&gt;
                                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                        &lt;/plugin&gt;
                &lt;/plugins&gt;
        &lt;/build&gt;</programlisting>
<note><simpara>You only need to add the plugin, there is no need for to configure it, unless you
want to change the settings in the parent.</simpara></note>
</section>
</section>
<section id="_gradle">
<title>Gradle</title>
<simpara>Gradle users can directly import &#8220;starter POMs&#8221; in their <literal>dependencies</literal> section. Unlike
Maven, there is no &#8220;super parent&#8221; to import.</simpara>
<programlisting language="groovy" linenumbering="indent=0">        apply plugin: 'java'

        repositories { mavenCentral() }
        dependencies {
                compile("org.springframework.boot:spring-boot-starter-web")
        }</programlisting>
<simpara>The <literal>spring-boot-gradle-plugin</literal> is also available and provides tasks to create executable
JARs and run projects from source. It also adds a <literal>ResolutionStrategy</literal> that enables you
to omit the version number for common dependencies:</simpara>
<programlisting language="groovy" linenumbering="indent=0">        buildscript {
                repositories { mavenCentral() }
                dependencies {
                        classpath("org.springframework.boot:spring-boot-gradle-plugin:${spring-boot-version}")
                }
        }

        apply plugin: 'java'
        apply plugin: 'spring-boot'

        repositories { mavenCentral() }
        dependencies {
                compile("org.springframework.boot:spring-boot-starter-web")
                testCompile("org.springframework.boot:spring-boot-starter-test")
        }</programlisting>
</section>
<section id="_ant">
<title>Ant</title>
<simpara>It is possible to build a Spring Boot project using Apache Ant, however, no special
support or plugins are provided. Ant scripts can use the Ivy dependency system to import
starter POMs.</simpara>
<simpara>See XXX for more complete instructions.</simpara>
</section>
<section id="_starter_poms">
<title>Starter POMs</title>
<simpara>Starter POMs are a set of convenient dependency descriptors that you can include in your
application. You get a one-stop-shop for all the Spring and related technology that you
need, without having to hunt through sample code and copy paste loads of dependency
descriptors. For example, if you want to get started using Spring and JPA for database
access, just include the <literal>spring-boot-starter-data-jpa</literal> dependency in your project, and
you are good to go.</simpara>
<simpara>The starters contain a lot of the dependencies that you need to get a project up and
running quickly and with a consistent, supported set of managed transitive dependencies.</simpara>
<sidebar>
<title>What&#8217;s in a name</title>
<simpara>All starters follow a similar naming pattern; &#8216;spring-boot-starter-*<literal>, where `*</literal> is
a particular type of application. This naming structure is intended to help when you need
to find a starter. The Maven integration in many IDEs allow you to search dependencies by
name. For example, with the appropriate Eclipse or STS plugin installed, you can simply
hit <literal>ctrl-space</literal> in the POM editor and type <emphasis>'spring-boot-starter</emphasis>&#8217; for a complete list.</simpara>
</sidebar>
<simpara>The following application starters are provided by Spring Boot under the
<literal>org.springframework.boot</literal> group:</simpara>
<table
frame="all"
rowsep="1" colsep="1"
>
<title>Spring Boot application starters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Name</simpara></entry>
<entry align="left" valign="top"><simpara>Description</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring-boot-starter</simpara></entry>
<entry align="left" valign="top"><simpara>The core Spring Boot starter, including auto-configuration support, logging and YAML.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring-boot-starter-amqp</simpara></entry>
<entry align="left" valign="top"><simpara>Support for the &#8220;Advanced Message Queuing Protocol&#8221; via <literal>spring-rabbit</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring-boot-starter-aop</simpara></entry>
<entry align="left" valign="top"><simpara>Full AOP programming support including <literal>spring-aop</literal> and AspectJ.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring-boot-starter-batch</simpara></entry>
<entry align="left" valign="top"><simpara>Support for &#8220;Spring Batch&#8221; including HSQLDB database.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring-boot-starter-data-jpa</simpara></entry>
<entry align="left" valign="top"><simpara>Full support for the &#8220;Java Persistence API&#8221; including <literal>spring-data-jpa</literal>, <literal>spring-orm</literal>
and Hibernate.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring-boot-starter-data-mongodb</simpara></entry>
<entry align="left" valign="top"><simpara>Support for the MongoDB NoSQL Database, including <literal>spring-data-mongodb</literal>,</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring-boot-starter-data-rest</simpara></entry>
<entry align="left" valign="top"><simpara>Support for exposing Spring Data repositories over REST via <literal>spring-data-rest-webmvc</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring-boot-starter-integration</simpara></entry>
<entry align="left" valign="top"><simpara>Support for common <literal>spring-integration</literal> modules.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring-boot-starter-jdbc</simpara></entry>
<entry align="left" valign="top"><simpara>JDBC Database support</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring-boot-starter-mobile</simpara></entry>
<entry align="left" valign="top"><simpara>Support for <literal>spring-mobile</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring-boot-starter-redis</simpara></entry>
<entry align="left" valign="top"><simpara>Support for the REDIS key-value data store, including <literal>spring-redis</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring-boot-starter-security</simpara></entry>
<entry align="left" valign="top"><simpara>Support for <literal>spring-security</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring-boot-starter-test</simpara></entry>
<entry align="left" valign="top"><simpara>Support for common test dependencies, including JUnit, Mockito and Hamcrest along with
 the <literal>spring-test</literal> module.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring-boot-starter-thymeleaf</simpara></entry>
<entry align="left" valign="top"><simpara>Support for the Thymeleaf templating engine, including integration with Spring.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring-boot-starter-web</simpara></entry>
<entry align="left" valign="top"><simpara>Support for full-stack web development, including Tomcat and <literal>spring-webmvc</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring-boot-starter-websocket</simpara></entry>
<entry align="left" valign="top"><simpara>Support for websocket development with Tomcat.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>In addition to the application starter, the following starters can be used to
add &#8220;production ready&#8221; features.</simpara>
<table
frame="all"
rowsep="1" colsep="1"
>
<title>Spring Boot &#8220;production ready&#8221; starters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Name</simpara></entry>
<entry align="left" valign="top"><simpara>Description</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring-boot-starter-actuator</simpara></entry>
<entry align="left" valign="top"><simpara>Adds production ready features such as metrics and monitoring.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring-boot-starter-shell-remote</simpara></entry>
<entry align="left" valign="top"><simpara>Adds remote <literal>ssh</literal> shell support.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Finally, Spring Boot includes some starters that can be used if you want to exclude or
swap specific technical facets.</simpara>
<table
frame="all"
rowsep="1" colsep="1"
>
<title>Spring Boot technical starters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Name</simpara></entry>
<entry align="left" valign="top"><simpara>Description</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring-boot-starter-jetty</simpara></entry>
<entry align="left" valign="top"><simpara>Imports the Jetty HTTP engine (to be used as an alternative to Tomcat)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring-boot-starter-log4j</simpara></entry>
<entry align="left" valign="top"><simpara>Support the Log4J looggin framework</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring-boot-starter-logging</simpara></entry>
<entry align="left" valign="top"><simpara>Import Spring Boot&#8217;s default logging framework (Logback).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring-boot-starter-tomcat</simpara></entry>
<entry align="left" valign="top"><simpara>Import Spring Boot&#8217;s default HTTP engine (Tomcat).</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section id="_structuring_your_code">
<title>Structuring your code</title>
<simpara>Spring Boot does not require any specific code layout to work, however, there are some
best practices that help.</simpara>
<section id="_using_the_8220_default_8221_package">
<title>Using the &#8220;default&#8221; package</title>
<simpara>When a class doesn&#8217;t include a <literal>package</literal> declaration it is considered to be in the
&#8220;default package&#8221;. The use of the &#8220;default package&#8221; is generally discouraged, and
should be avoided. It can cause particular problems for Spring Boot applications that
use <literal>@ComponentScan</literal> or <literal>@EntityScan</literal> annotations, since every class from every jar,
will be read.</simpara>
<tip><simpara>We recommend that you use the follow Java&#8217;s recommended package naming conventions
and use a reversed domain name (for example, <literal>com.example.project</literal>).</simpara></tip>
</section>
<section id="_locating_the_main_application_class">
<title>Locating the main application class</title>
<simpara>We generally recommend that you locate your main application class in a root package
above other classes. The <literal>@EnableAutoConfiguration</literal> annotation is often placed on your
main class, and it implicitly defines a base &#8220;search package&#8221; for certain items. For
example, if you are writing a JPA application, the package of the
<literal>@EnableAutoConfiguration</literal> annotated class will be used to search for <literal>@Entity</literal> items.</simpara>
<simpara>Using a root package also allows the <literal>@ComponentScan</literal> annotation to be used without
needing to specify a <literal>basePackage</literal> attribute.</simpara>
<simpara>Here is a typical layout:</simpara>
<screen>        com
         +- example
             +- myproject
                 +- Application.java
                 |
                 +- domain
                 |   +- Customer.java
                 |   +- CustomerRepository.java
                 |
                 +- service
                 |   +- CustomerService.java
                 |
                 +- web
                     +- CustomerController.java</screen>
<simpara>The <literal>Application.java</literal> file would declare the <literal>main</literal> method, along with the basic
<literal>@Configuration</literal>.</simpara>
<programlisting language="java" linenumbering="indent=0">        package com.example.myproject;

        import org.springframework.boot.SpringApplication;
        import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
        import org.springframework.context.annotation.ComponentScan;
        import org.springframework.context.annotation.Configuration;

        @Configuration
        @EnableAutoConfiguration
        @ComponentScan
        public class Application {

                public static void main(String[] args) {
                        SpringApplication.run(Application.class, args);
                }

        }</programlisting>
</section>
</section>
<section id="_configuration_classes">
<title>@Configuration classes</title>
<simpara>Spring Boot favors Java-based configuration. Although it is possible to call
<literal>SpringApplication.run()</literal> with an XML source, we generally recommend that your primary
source is a <literal>@Configuration</literal> class. Usually the class that defines the <literal>main</literal> method
is also a good candidate as the primary <literal>@Configuration</literal>.</simpara>
<tip><simpara>Many Spring configuration examples have been published that use XML configuration.
Always try to use the equivalent Java-base configuration if possible. Searching for
<literal>enable*</literal> annotations can be a good starting point.</simpara></tip>
<section id="_importing_additional_configuration_classes">
<title>Importing additional configuration classes</title>
<simpara>You don&#8217;t need to put all your <literal>@Configuration</literal> into a single class. The <literal>@Import</literal>
annotation an be used to import additional configuration classes. Alternatively, you
can use <literal>@ComponentScan</literal> to automatically pickup all Spring components, including
<literal>@Configuration</literal> classes.</simpara>
</section>
<section id="_importing_xml_configuration">
<title>Importing XML configuration</title>
<simpara>If you absolutely must use XML based configuration we recommend that you still start
with a <literal>@Configuration</literal> class. You can then use an additional <literal>@ImportResource</literal>
annotation to load XML configuration files.</simpara>
</section>
</section>
<section id="_auto_configuration">
<title>Auto-configuration</title>
<simpara>Spring Boot auto-configuration attempts to automatically configure your Spring
application based on the JAR dependencies that you have added. For example, If
<literal>HSQLDB</literal> is on your classpath, and you have not manually configured any database
connection beans, then we will auto-configure an in-memory database.</simpara>
<simpara>You need to opt-in to auto-configuration by adding the <literal>@EnableAutoConfiguration</literal>
annotation to one of your <literal>@Configuration</literal> classes.</simpara>
<tip><simpara>You should only ever add one <literal>@EnableAutoConfiguration</literal> annotation. We generally
recommend that you add it to your primary <literal>@Configuration</literal> class.</simpara></tip>
<section id="_gradually_replacing_auto_configuration">
<title>Gradually replacing auto-configuration</title>
<simpara>Auto-configuration is noninvasive,  at any point you can start to define your own
configuration to replace specific parts of the auto-configuration. For example, if
you add your own <literal>DataSource</literal> bean, the default embedded database support will back away.</simpara>
<simpara>If you need to find out what auto-configuration is currently being applied, and why,
starting your application with the <literal>--debug</literal> switch. This will log an auto-configuration
report to the console.</simpara>
</section>
<section id="_disabling_specific_auto_configuration">
<title>Disabling specific auto-configuration</title>
<simpara>If you find that specific auto-configure classes are being applied that you don&#8217;t want
you can use the exclude attribute of <literal>@EnableAutoConfiguration</literal> to disable them.</simpara>
<programlisting language="java" linenumbering="indent=0">        import org.springframework.boot.autoconfigure.*;
        import org.springframework.boot.autoconfigure.jdbc.*;
        import org.springframework.context.annotation.*;

        @Configuration
        @EnableAutoConfiguration(exclude={EmbeddedDatabaseConfiguration.class})
        public class MyConfiguration {
        }</programlisting>
</section>
</section>
<section id="_spring_beans_and_dependency_injection">
<title>Spring Beans and dependency injection</title>
<simpara>You are free to use any the standard Spring Framework techniques to defines your beans
and their injected dependencies. For simplicity, we often find that using <literal>@ComponentScan</literal>
to find your beans, in combination with <literal>@Autowired</literal> constructor injection works well.</simpara>
<simpara>If you structure your code as suggested above (locating your application class in a root
package), you can add <literal>@ComponentScan</literal> without any arguments. All of your application
components (<literal>@Component</literal>, <literal>@Service</literal>, <literal>@Repoistory</literal>, <literal>@Controller</literal> etc.) will be
automatically registered as Spring Beans.</simpara>
<simpara>Here is an example &#8216;@Service` Bean that uses constructor injection to obtain its&#8217;
required <literal>RiskAssessor</literal> bean.</simpara>
<programlisting language="java" linenumbering="indent=0">        package com.example.service;

        import org.springframework.beans.factory.annotation.Autowired;
        import org.springframework.stereotype.Service;

        @Service
        public class DatabaseAccountService implements AccountService {

                private final RiskAssessor riskAssessor;

                @Autowired
                public DatabaseAccountService(RiskAssessor riskAssessor) {
                        this.riskAssessor = riskAssessor;
                }

                // ...

        }</programlisting>
<tip><simpara>Notice how using constructor injection allows the <literal>riskAssessor</literal> field to be marked
as <literal>final</literal>, indicating that it cannot be subsequently changed.</simpara></tip>
</section>
<section id="_running_your_application">
<title>Running your application</title>
<simpara>One of the biggest advantages of packaging your application as JAR and using an embedded
HTTP server is that you can run your application as you would any other. Debugging Spring
Boot applications is also easy; you don&#8217;t need any special IDE plugins or extensions.</simpara>
<note><simpara>This section only covers JAR pased packaging, If you choose to package your
application as a WAR file you should refer to your server and IDE documentation.</simpara></note>
<section id="_running_from_an_ide">
<title>Running from an IDE</title>
<simpara>You can run a Spring Boot application from your IDE as a simple Java application, however,
first you will need to import your project. Import steps will vary depending on your IDE
and build system. Most IDEs can import Maven projects directly, for example Eclipse users
can select <literal>Import...</literal> &#8594; <literal>Existing Maven Projects</literal> from the <literal>File</literal> menu.</simpara>
<simpara>If you can&#8217;t directly import your project into your IDE, you may be able to generate IDE
meta-data using a build plugin. Maven includes plugins for
<ulink url="http://maven.apache.org/plugins/maven-eclipse-plugin/">Eclipse</ulink> and
<ulink url="http://maven.apache.org/plugins/maven-idea-plugin/">IDEA</ulink>; Gradle offers plugins
for <ulink url="http://www.gradle.org/docs/current/userguide/ide_support.html">various IDEs</ulink>.</simpara>
<tip><simpara>If you accidentally run a web application twice you will see a &#8220;Port already in
use&#8221; error. STS users can use the <literal>Relauch</literal> button rather than <literal>Run</literal> to ensure that
any existing instance is closed.</simpara></tip>
</section>
<section id="_as_a_packaged_application">
<title>As a packaged application</title>
<simpara>If you use the Spring Boot Maven or Gradle plugins to create an executable JAR you can
run your application using <literal>java -jar</literal>. For example:</simpara>
<screen>        $ java -jar target/myproject-0.0.1-SNAPSHOT.jar</screen>
<simpara>It is also possible to run a package application with remote debugging support enabled.
This allows you to attach a debugger to your packaged application:</simpara>
<screen>        $ java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n \
               -jar target/myproject-0.0.1-SNAPSHOT.jar</screen>
</section>
<section id="_using_the_maven_plugin">
<title>Using the Maven plugin</title>
<simpara>The Spring Boot Maven plugin includes a <literal>run</literal> goal which can be used to quickly compile
and run your application. Applications run in an exploded form, and you can edit
resources for instant &#8220;hot&#8221; reload.</simpara>
<screen>        $ mvn spring-boot:run</screen>
</section>
<section id="_using_the_gradle_plugin">
<title>Using the Gradle plugin</title>
<simpara>The Spring Boot Gradle plugin also includes a <literal>run</literal> goal which can be used to run
your application in an exploded form. The <literal>bootRun</literal> task is added whenever you import
the <literal>spring-boot-plugin</literal></simpara>
<screen>        $ gradle bootRun</screen>
</section>
<section id="_hot_swapping">
<title>Hot swapping</title>
<simpara>Since Spring Boot applications are just plain Java application, JVM hot-swapping should
work out of the box. JVM hot swapping is somewhat limited with bytecode that it can
replace, for a more complete solution the
<ulink url="https://github.com/spring-projects/spring-loaded">Spring Loaded</ulink> project, or
<ulink url="http://zeroturnaround.com/software/jrebel/">JRebel</ulink> can be used.</simpara>
<simpara>See the Hot swapping &#8220;How-to&#8221; section for details.</simpara>
</section>
</section>
<section id="_packaging_your_application_for_production">
<title>Packaging your application for production</title>
<simpara>Executable JARs can be used for production deployment. As they are self contained, they
are also ideally suited for cloud-based deployment.</simpara>
<simpara>For additional &#8220;production ready&#8221; features, such as health, auditing and metric REST
or JMX end-points; consider adding <literal>spring-boot-actuator</literal>. Actuator</simpara>
<sidebar>
<title>Definition of Actuator</title>
<simpara>An actuator is a manufacturing term, referring to a mechanical device for moving or
controlling something. Actuators can generate a large amount of motion from a small
change.</simpara>
</sidebar>
<simpara>To add actuator features to Maven based project, add the following &#8220;starter&#8221;
dependency:</simpara>
<programlisting language="xml" linenumbering="indent=0">        &lt;dependencies&gt;
                &lt;dependency&gt;
                        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
                &lt;/dependency&gt;
        &lt;/dependencies&gt;</programlisting>
<simpara>For Gradle, use the declaration:</simpara>
<programlisting language="groovy" linenumbering="indent=0">        dependencies {
                compile("org.springframework.boot:spring-boot-starter-actuator")
        }</programlisting>
<simpara>More information on Actuator features can be found in XXX below.</simpara>
</section>
<section id="_what_to_read_next_2">
<title>What to read next</title>
</section>
</section>
<section id="_springapplication">
<title>SpringApplication</title>
<simpara>The <literal>SpringApplication</literal> class provides a convenient way to bootstrap a Spring application
that will be started from a <literal>main()</literal> method. In many situations you can just delegate to
the static <literal>SpringApplication.run</literal> method:</simpara>
<programlisting language="java" linenumbering="indent=0">        public static void main(String[] args) {
                SpringApplication.run(MySpringConfiguration.class, args);
        }</programlisting>
<simpara>When you application starts you should see something similar to the following:</simpara>
<screen>  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::   v1.0.0.BUILD-SNAPSHOT

2013-07-31 00:08:16.117  INFO 56603 --- [           main] o.s.b.s.app.SampleApplication            : Starting SampleApplication v0.1.0 on mycomputer with PID 56603 (/apps/myapp.jar started by pwebb)
2013-07-31 00:08:16.166  INFO 56603 --- [           main] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@6e5a8246: startup date [Wed Jul 31 00:08:16 PDT 2013]; root of context hierarchy
2014-03-04 13:09:54.912  INFO 41370 --- [           main] .t.TomcatEmbeddedServletContainerFactory : Server initialized with port: 8080
2014-03-04 13:09:56.501  INFO 41370 --- [           main] o.s.b.s.app.SampleApplication            : Started SampleApplication in 2.992 seconds (JVM running for 3.658)</screen>
<simpara>By default <literal>INFO</literal> logging messages will shown, including some relevant startup details
such as the user that launched the application.</simpara>
<section id="_customizing_springapplication">
<title>Customizing SpringApplication</title>
<simpara>If the <literal>SpringApplication</literal> defaults aren&#8217;t to your taste you can instead create a local
instance and customize it. For example, to turn off the banner you would write:</simpara>
<programlisting language="java" linenumbering="indent=0">        public static void main(String[] args) {
                SpringApplication app = new SpringApplication(MySpringConfiguration.class);
                app.setShowBanner(false);
                app.run(args);
        }</programlisting>
<note><simpara>The constructor arguments passed to <literal>SpringApplication</literal> are configuration sources
for spring beans. In most cases these will be references to <literal>@Configuration</literal> classes, but
they could also be references to XML configuration or to packages that should be scanned.</simpara></note>
<simpara>It is also possible to configure the <literal>SpringApplication</literal> using an <literal>application.properties</literal>
file. See XXX.</simpara>
<simpara>For a complete list of the configuration options, see the <literal>SpringApplication</literal> Javadoc.</simpara>
</section>
<section id="_fleunt_builder_api">
<title>Fleunt builder API</title>
<simpara>If you need to build an <literal>ApplicationContext</literal> hierarchy (multiple contexts with a
parent/child relationship), or if you just prefer using a &#8220;fluent&#8221; builder API, you
can use the <literal>SpringApplicationBuilder</literal>.</simpara>
<simpara>The <literal>SpringApplicationBuilder</literal> allows you to chain together multiple method calls, and
includes <literal>parent</literal> and <literal>child</literal> methods that allow you to create a hierarchy.</simpara>
<simpara>For example:</simpara>
<programlisting language="java" linenumbering="indent=0">        new SpringApplicationBuilder()
                .showBanner(false)
                .sources(Parent.class)
                .child(Application.class)
                .run(args);</programlisting>
<note><simpara>There are some restrictions when creating an <literal>ApplicationContext</literal> hierarchy, e.g.
the parent application context is <emphasis role="strong">not</emphasis> a <literal>WebApplicationContext</literal>.  Both parent and child
are executed with the same <literal>Environment</literal> constructed in the usual way to include command
line arguments.  Any <literal>ServletContextAware</literal> components all have to go in the child
context, otherwise there is no way for Spring Boot to create the <literal>ServletContext</literal> in time.</simpara></note>
</section>
<section id="_application_events_and_listeners">
<title>Application events and listeners</title>
<simpara>In addition to the usual Spring Framework events, such as <literal>ContextRefreshedEvent</literal>, a
<literal>SpringApplication</literal> sends some additional application events. Some events are actually
triggered before the <literal>ApplicationContext</literal> is created.</simpara>
<simpara>You can register event listeners in a number of ways, the most common being
<literal>SpringApplication.addListeners(...)</literal> method (See XXX).</simpara>
<simpara>Application events are sent in the following order, as your application runs:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
An <literal>ApplicationStartedEvent</literal> is sent at the start of a run, but before any
  processing except the registration of listeners and initializers.
</simpara>
</listitem>
<listitem>
<simpara>
An <literal>ApplicationEnvironmentPreparedEvent</literal> is sent when the <literal>Environment</literal> to be used in
  the context is known, but before the context is created.
</simpara>
</listitem>
<listitem>
<simpara>
An <literal>ApplicationPreparedEvent</literal> is sent just before the refresh is started, but after bean
  definitions have been loaded.
</simpara>
</listitem>
<listitem>
<simpara>
An <literal>ApplicationFailedEvent</literal> is sent if there is an exception on startup.
</simpara>
</listitem>
</orderedlist>
<tip><simpara>You often won&#8217;t need to use application events, but it can be handy to know that they
exist. Internally, Spring Boot uses events to handle a variety of tasks.</simpara></tip>
</section>
<section id="_web_environment">
<title>Web environment</title>
<simpara>A <literal>SpringApplication</literal> will attempt to create the right type of <literal>ApplicationContext</literal> on
your behalf. By default, an <literal>AnnotationConfigApplicationContext</literal> or
<literal>AnnotationConfigEmbeddedWebApplicationContext</literal> will be used, depending on whether you
are developing a web application or not.</simpara>
<simpara>The algorithm used to determine a &#8220;web environment&#8221; is fairly simplistic (based on the
presence of a few classes). You can use <literal>setWebEnvironment(boolean webEnvironment)</literal> if
you need to override the default.</simpara>
<simpara>It is also possible to take complete control of the <literal>ApplicationContext</literal> type that will
be used by using <literal>setApplicationContextClass(...)</literal>.</simpara>
<tip><simpara>It is often desirable call <literal>setWebEnvironment(false)</literal> when using <literal>SpringApplication</literal>
within a JUnit test.</simpara></tip>
</section>
<section id="_using_the_commandlinerunner">
<title>Using the CommandLineRunner</title>
<simpara>If you want access to the raw command line argument, or you need to run some specific code
once the <literal>SpringApplication</literal> has started you can implement the <literal>CommandLineRunner</literal>
interface. The <literal>run(String... args)</literal> method will be called on all spring beans
implementing this interface.</simpara>
<programlisting language="java" linenumbering="indent=0">        import org.springframework.boot.*
        import org.springframework.stereotype.*

        @Component
        public class MyBean implements CommandLineRunner {

            public void run(String... args) {
                // Do something...
            }

        }</programlisting>
<simpara>You can additionally implement the <literal>org.springframework.core.Ordered</literal> interface or use the
<literal>org.springframework.core.annotation.Order</literal> annotation if several <literal>CommandLineRunner</literal>
beans are defined that must be called in a specific order.</simpara>
</section>
<section id="_application_exit">
<title>Application exit</title>
<simpara>Each <literal>SpringApplication</literal> will register a shutdown hook with the JVM to ensure that the
<literal>ApplicationContext</literal> is closed gracefully on exit. All the standard Spring lifecycle
callbacks (such as the <literal>DisposableBean</literal> interface, or the <literal>@PreDestroy</literal> annotation) can
be used.</simpara>
<simpara>In addition, beans may implement the <literal>org.springframework.boot.ExitCodeGenerator</literal>
interface if they wish to return a specific exit code when the application ends.</simpara>
</section>
</section>
<section id="_externalized_configuration">
<title>Externalized Configuration</title>
<simpara>Spring Boot likes you to externalize your configuration so you can work with the same
application code in different environments. You can use properties files, YAML files,
environment variables and command-line arguments to externalize configuration. Property
values can be injected directly into your beans using the <literal>@Value</literal> annotation, accessed
via Spring&#8217;s <literal>Environment</literal> abstraction or bound to structured objects.</simpara>
<simpara>Spring Boot uses a very particular <literal>PropertySource</literal> order that is designed to allow
sensible overriding of values, properties are considered in the the following order:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Command line argument
</simpara>
</listitem>
<listitem>
<simpara>
Java System properties (<literal>System.getProperties()</literal>).
</simpara>
</listitem>
<listitem>
<simpara>
OS environment variables.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>@PropertySource</literal> annotations on your <literal>@Configuration</literal> classes.
</simpara>
</listitem>
<listitem>
<simpara>
Application properties outside of your packaged JAR (<literal>application.properties</literal>
  including YAML and profile variants)
</simpara>
</listitem>
<listitem>
<simpara>
Application properties packaged inside your JAR (<literal>application.properties</literal>
  including YAML and profile variants)
</simpara>
</listitem>
<listitem>
<simpara>
Default properties (specified using <literal>SpringApplication.setDefaultProperties</literal>)
</simpara>
</listitem>
</orderedlist>
<simpara>To provide a concrete example, suppose you develop a <literal>@Component</literal> that uses a
<literal>name</literal> property:</simpara>
<programlisting language="java" linenumbering="indent=0">        import org.springframework.stereotype.*
        import org.springframework.beans.factory.annotation.*

        @Component
        public class MyBean {

            @Value("${name}")
            private String name;

            // ...

        }</programlisting>
<simpara>You can bundle an <literal>application.properties</literal> inside your jar that provides a sensible
default <literal>name</literal>. When running in production, an <literal>application.properties</literal> can be provided
outside of your JAR that overrides <literal>name</literal>; and for one off testing you can launch with
a specific command line switch (e.g. <literal>java -jar app.jar --name="Spring"</literal>).</simpara>
<section id="_accessing_command_line_properties">
<title>Accessing command line properties</title>
<simpara>By default SpringApplication will convert any command line option arguments (starting
with &#8220;--&#8221;, e.g. <literal>--server.port=9000</literal>) to a <literal>PropertySource</literal> and add it to the Spring
<literal>Environment</literal>. As mentioned above, command line properties always take precedence over
other property sources.</simpara>
<simpara>If you don&#8217;t want command line properties to be added to the <literal>Environment</literal> you can disable
them using <literal>SpringApplication.setAddCommandLineProperties(false)</literal>.</simpara>
</section>
<section id="_application_property_files">
<title>Application property files</title>
<simpara><literal>SpringApplication</literal> will load properties from <literal>application.properties</literal> files in the
following locations and add them to the Spring <literal>Environment</literal>:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
The current directory
</simpara>
</listitem>
<listitem>
<simpara>
A <literal>/config</literal> subdir of the current directory.
</simpara>
</listitem>
<listitem>
<simpara>
The classpath root
</simpara>
</listitem>
<listitem>
<simpara>
A classpath <literal>/config</literal> package
</simpara>
</listitem>
</orderedlist>
<simpara>The list is ordered by precedence (locations higher in the list override lower items).</simpara>
<note><simpara>You can also use YAML (<emphasis>.yml</emphasis>) files as an alternative to <emphasis>.properties</emphasis> (see below)</simpara></note>
<simpara>If you don&#8217;t like <literal>application.properties</literal> as the configuration file name you can switch
to another by specifying <literal>spring.config.name</literal> environment property. You can also refer
to an explicit location using the <literal>spring.config.location</literal> environment property.</simpara>
<screen>        $ java -jar myproject.jar --spring.config.name=myproject</screen>
<section id="_profile_specific_properties">
<title>Profile specific properties</title>
<simpara>In addition to <literal>application.properties</literal> files, profile specific properties can also be
defined using the naming convention <literal>application-{profile}.properties</literal>.</simpara>
<simpara>Profile specific properties are loaded from the same locations as standard
<literal>application.properties</literal>, with profiles specific files overriding the default ones.</simpara>
</section>
<section id="_placeholders_in_properties">
<title>Placeholders in properties</title>
<simpara>The values in <literal>application.properties</literal> are filtered through the existing <literal>Environment</literal>
when they are used so you can refer back to previously defined values (e.g. from System
properties).</simpara>
<screen>        app.name: MyApp
        app.description: ${app.name} is a Spring Boot application</screen>
<tip><simpara>You can also use this technique to create <literal>short</literal> variants of existing Spring Boot
properties. See XXX</simpara></tip>
</section>
</section>
<section id="_using_yaml_instead_of_properties">
<title>Using YAML instead of Properties</title>
<simpara><ulink url="http://yaml.org">YAML</ulink> is a superset of JSON, and as such is a very convenient format
for specifying hierarchical configuration data. The <literal>SpringApplication</literal> class will
automatically support YAML as an alternative to properties whenever you have the
<ulink url="http://code.google.com/p/snakeyaml/">SnakeYAML</ulink> library on your classpath.</simpara>
<note><simpara>If you use &#8220;starter POMs&#8221; SnakeYAML will be automatically provided via
<literal>spring-boot-starter</literal>.</simpara></note>
<section id="_loading_yaml">
<title>Loading YAML</title>
<simpara>Spring Boot provides two convenient classes that can be used to load YAML documents. The
<literal>YamlPropertiesFactoryBean</literal> will load YAML as <literal>Properties</literal> and the <literal>YamlMapFactoryBean</literal>
will load YAML as a <literal>Map</literal>.</simpara>
<simpara>For example, the following YAML document:</simpara>
<programlisting language="yaml" linenumbering="indent=0">        dev:
                url: http://dev.bar.com
                name: Developer Setup
        prod:
                url: http://foo.bar.com
                name: My Cool App</programlisting>
<simpara>Would be transformed into these properties:</simpara>
<screen>        environments.dev.url=http://dev.bar.com
        environments.dev.name=Developer Setup
        environments.prod.url=http://foo.bar.com
        environments.prod.name=My Cool App</screen>
<simpara>YAML lists are represented as comma-separated values (useful for simple String values)
and also as property keys with <literal>[index]</literal> dereferencers, for example this YAML:</simpara>
<programlisting language="yaml" linenumbering="indent=0">         servers:
                - dev.bar.com
                - foo.bar.com</programlisting>
<simpara>Would be transformed into these properties:</simpara>
<screen>        servers=dev.bar.com,foo.bar.com
        servers[0]=dev.bar.com
        servers[1]=foo.bar.com</screen>
</section>
<section id="_exposing_yaml_as_properties_in_the_spring_environment">
<title>Exposing YAML as properties in the Spring Environment.</title>
<simpara>The <literal>YamlPropertySourceLoader</literal> class can be used to expose YAML as a <literal>PropertySource</literal>
in the Spring <literal>Environment</literal>. This allows you to the familiar <literal>@Value</literal> with placeholders
syntax to access YAML properties.</simpara>
</section>
<section id="_multi_profile_yaml_documents">
<title>Multi-profile YAML documents</title>
<simpara>You can specify multiple profile-specific YAML document in a single file by
by using a <literal>spring.profiles</literal> key to indicate when the document applies. For example:</simpara>
<programlisting language="yaml" linenumbering="indent=0">        server:
                address: 192.168.1.100
        ---
        spring:
                profiles: production
        server:
                address: 192.168.1.120</programlisting>
</section>
<section id="_yaml_shortcomings">
<title>YAML shortcomings</title>
<simpara>YAML files can&#8217;t be loaded via the <literal>@PropertySource</literal> annotation. So in the
case that you need to load values that way, you need to use a properties file.</simpara>
</section>
</section>
<section id="_typesafe_configuration_properties">
<title>Typesafe Configuration Properties</title>
<simpara>Using the <literal>@Value("${property}")</literal> annotation to inject configuration properties can
sometimes be cumbersome, especially if you are working with multiple properties or
your data is hierarchical in nature. Spring Boot provides an alternative method
of working with properties that allows strongly typed beans to govern and validate
the configuration of your application. For example:</simpara>
<programlisting language="java" linenumbering="indent=0">        @Component
        @ConfigurationProperties(name="connection")
        public class ConnectionSettings {

                private String username;

                private InetAddress remoteAddress;

                // ... getters and setters

        }</programlisting>
<simpara>When the <literal>@EnableConfigurationProperties</literal> annotation is applied to your <literal>@Configuration</literal>,
any beans annotated with <literal>@ConfigurationProperties</literal> will automatically be configured
from the <literal>Environment</literal> properties. This style of configuration works particularly well
with the <literal>SpringApplication</literal> external YAML configuration:</simpara>
<programlisting language="yaml" linenumbering="indent=0">        # application.yml

        connection:
                username: admin
                remoteAddress: 192.168.1.1

        # additional configuration as required</programlisting>
<simpara>To work with <literal>@ConfigurationProperties</literal> beans you can just inject them in the same way
as any other bean.</simpara>
<programlisting language="java" linenumbering="indent=0">        @Service
        public class MyService {

                @Autowired
                private ConnectionSettings connection;

                //...

                @PostConstruct
                public void openConnection() {
                        Server server = new Server();
                        this.connection.configure(server);
                }

        }</programlisting>
<simpara>It is also possible to shortcut the registration of <literal>@ConfigurationProperties</literal> bean
definitions by simply listing the properties classes directly in the
<literal>@EnableConfigurationProperties</literal> annotation:</simpara>
<programlisting language="java" linenumbering="indent=0">        @Configuration
        @EnableConfigurationProperties(ConnectionSettings.class)
        public class MyConfiguration {
        }</programlisting>
<section id="_relaxed_binding">
<title>Relaxed binding</title>
<simpara>Spring Boot uses some relaxed rules for binding <literal>Environment</literal> properties to
<literal>@ConfigurationProperties</literal> beans, so there doesn&#8217;t need to be an exact match between
the <literal>Environment</literal> property name and the bean property name.  Common examples where this
is useful include underscore separated (e.g. <literal>context_path</literal> binds to <literal>contextPath</literal>), and
capitalized (e.g. <literal>PORT</literal> binds to <literal>port</literal>) environment properties.</simpara>
<simpara>Spring will attempt to coerce the external application properties to the right type when
it binds to the <literal>@ConfigurationProperties</literal> beans. If you need custom type conversion you
can provide a <literal>ConversionService</literal> bean (with bean id <literal>conversionService</literal>) or custom
property editors (via a <literal>CustomEditorConfigurer</literal> bean).</simpara>
</section>
<section id="_configurationproperties_validation">
<title>@ConfigurationProperties Validation</title>
<simpara>Spring Boot will attempt to validate external configuration, by default using JSR-303
(if it is on the classpath). You can simply add JSR-303 <literal>javax.valididation</literal> constraint
annotations to your <literal>@ConfigurationProperties</literal> class:</simpara>
<programlisting language="java" linenumbering="indent=0">        @Component
        @ConfigurationProperties(name="connection")
        public class ConnectionSettings {

                @NotNull
                private InetAddress remoteAddress;

                // ... getters and setters

        }</programlisting>
<simpara>You can also add a custom Spring <literal>Validator</literal> by creating a bean definition called
<literal>configurationPropertiesValidator</literal>.</simpara>
<tip><simpara>The <literal>spring-boot-actuator</literal> includes an end-point that exposes all
<literal>@ConfigurationProperties</literal> beans. Simply point your web browser to <literal>/configprops</literal>.</simpara></tip>
</section>
</section>
</section>
<section id="_profiles">
<title>Profiles</title>
<simpara>Spring Profiles are a way to segregate parts of the application configuration and make it
only available in certain environments.  Any <literal>@Component</literal> or <literal>@Configuration</literal> can be
marked with <literal>@Profile</literal> to limit when it is loaded:</simpara>
<programlisting language="java" linenumbering="indent=0">        @Configuration
        @Profile("production")
        public class ProductionConfiguraiton {

                // ...

        }</programlisting>
<simpara>Spring Boot takes this a stage further, in that you can use a <literal>spring.profiles.active</literal>
<literal>Environment</literal> property to specify which profiles are active. You can specify the property
in any of the usual ways, for example you could include it in your
<literal>application.properties</literal>:</simpara>
<screen>        spring.profiles.active=dev,hsqldb</screen>
<simpara>or specify on the command line using the switch <literal>--spring.profiles.active=dev,hsqldb</literal>.</simpara>
<section id="_adding_active_profiles">
<title>Adding active profiles</title>
<simpara>The <literal>spring.profiles.active</literal> property follows the same ordering rules as other
properties, the highest <literal>PropertySource</literal> will win. This means that you can specify
active profiles in <literal>application.properties</literal> then <emphasis role="strong">replace</emphasis> them using the command line
switch.</simpara>
<simpara>Sometimes it is useful to have profile specific properties that <emphasis role="strong">add</emphasis> to the active
profiles rather than replace them. The <literal>+</literal> prefix can be used to add active profiles.</simpara>
<simpara>For example, when an application with following properties is run using the switch
<literal>--spring.profiles.active=prod</literal> the <literal>proddb</literal> and <literal>prodmq</literal> profiles will also be activated:</simpara>
<simpara>```yaml
---
my.property: fromyamlfile
---
spring.profiles: prod
spring.profiles.active: +proddb,+prodmq
```
=== Programmatically setting profiles
You can programmatically set active profiles by calling
<literal>SpringApplication.setAdditionalProfiles(...)</literal> before your application runs. It is also
possible to activate profiles using Spring&#8217;s <literal>ConfigurableEnvironment</literal> interface.</simpara>
</section>
<section id="_profile_specific_configuration_files">
<title>Profile specific configuration files</title>
<simpara>Profile specific variants of both <literal>application.properties</literal> (or <literal>application.yml</literal>) and
files referenced via <literal>@ConfigurationProperties</literal> are considered as files are loaded.
See XXX and XXX for details.</simpara>
</section>
</section>
<section id="_logging">
<title>Logging</title>
<simpara>Spring Boot uses <ulink url="http://commons.apache.org/logging">Commons Logging</ulink> for all internal
logging, but leaves the underlying log implementation open. Default configurations are
provided for
<ulink url="http://docs.oracle.com/javase/7/docs/api/java/util/logging/package-summary.html">Java Util Logging</ulink>,
<ulink url="http://logging.apache.org/log4j/">Log4J</ulink> and
<ulink url="http://logback.qos.ch/">Logback</ulink>.
In each case there is console output and file output (rotating, 10 Mb file size).</simpara>
<simpara>By default, If you use the &#8220;Starter POMs&#8221;, Logback will be used for logging. Appropriate
Logback routing is also included to ensure that dependent libraries that use
Java Util Logging, Commons Logging, Log4J or SLF4J will all work correctly.</simpara>
<tip><simpara>There are a lot of logging frameworks available for Java. Don&#8217;t worry if the above
list seems confusing, generally you won&#8217;t need to change your logging dependencues and
the Spring Boot defaults will work just fine.</simpara></tip>
<section id="_log_format">
<title>Log format</title>
<simpara>The default log output from Spring Boot looks like this:</simpara>
<screen>2014-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52
2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms
2014-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: 'dispatcherServlet' to [/]
2014-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]</screen>
<simpara>The following items are output:</simpara>
<itemizedlist>
<listitem>
<simpara>
Date and Time&#8201;&#8212;&#8201;Millesecond precision and easily sortable
</simpara>
</listitem>
<listitem>
<simpara>
Log Level&#8201;&#8212;&#8201;<literal>ERROR</literal>, <literal>WARN</literal>, <literal>INFO</literal>, <literal>DEBUG</literal> or <literal>TRACE</literal>
</simpara>
</listitem>
<listitem>
<simpara>
Process ID
</simpara>
</listitem>
<listitem>
<simpara>
A <literal>---</literal> separator to distinguish the start of actual log messages
</simpara>
</listitem>
<listitem>
<simpara>
Logger name&#8201;&#8212;&#8201;This is usually the source class name (often abbreviated)
</simpara>
</listitem>
<listitem>
<simpara>
The log message
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_console_output">
<title>Console output</title>
<simpara>The default log configuration will echo messages to the console as they written. By
default <literal>ERROR</literal>, <literal>WARN</literal> and <literal>INFO</literal> level messages are logged. To also log <literal>DEBUG</literal> level
messages to the console you can start your application with a <literal>--debug</literal> flag.</simpara>
<screen>        $ java -jar myapp.jar --debug</screen>
<simpara>If your terminal supports ANSI, color output will be used to aid readability.</simpara>
</section>
<section id="_file_output">
<title>File output</title>
<simpara>By default, log files are written to <literal>/tmp/spring.log</literal> and rotate at 10 Mb. You can easily
customize the output folder by setting the <literal>logging.path</literal> property (for example in your
<literal>application.properties</literal>). It is also possible to change the filename using a
<literal>logging.file</literal> property.</simpara>
<simpara>As with console output, <literal>ERROR</literal>, <literal>WARN</literal> and <literal>INFO</literal> level messages are logged by default.</simpara>
</section>
<section id="_custom_log_configuration">
<title>Custom log configuration</title>
<simpara>The various logging systems can be activated by including the appropriate libraries on
the classpath, and further customized by supported by providing a suitable configuration
file in the root of the classpath, or in a location specified by the Spring <literal>Environment</literal>
property <literal>logging.config</literal>.</simpara>
<simpara>Depending on your logging system, the following files will be loaded:</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Logging System</simpara></entry>
<entry align="left" valign="top"><simpara>Customization</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Logback</simpara></entry>
<entry align="left" valign="top"><simpara><literal>logback.xml</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Log4j</simpara></entry>
<entry align="left" valign="top"><simpara><literal>log4j.properties</literal> or <literal>log4j.xml</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>JDK (Java Util Logging)</simpara></entry>
<entry align="left" valign="top"><simpara><literal>logging.properties</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>To help with the customization some other properties are transferred from the Spring
<literal>Environment</literal> to System properties:</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Spring Environment</simpara></entry>
<entry align="left" valign="top"><simpara>System Property</simpara></entry>
<entry align="left" valign="top"><simpara>Comments</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>logging.file</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>LOG_FILE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Used in default log configuration if defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>logging.path</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>LOG_PATH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Used in default log configuration if defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PID</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PID</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The current process ID is discovered if possible and not already provided</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>All the logging systems supported can consult System properties when parsing their
configuration files.  See the default configurations in <literal>spring-boot.jar</literal> for examples.</simpara>
<warning><simpara>There are know classloading issues with Java Util Logging that cause problems
when running from an &#8220;executable JAR&#8221;. We recommend that you avoid it if at all
possible.</simpara></warning>
</section>
</section>
<section id="_web_applications">
<title>Web applications</title>
<simpara>Spring Boot is well suited for web application development. You can easily create a
self-contained HTTP server using embedded Tomcat or Jetty. Most web applications will
use the <literal>spring-boot-starter-web</literal> module to get up and running quickly.</simpara>
<simpara>If you haven&#8217;t yet developed a Spring Boot web application you can follow the
"Hello World!" example in XXX</simpara>
<section id="_the_8220_spring_web_mvc_framework_8221">
<title>The &#8220;Spring Web MVC framework&#8221;</title>
<simpara>The Spring Web MVC framework (often referred to as simply &#8220;Spring MVC&#8221;) is a rich
&#8220;model view controller&#8221; web framework. Spring MVC lets you create special <literal>@Controller</literal>
or <literal>@RestController</literal> beans to handle incoming HTTP requests. Methods in your controller
are mapped to HTTP using <literal>@RequestMapping</literal> annotations.</simpara>
<simpara>Here is a typical example <literal>@RestController</literal> to serve JSON data:</simpara>
<programlisting language="java" linenumbering="indent=0">        @RestController
        @RequestMapping(value="/users")
        public class MyRestController {

                @RequestMapping(value="/{user}", method=RequestMethod.GET)
                public User getUser(@PathVariable Long user) {
                        // ...
                }

                @RequestMapping(value="/{user}/customers", method=RequestMethod.GET)
                List&lt;Customer&gt; getUserCustomers(@PathVariable Long user) {
                        // ...
                }

                @RequestMapping(value="/{user}", method=RequestMethod.DELETE)
                public User deleteUser(@PathVariable Long user) {
                        // ...
                }

        }</programlisting>
<simpara>Spring MVC is part of the core Spring Framework and detailed information is available in
the reference documentation. There are also several guides available at
<ulink url="http://spring.io/guides">http://spring.io/guides</ulink> that cover Spring MVC.</simpara>
<section id="_spring_mvc_auto_configuration">
<title>Spring MVC auto-configuration</title>
<simpara>Spring Boot provides auto-configuration for Spring MVC that works well with most
applications. If you want to take complete control of Spring MVC you can add your
own <literal>@Configuration</literal> annotated with <literal>@EnableWebMvc</literal>.</simpara>
<simpara>The auto-configuration adds the following features on top of Spring&#8217;s defaults:</simpara>
<itemizedlist>
<listitem>
<simpara>
Inclusion of <literal>ContentNegotiatingViewResolver</literal> and <literal>BeanNameViewResolver</literal> beans.
</simpara>
</listitem>
<listitem>
<simpara>
Support for serving static resources, including support for WebJars (see below).
</simpara>
</listitem>
<listitem>
<simpara>
Automatic registration of <literal>Converter</literal>, <literal>GenericConverter</literal>, <literal>Formatter</literal> beans.
</simpara>
</listitem>
<listitem>
<simpara>
Support for <literal>HttpMessageConverters</literal> (see below).
</simpara>
</listitem>
<listitem>
<simpara>
Static <literal>index.html</literal> support.
</simpara>
</listitem>
<listitem>
<simpara>
Custom <literal>Favicon</literal> support.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_httpmessageconverters">
<title>HttpMessageConverters</title>
<simpara>Spring MVC uses the <literal>HttpMessageConverter</literal> interface to convert HTTP requests and
responses. Sensible defaults are included out of the box, for example Objects can be
automatically converted to JSON (using the Jackson library) or XML (using JAXB).</simpara>
<simpara>If you need to add or customize converters you can use Spring Boot&#8217;s
<literal>HttpMessageConverters</literal> class:</simpara>
<programlisting language="java" linenumbering="indent=0">        import org.springframework.boot.autoconfigure.web.HttpMessageConverters;
        import org.springframework.context.annotation.*;
        import org.springframework.http.converter.*;

        @Configuration
        public class MyConfiguration {

                @Bean
                public HttpMessageConverters customConverters() {
                        HttpMessageConverter&lt;?&gt; additional = ...
                        HttpMessageConverter&lt;?&gt; another = ...
                        return new HttpMessageConverters(additional, another);
                }

        }</programlisting>
</section>
<section id="_static_content">
<title>Static Content</title>
<simpara>By default Spring Boot will serve static content from a folder called <literal>/static</literal> (or
<literal>/public</literal> or or <literal>/resources</literal> or <literal>/META-INF/resources</literal>) in the classpath or from the root
of the <literal>ServeltContext</literal>.  It uses the <literal>ResourceHttpRequestHandler</literal> from Spring MVC so you
can modify that behavior by adding your own <literal>WebMvcConfigurerAdapter</literal> and overriding the
<literal>addResourceHandlers</literal> method.</simpara>
<simpara>In a stand-alone web application the default servlet from the container is also
enabled, and acts as a fallback, serving content from the root of the <literal>ServletContext</literal> if
Spring decides not to handle it. Most of the time this will not happen unless you modify
the deafult MVC configuration because Spring will always be able to handle requests
through the <literal>DispatcherServlet</literal>.</simpara>
<simpara>In addition to the &#8220;standard&#8221; static resource locations above, a special case is made for
<ulink url="http://www.webjars.org/">Webjars content</ulink>. Any resources with a path in <literal>/webjars/**</literal> will
be served from jar files if they are packaged in the Webjars format.</simpara>
<tip><simpara>Do not use the <literal>src/main/webapp</literal> folder if your application will be packaged as a
JAR. Although this folder is a common standard, it will <emphasis role="strong">only</emphasis> work with WAR packaging
and it will be silently ignored by most build tools if you generate a JAR.</simpara></tip>
</section>
<section id="_template_engines">
<title>Template engines</title>
<simpara>As well as REST web service, you can also use Spring MVC to service dynamic HTML content.
Spring MVC supports a variety of templating technologies including: velocity, freemarker,
and JSPs. Many other templating engines also ship their own Spring MVC integrations.</simpara>
<simpara>Spring Boot includes auto-configuration support for the Thymeleaf templating engine.
Thymeleaf is an XML/XHTML/HTML5 template engine that can work both in web and non-web
environments. If allows you to create natural templates, that can be correctly displayed
by browsers and therefore work also as static prototypes. Thymeleaf templates will be
picked up automatically from <literal>src/main/resources/templates</literal>.</simpara>
<tip><simpara>JSPs should be avoided if possible, there are several known limitations when using
them with embdedded servlet containers.</simpara></tip>
</section>
</section>
<section id="_embedded_servlet_container_support">
<title>Embedded servlet container support</title>
<simpara>Spring Boot includes support for embedded Tomcat and Jetty servers. Most developers will
simply use the appropriate &#8220;Starter POM&#8221; to obtain a fully configured instance. By
default both Tomcat and Jetty will listen for HTTP requests on port <literal>8080</literal>.</simpara>
<section id="_servlets_and_filters">
<title>Servlets and Filters</title>
<simpara>When using an embedded servlet container you can register Servlets and Filters directly as
Spring beans. This can be particularly convenient if you want to refer to a value from
your <literal>application.properties</literal> during configuration.</simpara>
<simpara>By default, if the context contains only a single Servlet it will be mapped to <literal>/</literal>. In
the case of multiple Servlets beans the bean name will be used as a path prefix. Filters
will map to <literal>/*</literal>.</simpara>
<simpara>If convention based mapping is not flexible enough you can use the
<literal>ServletRegistrationBean</literal> and <literal>FilterRegistrationBean</literal> classes for complete control. You
can also register items directly if your bean implements the <literal>ServletContextInitializer</literal>
interface.</simpara>
</section>
<section id="_the_embeddedwebapplicationcontext">
<title>The EmbeddedWebApplicationContext</title>
<simpara>Under the hood Spring Boot uses a new type of <literal>ApplicationContext</literal> for embedded
servlet container support.  The <literal>EmbeddedWebApplicationContext</literal> is a special
type of <literal>WebApplicationContext</literal> that bootstraps itself by searching for a single
<literal>EmbeddedServletContainerFactory</literal> bean. Usually a <literal>TomcatEmbeddedServletContainerFactory</literal>
or <literal>JettyEmbeddedServletContainerFactory</literal> will have been auto-configured.</simpara>
<note><simpara>You usually won&#8217;t need to be aware of these implementation classes. Most
applications will be auto-configured and the appropriate <literal>ApplicationContext</literal> and
<literal>EmbeddedServletContainerFactory</literal> will be created on your behalf.</simpara></note>
</section>
<section id="_customizing_embedded_servlet_containers">
<title>Customizing embedded servlet containers</title>
<simpara>Common servlet container settings can be configured using Spring <literal>Environment</literal>
properties. Usually you would define the properties in your <literal>application.properties</literal>
file.</simpara>
<simpara>Common server settings include:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>server.port</literal>&#8201;&#8212;&#8201;The listen port for incoming HTTP requests.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>server.address</literal>&#8201;&#8212;&#8201;The interface address to bind to/
</simpara>
</listitem>
<listitem>
<simpara>
<literal>server.sessionTimeout</literal>&#8201;&#8212;&#8201;A session timeout
</simpara>
</listitem>
</itemizedlist>
<simpara>See the <literal>ServerProperties</literal> class for a complete list.</simpara>
<section id="_programmatic_customization">
<title>Programmatic customization</title>
<simpara>If you need to configure your embdedded servlet container programmatically you can register
a Spring bean that implements the <literal>EmbeddedServletContainerCustomizer</literal> interface.
<literal>EmbeddedServletContainerCustomizer</literal> provides access to the
<literal>ConfigurableEmbeddedServletContainerFactory</literal> which includes numerous customization
setter methods.</simpara>
<programlisting language="java" linenumbering="indent=0">        import org.springframework.boot.context.embedded.*;
        import org.springframework.stereotype.Component;

        @Component
        public class CustomizationBean implements EmbeddedServletContainerCustomizer {

                @Override
                public void customize(ConfigurableEmbeddedServletContainer container) {
                        container.setPort(9000);
                }

        }</programlisting>
</section>
<section id="_customizing_configurableembeddedservletcontainerfactory_directly">
<title>Customizing ConfigurableEmbeddedServletContainerFactory directly</title>
<simpara>If the above customization techniques are too limited, you can register the
<literal>TomcatEmbeddedServletContainerFactory</literal> or <literal>JettyEmbeddedServletContainerFactory</literal> bean
yourself.</simpara>
<programlisting language="java" linenumbering="indent=0">        @Bean
        public EmbeddedServletContainerFactory servletContainer() {
                TomcatEmbeddedServletContainerFactory factory = new TomcatEmbeddedServletContainerFactory();
                factory.setPort(9000);
                factory.setSessionTimeout(10, TimeUnit.MINUTES);
                factory.addErrorPages(new ErrorPage(HttpStatus.404, "/notfound.html");
                return factory;
        }</programlisting>
<simpara>Setters are provided for many configuration options. Several protected method
&#8220;hooks&#8221; are also provided should you need to do something more exotic. See the
source code documentation for details.</simpara>
</section>
</section>
<section id="_jsp_limitations">
<title>JSP limitations</title>
<simpara>When running a Spring Boot application that uses an embedded servlet container (and is
packaged as an executable archive), there are some limitations in the JSP support.</simpara>
<itemizedlist>
<listitem>
<simpara>
With Tomcat it should work if you use WAR packaging, i.e. an executable WAR will work,
  and will also be deployable to a standard container (not limited to, but including
  Tomcat). An executable JAR will not work because of a hard coded file pattern in Tomcat.
</simpara>
</listitem>
<listitem>
<simpara>
Jetty does not currently work as an embedded container with JSPs.
</simpara>
</listitem>
</itemizedlist>
<simpara>There is a JSP sample so you can see how to set things up.</simpara>
</section>
</section>
</section>
<section id="_working_with_data">
<title>Working with data</title>
<section id="_configure_a_datasource">
<title>Configure a DataSource</title>
</section>
<section id="_spring_data">
<title>Spring Data</title>
</section>
<section id="_entityscan">
<title>@EntityScan</title>
</section>
<section id="_jpa_properties">
<title>JPA properties</title>
</section>
<section id="_initialize_a_database">
<title>Initialize a database</title>
</section>
</section>
<section id="_testing">
<title>Testing</title>
</section>
<section id="_production_ready_features">
<title>Production ready features</title>
<section id="_jmx">
<title>JMX</title>
</section>
</section>
<section id="_gradle_plugin">
<title>Gradle plugin</title>
</section>
<section id="_maven_plugin">
<title>Maven plugin</title>
</section>
<section id="_spring_boot_cli">
<title>Spring Boot CLI</title>
</section>
<section id="_deploying_to_the_cloud">
<title>Deploying to the cloud</title>
<section id="_cloud_foundry">
<title>Cloud Foundry</title>
</section>
<section id="_heroku">
<title>Heroku</title>
</section>
</section>
<section id="_lombok">
<title>Lombok</title>
</section>
<section id="_extending_spring_boot">
<title>Extending Spring Boot</title>
</section>
<section id="_starters">
<title>Starters</title>
<section id="_auto_configuration_2">
<title>Auto-Configuration</title>
<section id="_batch">
<title>Batch</title>
</section>
<section id="_integration">
<title>Integration</title>
</section>
<section id="_actuator">
<title>Actuator</title>
</section>
</section>
<section id="_cli">
<title>CLI</title>
</section>
<section id="_common_application_properties">
<title>Common application properties</title>
</section>
<section id="_conditions">
<title>Conditions</title>
</section>
</section>
<section id="_8220_how_to_8221_guides">
<title>&#8220;How-to&#8221; guides</title>
<simpara>This section provides answers to some common &#8220;how do I do that&#8230;&#8221; types of questions.</simpara>
<section id="_spring_boot_application">
<title>Spring Boot application</title>
<section id="_troubleshoot_auto_configuration">
<title>Troubleshoot auto-configuration</title>
<simpara>The Spring Boot auto-configuration tries it&#8217;s best to &#8220;do the right thing&#8221;, but
sometimes things fail and it can be hard to tell why.</simpara>
<simpara>There is a really useful <literal>AutoConfigurationReport</literal> available in any Spring Boot
<literal>ApplicationContext</literal>. You will see it if you enable <literal>DEBUG</literal> logging output. If you use
the Actuator there is also an endpoint <literal>/autoconfig</literal> that renders the report in JSON.
Use that to debug the application and see what features have been added (and which not) by
Spring Boot at runtime.</simpara>
<simpara>Many more questions can be answered by looking at the source code and Javadocs. Some
rules of thumb:</simpara>
<itemizedlist>
<listitem>
<simpara>
Look for classes called <literal>*AutoConfiguration</literal> and read their sources, in particular the
  <literal>@Conditional*</literal> annotations to find out what features they enable and when. Add
  <literal>--debug</literal> to the command line or a System property <literal>-Ddebug</literal> to get a printout on the
  console of all the autoconfiguration decisions that were made in your app. In a running
  Actuator app look at the <literal>/autoconfig</literal> endpoint (or the JMX equivalent) for the same
  information.
</simpara>
</listitem>
<listitem>
<simpara>
Look for classes that are <literal>@ConfigurationProperties</literal> (e.g.
  <ulink url="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java?source=c"><literal>ServerProperties</literal></ulink>
  and read from there the available external configuration options. The
  <literal>@ConfigurationProperties</literal> has a <literal>name</literal> attribute which acts as a prefix to external
  properties, thus <literal>ServerProperties</literal> has <literal>name="server"</literal> and its configuration properties
  are <literal>server.port</literal>, <literal>server.address</literal> etc. In a running Actuator app look at the
  <literal>/configprops</literal> endpoint or JMX equivalent.
</simpara>
</listitem>
<listitem>
<simpara>
Look for use of <literal>RelaxedEnvironment</literal> to pull configuration values explicitly out of the
  <literal>Environment</literal>. It often is used with a prefix.
</simpara>
</listitem>
<listitem>
<simpara>
Look for <literal>@Value</literal> annotations that bind directly to the <literal>Environment</literal>. This is less
  flexible than the <literal>RelaxedEnvironment</literal> approach, but does allow some relaxed binding,
  specifically for OS environment variables (so <literal>CAPITALS_AND_UNDERSCORES</literal> are synonyms
  for <literal>period.separated</literal>).
</simpara>
</listitem>
<listitem>
<simpara>
Look for <literal>@ConditionalOnExpression</literal> annotations that switch features on and off in
  response to SpEL expressions, normally evaluated with place-holders resolved from the
  <literal>Environment</literal>.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_test_a_spring_boot_application">
<title>Test a Spring Boot application</title>
<simpara>A Spring Boot application is just a Spring <literal>ApplicationContext</literal> so nothing very special
has to be done to test it beyond what you would normally do with a vanilla Spring context.
One thing to watch out for though is that the external properties, logging and other
features of Spring Boot are only installed in the context by default if you use
<literal>SpringApplication</literal> to create it. Spring Boot has a special Spring <literal>@ContextConfiguration</literal>
annotation, so you can use this for example (from the JPA Sample):</simpara>
<programlisting language="java" linenumbering="indent=0">        @RunWith(SpringJUnit4ClassRunner.class)
        @SpringApplicationConfiguration(classes = SampleDataJpaApplication.class)
        public class CityRepositoryIntegrationTests {

                @Autowired
                CityRepository repository;

                // ...

        }</programlisting>
<simpara>To use the <literal>@SpringApplicationConfiguration</literal> you need the test jar on your classpath
(recommended Maven co-ordinates <literal>org.springframework.boot:spring-boot-starter-test</literal>).
The context loader guesses whether you want to test a web application or not (e.g. with
<literal>MockMVC</literal>) by looking for the <literal>@WebAppConfiguration</literal> annotation.  (<literal>MockMVC</literal> and
<literal>@WebAppConfiguration</literal> are from the Spring Test support library).</simpara>
</section>
<section id="_customize_the_environment_or_applicationcontext_before_it_starts">
<title>Customize the Environment or ApplicationContext before it starts</title>
<simpara>A <literal>SpringApplication</literal> has <literal>ApplicationListeners</literal> and <literal>ApplicationContextInitializers</literal> that
are used to apply customizations to the context or environment. Spring Boot loads a number
of such customizations for use internally from <literal>META-INF/spring.factories</literal>. There is more
than one way to register additional ones:</simpara>
<itemizedlist>
<listitem>
<simpara>
Programmatically per application by calling the <literal>addListeners</literal> and <literal>addInitializers</literal>
  methods on <literal>SpringApplication</literal> before you run it.
</simpara>
</listitem>
<listitem>
<simpara>
Declaratively per application by setting <literal>context.initializer.classes</literal> or
  <literal>context.listener.classes</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
Declarative for all applications by adding a <literal>META-INF/spring.factories</literal> and packaging
  a jar file that the applications all use as a library.
</simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>SpringApplication</literal> sends some special <literal>ApplicationEvents</literal> to the listeners (even
some before the context is created), and then registers the listeners for events published
by the <literal>ApplicationContext</literal> as well. See XXX for a complete list.</simpara>
</section>
<section id="build-hierarchy">
<title>Build an ApplicationContext hierarchy (adding a parent or root context)</title>
</section>
<section id="_create_a_non_web_application">
<title>Create a non-web application</title>
<simpara>Not all Spring applications have to be web applications (or web services). If you want to
execute some code in a <literal>main</literal> method, but also bootstrap a Spring application to set up
the infrastructure to use, then it&#8217;s easy with the <literal>SpringApplication</literal> features of Spring
Boot. A <literal>SpringApplication</literal> changes its <literal>ApplicationContext</literal> class depending on whether it
thinks it needs a web application or not. The first thing you can do to help it is to just
leave the servlet API dependencies off the classpath. If you can&#8217;t do that (e.g. you are
running 2 applications from the same code base) then you can explicitly call
<literal>SpringApplication.setWebEnvironment(false)</literal>, or set the <literal>applicationContextClass</literal>
property (through the Java API or with external properties).
Application code that you want to run as your business logic can be implemented as a
<literal>CommandLineRunner</literal> and dropped into the context as a <literal>@Bean</literal> definition.</simpara>
</section>
</section>
<section id="_properties_amp_configuration">
<title>Properties &amp; configuration</title>
<section id="_externalize_the_configuration_of_springapplication">
<title>Externalize the configuration of SpringApplication</title>
<simpara>A <literal>SpringApplication</literal> has bean properties (mainly setters) so you can use its Java API as
you create the application to modify its behavior. Or you can externalize the
configuration using properties in <literal>spring.main.*</literal>. E.g. in <literal>application.properties</literal> you
might have.</simpara>
<screen>        spring.main.web_environment: false
        spring.main.show_banner: false</screen>
<simpara>and then the Spring Boot banner will not be printed on startup, and the application will
not be a web application.</simpara>
</section>
<section id="_change_the_location_of_external_properties_of_an_application">
<title>Change the location of external properties of an application</title>
<simpara>By default properties from different sources are added to the Spring <literal>Environment</literal> in a
defined order, and the precedence for resolution is:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
commandline
</simpara>
</listitem>
<listitem>
<simpara>
filesystem (current working directory) <literal>application.properties</literal>
</simpara>
</listitem>
<listitem>
<simpara>
classpath <literal>application.properties</literal>.
</simpara>
</listitem>
</orderedlist>
<simpara>A nice way to augment and modify this is to add <literal>@PropertySource</literal> annotations to your
application sources. Classes passed to the <literal>SpringApplication</literal> static convenience
methods, and those added using <literal>setSources()</literal> are inspected to see if they have
<literal>@PropertySources</literal> and if they do those properties are added to the <literal>Environment</literal> early
enough to be used in all phases of the <literal>ApplicationContext</literal> lifecycle. Properties added
in this way have precendence over any added using the default locations, but have lower
priority than system properties, environment variables or the command line.</simpara>
<simpara>You can also provide System properties (or environment variables) to change the behavior:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>spring.config.name</literal> (<literal>SPRING_CONFIG_NAME</literal>), defaults to <literal>application</literal> as the root of
  the file name.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>spring.config.location</literal> (<literal>SPRING_CONFIG_LOCATION</literal>) is file to load (e.g. a classpath
  resource or a URL). A separate <literal>Environment</literal> property source is set up for this document
  and it can be overridden by system properties, environment variables or the
  command line.
</simpara>
</listitem>
</itemizedlist>
<simpara>No matter what you set in the environment, Spring Boot will always load
<literal>application.properties</literal> as described above. If YAML is used then files with the &#8220;.yml&#8221;
extension are also added to the list by default.</simpara>
<simpara>See <literal>ConfigFileApplicationListener</literal> for more detail.</simpara>
</section>
<section id="_use_8220_short_8221_command_line_arguments">
<title>Use &#8220;short&#8221; command line arguments</title>
<simpara>Some people like to use (for example) <literal>--port=9000</literal> instead of <literal>--server.port=9000</literal> to
set configuration properties on the command line. You can easily enable this by using
placeholders in <literal>application.properties</literal>, e.g.</simpara>
<screen></screen>
<note><simpara>In this specific case the port binding will work in a PaaS environment like Heroku
and Cloud Foundry, since in those two platforms the <literal>PORT</literal> environment variable is set
automatically and Spring can bind to capitalized synonyms for <literal>Environment</literal> properties.</simpara></note>
</section>
<section id="_use_yaml_for_external_properties">
<title>Use YAML for external properties</title>
<simpara>YAML is a superset of JSON and as such is a very convenient syntax for storing external
properties in a hierarchical format. E.g.</simpara>
<programlisting language="yaml" linenumbering="indent=0">        spring:
                application:
                        name: cruncher
                datasource:
                        driverClassName: com.mysql.jdbc.Driver
                        url: jdbc:mysql://localhost/test
        server:
                port: 9000</programlisting>
<simpara>Create a file called <literal>application.yml</literal> and stick it in the root of your classpath, and
also add <literal>snakeyaml</literal> to your classpath (Maven co-ordinates <literal>org.yaml:snakeyaml</literal>, already
included if you use a Spring Boot Starter). A YAML file is parsed to a Java
<literal>Map&lt;String,Object&gt;</literal> (like a JSON object), and Spring Boot flattens the maps so that it
is 1-level deep and has period-separated keys, a lot like people are used to with
<literal>Properties</literal> files in Java.</simpara>
<simpara>The example YAML above corresponds to an <literal>application.properties</literal> file</simpara>
<screen>        spring.application.name: cruncher
        spring.datasource.driverClassName: com.mysql.jdbc.Driver
        spring.datasource.url: jdbc:mysql://localhost/test
        server.port: 9000</screen>
</section>
<section id="_set_the_active_spring_profiles">
<title>Set the active Spring profiles</title>
<simpara>The Spring <literal>Environment</literal> has an API for this, but normally you would set a System profile
(<literal>spring.profiles.active</literal>) or an OS environment variable (<literal>SPRING_PROFILES_ACTIVE</literal>). E.g.
launch your application with a <literal>-D...</literal> argument (remember to put it before the main class
or jar archive):</simpara>
<screen>        $ java -jar -Dspring.profiles.active=production demo-0.0.1-SNAPSHOT.jar</screen>
<simpara>In Spring Boot you can also set the active profile in <literal>application.properties</literal>, e.g.</simpara>
<screen>        spring.profiles.active=production</screen>
<simpara>A value set this way is replaced by the System property or environment variable setting,
but not by the <literal>SpringApplicationBuilder.profiles()</literal> method. Thus the latter Java API can
be used to augment the profiles without changing the defaults.</simpara>
</section>
<section id="_change_configuration_depending_on_the_environment">
<title>Change configuration depending on the environment</title>
<simpara>A YAML file is actually a sequence of documents separated by <literal>---</literal> lines, and each
document is parsed separately to a flattened map.</simpara>
<simpara>If a YAML document contains a <literal>spring.profiles</literal> key, then the profiles value
(comma-separated list of profiles) is fed into the Spring
<literal>Environment.acceptsProfiles()</literal> and if any of those profiles is active that document is
included in the final merge (otherwise not).</simpara>
<simpara>Example:</simpara>
<programlisting language="yaml" linenumbering="indent=0">        server:
                port: 9000
        ---

        spring:
                profiles: development
        server:
                port: 9001

        ---

        spring:
                profiles: production
        server:
                port: 0</programlisting>
<simpara>In this example the default port is 9000, but if the Spring profile &#8220;development&#8221; is
active then the port is 9001, and if &#8220;production&#8221; is active then it is 0.</simpara>
<simpara>The YAML documents are merged in the order they are encountered (so later values override
earlier ones).</simpara>
<simpara>To do the same thing with properties files you can use <literal>application-${profile}.properties</literal>
to specify profile-specific values.</simpara>
</section>
<section id="discover-options">
<title>Discover built-in options for external properties</title>
<simpara>Spring Boot binds external properties from <literal>application.properties</literal> (or <literal>.yml</literal>) (and
other places) into an application at runtime.  There is not (and technically cannot be)
an exhaustive list of all supported properties in a single location because contributions
can come from additional JAR files on your classpath.</simpara>
<simpara>A running application with the Actuator features has a <literal>/configprops</literal> endpoint that shows
all the bound and bindable properties available through <literal>@ConfigurationProperties</literal> (also
exposed through JMX if you don&#8217;t have a web endpoint).</simpara>
<simpara>There is a sample
<ulink url="https://github.com/spring-projects/spring-boot/blob/master/docs/application.yml"><literal>application.yml</literal></ulink>
with a non-exhaustive and possibly inaccurate list of properties supported by Spring Boot
vanilla with autoconfiguration. The definitive list comes from searching the source code
for <literal>@ConfigurationProperties</literal> and <literal>@Value</literal> annotations, as well as the occasional use of
<literal>RelaxedEnvironment</literal> (c.f. <ulink url="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaAutoConfiguration.java?source=c#L65">here</ulink>).</simpara>
</section>
</section>
<section id="_embedded_servlet_containers">
<title>Embedded servlet containers</title>
<section id="_add_a_servlet_filter_or_servletcontextlistener_to_an_application">
<title>Add a Servlet, Filter or ServletContextListener to an application</title>
<simpara><literal>Servlet</literal>, <literal>Filter</literal>, <literal>ServletContextListener</literal> and the other listeners supported by the
Servlet spec can be added to your application as <literal>@Bean</literal> definitions. Be very careful that
they don&#8217;t cause eager initialization of too many other beans because they have to be
installed in th container very early in the application lifecycle (e.g. it&#8217;s not a good
idea to have them depend on your <literal>DataSource</literal> or JPA configuration). You can work around
restrictions like that by initializing them lazily when first used instead of on
initialization.</simpara>
<simpara>In the case of <literal>Filters</literal> and <literal>Servlets</literal> you can also add mappings and init parameters by
adding a <literal>FilterRegistrationBean</literal> or <literal>ServletRegistrationBean</literal> instead of or as well as
the underlying component.</simpara>
</section>
<section id="_change_the_http_port">
<title>Change the HTTP port</title>
<simpara>In a standalone application the main HTTP port defaults to 8080, but can be set with
<literal>server.port</literal> (e.g. in <literal>application.properties</literal> or as a System property). Thanks to
relaxed binding of <literal>Environment</literal> values you can also use <literal>SERVER_PORT</literal> (e.g. as an OS
environment variable).</simpara>
<simpara>To switch off the HTTP endpoints completely, but still create a <literal>WebApplicationContext</literal>,
use <literal>server.port=-1</literal> (this is sometimes useful for testing).</simpara>
<simpara>For more detail look at the <ulink url="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java?source=c"><literal>ServerProperties</literal></ulink>
source code.</simpara>
</section>
<section id="_use_a_random_unassigned_http_port">
<title>Use a random unassigned HTTP port</title>
<simpara>To scan for a free port (using OS natives to prevent clashes) use <literal>server.port=0</literal>.</simpara>
</section>
<section id="_discover_the_http_port_at_runtime">
<title>Discover the HTTP port at runtime</title>
<simpara>You can access the port the server is running on from log output or from the
<literal>EmbeddedWebApplicationContext</literal> via its <literal>EmbeddedServletContainer</literal>. The best way to get
that and be sure that it has initialized is to add a <literal>@Bean</literal> of type
<literal>ApplicationListener&lt;EmbeddedServletContainerInitializedEvent&gt;</literal> and pull the container
out of the event wehen it is published.</simpara>
</section>
<section id="_configure_tomcat">
<title>Configure Tomcat</title>
<simpara>Generally you can follow the advice from <xref linkend="discover-options"/> about
<literal>@ConfigurationProperties</literal> (<literal>ServerProperties</literal> is the main one here), but also look at
<literal>EmbeddedServletContainerCustomizer</literal> and various Tomcat specific <literal>*Customizers</literal> that you
can add in one of those. The Tomcat APIs are quite rich so once you have access to the
<literal>TomcatEmbeddedServletContainerFactory</literal> you can modify it in a number of ways. Or the
nuclear option is to add your own <literal>TomcatEmbeddedServletContainerFactory</literal>.</simpara>
</section>
<section id="_terminate_ssl_in_tomcat">
<title>Terminate SSL in Tomcat</title>
<simpara>Add a <literal>EmbeddedServletContainerCustomizer</literal> and in that add a <literal>TomcatConnectorCustomizer</literal>
that sets up the connector to be secure:</simpara>
<programlisting language="java" linenumbering="indent=0">        @Bean
        public EmbeddedServletContainerCustomizer containerCustomizer(){
                return new MyCustomizer();
        }

        // ...

        private static class MyCustomizer implements EmbeddedServletContainerCustomizer {

                @Override
                public void customize(ConfigurableEmbeddedServletContainerFactory factory) {
                        if(factory instanceof TomcatEmbeddedServletContainerFactory) {
                                customizeTomcat((TomcatEmbeddedServletContainerFactory) factory));
                        }
                }

                public void customizeTomcat(TomcatEmbeddedServletContainerFactory factory) {
                        factory.addConnectorCustomizers(new TomcatConnectorCustomizer() {
                                @Override
                                public void customize(Connector connector) {
                                        connector.setPort(serverPort);
                                        connector.setSecure(true);
                                        connector.setScheme("https");
                                        connector.setAttribute("keyAlias", "tomcat");
                                        connector.setAttribute("keystorePass", "password");
                                        try {
                                                connector.setAttribute("keystoreFile",
                                                        ResourceUtils.getFile("src/ssl/tomcat.keystore").getAbsolutePath());
                                        } catch (FileNotFoundException e) {
                                                throw new IllegalStateException("Cannot load keystore", e);
                                        }
                                        connector.setAttribute("clientAuth", "false");
                                        connector.setAttribute("sslProtocol", "TLS");
                                        connector.setAttribute("SSLEnabled", true);
                                }
                        });
                }

        }</programlisting>
</section>
<section id="_use_jetty_instead_of_tomcat">
<title>Use Jetty instead of Tomcat</title>
<simpara>The Spring Boot starters (<literal>spring-boot-starter-web</literal> in particular) use Tomcat as an
embedded container by default. You need to exclude those dependencies and include the
Jetty ones to use that container. Spring Boot provides Tomcat and Jetty dependencies
bundled together as separate startes to help make this process as easy as possible.</simpara>
<simpara>Example in Maven:</simpara>
<programlisting language="xml" linenumbering="indent=0">        &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
                &lt;exclusions&gt;
                        &lt;exclusion&gt;
                                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                                &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
                        &lt;/exclusion&gt;
                &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;
        &lt;/dependency&gt;</programlisting>
<simpara>Example in Gradle:</simpara>
<programlisting language="groovy" linenumbering="indent=0">        configurations {
                compile.exclude module: 'spring-boot-starter-tomcat'
        }

        dependencies {
                compile("org.springframework.boot:spring-boot-starter-web:1.0.0.RC3")
                compile("org.springframework.boot:spring-boot-starter-jetty:1.0.0.RC3")
                // ...
        }</programlisting>
</section>
<section id="_configure_jetty">
<title>Configure Jetty</title>
<simpara>Generally you can follow the advice [here](#discover.options) about
<literal>@ConfigurationProperties</literal> (<literal>ServerProperties</literal> is the main one here), but also look at
<literal>EmbeddedServletContainerCustomizer</literal>. The Jetty APIs are quite rich so once you have
access to the <literal>JettyEmbeddedServletContainerFactory</literal> you can modify it in a number
of ways. Or the nuclear option is to add your own <literal>JettyEmbeddedServletContainerFactory</literal>.</simpara>
</section>
<section id="_use_tomcat_8">
<title>Use Tomcat 8</title>
<simpara>Tomcat 8 works with Spring Boot, but the default is to use Tomcat 7 (so we can support
Java 1.6 out of the box). You should only need to change the classpath to use Tomcat 8
for it to work. The <ulink url="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-samples/spring-boot-sample-websocket/pom.xml">websocket sample</ulink>
shows you how to do that in Maven.</simpara>
</section>
<section id="_use_jetty_9">
<title>Use Jetty 9</title>
<simpara>Jetty 9 works with Spring Boot, but the default is to use Jetty 8 (so we can support
Java 1.6 out of the box). You should only need to change the classpath to use Jetty 9
for it to work.</simpara>
<simpara>If you are using the starter poms and parent you can just add the Jetty starter and
change the version properties, e.g. for a simple webapp or service:</simpara>
<programlisting language="xml" linenumbering="indent=0">        &lt;properties&gt;
                &lt;java.version&gt;1.7&lt;/java.version&gt;
                &lt;jetty.version&gt;9.1.0.v20131115&lt;/jetty.version&gt;
                &lt;servlet-api.version&gt;3.1.0&lt;/servlet-api.version&gt;
        &lt;/properties&gt;
        &lt;dependencies&gt;
                &lt;dependency&gt;
                        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
                        &lt;exclusions&gt;
                                &lt;exclusion&gt;
                                        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                                        &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
                                &lt;/exclusion&gt;
                        &lt;/exclusions&gt;
                &lt;/dependency&gt;
                &lt;dependency&gt;
                        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                        &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;
                &lt;/dependency&gt;
        &lt;/dependencies&gt;</programlisting>
</section>
</section>
<section id="_spring_mvc">
<title>Spring MVC</title>
<section id="_write_a_json_rest_service">
<title>Write a JSON REST service</title>
<simpara>Any Spring <literal>@RestController</literal> in a Spring Boot application should render JSON response by
default as long as Jackson2 is on the classpath. For example:</simpara>
<programlisting language="java" linenumbering="indent=0">        @RestController
        public class MyController {

                @RequestMapping("/thing")
                public MyThing thing() {
                                return new MyThing();
                }

        }</programlisting>
<simpara>As long as <literal>MyThing</literal> can be serialized by Jackson2 (e.g. a normal POJO or Groovy object)
then <literal>http://localhost:8080/thing</literal> will serve a JSON representation of it by default.
Sometimes in a browser you might see XML responses (but by default only if <literal>MyThing</literal> was
a JAXB object) because browsers tend to send accept headers that prefer XML.</simpara>
</section>
<section id="_customize_the_jackson_objectmapper">
<title>Customize the Jackson ObjectMapper</title>
<simpara>Spring MVC (client and server side) uses <literal>HttpMessageConverters</literal> to negotiate content
conversion in an HTTP exchange. If Jackson is on the classpath you already get a default
converter with a vanilla <literal>ObjectMapper</literal>. Spring Boot has some features to make it easier
to customize this behavior.</simpara>
<simpara>The smallest change that might work is to just add beans of type <literal>Module</literal> to your context.
They will be registered with the default <literal>ObjectMapper</literal> and then injected into the default
message converter. To replace the default <literal>ObjectMapper</literal> completely, define a <literal>@Bean</literal> of
that type and mark it as <literal>@Primary</literal>.</simpara>
<simpara>In addition, if your context contains any beans of type <literal>ObjectMapper</literal> then all of the
<literal>Module</literal> beans will be registered with all of the mappers. So there is a global mechanism
for contributing custom modules when you add new features to your application.</simpara>
<simpara>Finally, if you provide any <literal>@Beans</literal> of type <literal>MappingJackson2HttpMessageConverter</literal> then
they will replace the default value in the MVC configuration. Also, a convenience bean is
provided of type <literal>HttpMessageConverters</literal> (always available if you use the default MVC
configuration) which has some useful methods to access the default and user-enhanced
message converters.</simpara>
<simpara>See also the <link linkend="message-converters">section on <literal>HttpMessageConverters</literal></link> and the
<literal>WebMvcAutoConfiguration</literal> source code for more details.</simpara>
</section>
<section id="message-converters">
<title>Customize the @ResponseBody rendering</title>
<simpara>Spring uses <literal>HttpMessageConverters</literal> to render <literal>@ResponseBody</literal> (or responses from
<literal>@RestControllers</literal>). You can contribute additional converters by simply adding beans of
that type in a Spring Boot context. If a bean you add is of a type that would have been
included by default anyway (like <literal>MappingJackson2HttpMessageConverter</literal> for JSON
conversions) then it will replace the default value. A convenience bean is provided of
type <literal>HttpMessageConverters</literal> (always available if you use the default MVC configuration)
which has some useful methods to access the default and user-enhanced message converters
(useful, for example if you want to manually inject them into a custom <literal>RestTemplate</literal>).</simpara>
<simpara>As in normal MVC usage, any <literal>WebMvcConfigurerAdapter</literal> beans that you provide can also
contribute converters by overriding the <literal>configureMessageConverters</literal> method, but unlike
with normal MVC, you can supply only additional converters that you need (because Spring
Boot uses the same mechanism to contribute its defaults). Finally, if you opt out of the
Spring Boot default MVC configuration by providing your own <literal>@EnableWebMvc</literal> configuration,
then you can take control completely and do everything manually using
<literal>getMessageConverters</literal> from <literal>WebMvcConfigurationSupport</literal>.</simpara>
<simpara>See the <literal>WebMvcAutoConfiguration</literal> source code for more details.</simpara>
</section>
<section id="_switch_off_the_spring_mvc_dispatcherservlet">
<title>Switch off the Spring MVC DispatcherServlet</title>
<simpara>Spring Boot wants to serve all content from the root of your application <literal>/</literal> down. If you
would rather map your own servlet to that URL you can do it, but of course you may lose
some of the other Boot MVC features. To add your own servlet and map it to the root
resource just declare a <literal>@Bean</literal> of type <literal>Servlet</literal> and give it the special bean name
<literal>dispatcherServlet</literal>. (You can also create a bean of a different type with that name if
you want to switch it off and not replace it.)</simpara>
</section>
<section id="_switch_off_the_default_mvc_configuration">
<title>Switch off the Default MVC configuration</title>
<simpara>The easiest way to take complete control over MVC configuration is to provide your own
<literal>@Configuration</literal> with the <literal>@EnableWebMvc</literal> annotation. This will leave all MVC
configuration in your hands.</simpara>
</section>
</section>
<section id="_logging_2">
<title>Logging</title>
<section id="_configure_logback_for_logging">
<title>Configure Logback for logging</title>
<simpara>Spring Boot has no mandatory logging dependence, except for the <literal>commons-logging</literal> API, of
which there are many implementations to choose from. To use <ulink url="http://logback.qos.ch">Logback</ulink>
you need to include it, and some bindings for <literal>commons-logging</literal> on the classpath. The
simplest way to do that is through the starter poms which all depend on
<literal>spring-boot-start-logging</literal>.  For a web application you only need the web starter since it
depends transitively on the logging starter. E.g. in Maven:</simpara>
<programlisting language="xml" linenumbering="indent=0">        &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;</programlisting>
<simpara>Spring Boot has a <literal>LoggingSystem</literal> abstraction that attempts to select a system depending
on the contents of the classpath. If Logback is available it is the first choice. So if
you put a <literal>logback.xml</literal> in the root of your classpath it will be picked up from there.
Spring Boot provides a default base configuration that you can include if you just want
to set levels, e.g.</simpara>
<programlisting language="xml" linenumbering="indent=0">        &lt;?xml version="1.0" encoding="UTF-8"?&gt;
        &lt;configuration&gt;
                &lt;include resource="org/springframework/boot/logging/logback/base.xml"/&gt;
                &lt;logger name="org.springframework.web" level="DEBUG"/&gt;
        &lt;/configuration&gt;</programlisting>
<simpara>If you look at the default <literal>logback.xml</literal> in the spring-boot JAR you will see that it uses
some useful System properties which the <literal>LoggingSystem</literal> takes care of creating for you.
These are:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>${PID}</literal> the current process ID.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>${LOG_FILE}</literal> if <literal>logging.file</literal> was set in Boot&#8217;s external configuration.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>${LOG_PATH</literal> if <literal>logging.path</literal> was set (representing a directory for
        log files to live in).
</simpara>
</listitem>
</itemizedlist>
<simpara>Spring Boot also provides some nice ANSI colour terminal output on a console (but not in
a log file) using a custom Logback converter. See the default <literal>base.xml</literal> configuration
for details.</simpara>
<simpara>If Groovy is on the classpath you should be able to configure Logback with
<literal>logback.groovy</literal> as well (it will be given preference if present).</simpara>
</section>
<section id="_configure_log4j_for_logging">
<title>Configure Log4j for logging</title>
<simpara>Spring Boot supports <ulink url="http://logging.apache.org/log4j/1.x/">Log4j</ulink> for logging
configuration, but it has to be on the classpath. If you are using the starter poms for
assembling dependencies that means you have to exclude logback and then include log4j
back. If you aren&#8217;t using the starter poms then you need to provide <literal>commons-logging</literal>
(at least) in addition to Log4j.</simpara>
<simpara>The simplest path to using Log4j is probably through the starter poms, even though it
requires some jiggling with excludes, e.g. in Maven:</simpara>
<programlisting language="xml" linenumbering="indent=0">        &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
                &lt;exclusions&gt;
                                &lt;exclusion&gt;
                                                &lt;groupId&gt;${project.groupId}&lt;/groupId&gt;
                                                &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
                                &lt;/exclusion&gt;
                &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt;
        &lt;/dependency&gt;</programlisting>
<note><simpara>The use of the log4j starter to gather together the dependencies for common logging
requirements (e.g. including having Tomcat use <literal>java.util.logging</literal> but configure the
output using Log4j). See the Actuator Log4j Sample for more detail and to see it in
action.</simpara></note>
</section>
</section>
<section id="_data_access">
<title>Data Access</title>
<section id="_configure_a_datasource_2">
<title>Configure a DataSource</title>
<simpara>Spring Boot will create a <literal>DataSource</literal> for you if you have <literal>spring-jdbc</literal> and some other
things on the classpath. Here&#8217;s the algorithm for choosing a specific implementation.</simpara>
<itemizedlist>
<listitem>
<simpara>
We prefer the Tomcat pooling <literal>DataSource</literal> for its performance and concurrency, so if
  that is available we always choose it.
</simpara>
</listitem>
<listitem>
<simpara>
If commons-dbcp is available we will use that, but we don&#8217;t recommend it in production.
</simpara>
</listitem>
<listitem>
<simpara>
If neither of those is available but an embedded database is then we create one of
  those for you (preference order is h2, then Apache Derby, then hsqldb).
</simpara>
</listitem>
</itemizedlist>
<simpara>The pooling <literal>DataSource</literal> option is controlled by external configuration properties in
<literal>spring.datasource.*</literal> for example:</simpara>
<screen>        spring.datasource.url: jdbc:mysql://localhost/test
        spring.datasource.username: root
        spring.datasource.password:
        spring.datasource.driverClassName: com.mysql.jdbc.Driver</screen>
<simpara>The <literal>@ConfigurationProperties</literal> for <literal>spring.datasource</literal> are defined in
<literal>AbstractDataSourceConfiguration</literal> (so see there for more options).</simpara>
<simpara>For a pooling <literal>DataSource</literal> to be created we need to be able to verify that a valid
<literal>Driver</literal> class is available, so we check for that before doing anything. I.e. if you set
<literal>spring.datasource.driverClassName=com.mysql.jdbc.Driver</literal> then that class has to be
loadable.</simpara>
<simpara>To override the default settings just define a <literal>@Bean</literal> of your own of type <literal>DataSource</literal>.
See <ulink url="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceAutoConfiguration.java"><literal>DataSourceAutoConfiguration</literal></ulink>
for more details.</simpara>
</section>
<section id="_use_spring_data_repositories">
<title>Use Spring Data repositories</title>
<simpara>Spring Data can create implementations for you of <literal>@Repository</literal> interfaces of various
flavours. Spring Boot will handle all of that for you as long as those <literal>@Repositories</literal>
are included in the same package (or a sub-package) of your <literal>@EnableAutoConfiguration</literal>
class.</simpara>
<simpara>For many applications all you will need is to put the right Spring Data dependencies on
your classpath (there is a <literal>spring-boot-starter-data-jpa</literal> for JPA and for Mongodb you
only need to add <literal>spring-datamongodb</literal>), create some repository interfaces to handle your
<literal>@Entity</literal> objects. Examples are in the <ulink url="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-data-jpa">JPA sample</ulink>
or the <ulink url="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-data-mongodb">Mongodb sample</ulink>.</simpara>
<simpara>Spring Boot tries to guess the location of your <literal>@Repository</literal> definitions, based on the
<literal>@EnableAutoConfiguration</literal> it finds. To get more control, use the <literal>@EnableJpaRepositories</literal>
annotation (from Spring Data JPA).</simpara>
</section>
<section id="_separate_entity_definitions_from_spring_configuration">
<title>Separate @Entity definitions from Spring configuration</title>
<simpara>Spring Boot tries to guess the location of your <literal>@Entity</literal> definitions, based on the
<literal>@EnableAutoConfiguration</literal> it finds. To get more control, you can use the <literal>@EntityScan</literal>
annotation, e.g.</simpara>
<programlisting language="java" linenumbering="indent=0">        @Configuration
        @EnableAutoConfiguration
        @EntityScan(basePackageClasses=City.class)
        public class Application {

                //...

        }</programlisting>
</section>
<section id="_configure_jpa_properties">
<title>Configure JPA properties</title>
<simpara>Spring JPA already provides some vendor-independent configuration options (e.g. for SQL
logging) and Spring Boot exposes those, and a few more for hibernate as external
configuration properties. The most common options to set are:</simpara>
<screen>        spring.jpa.hibernate.ddl-auto: create-drop
        spring.jpa.hibernate.naming_strategy: org.hibernate.cfg.ImprovedNamingStrategy
        spring.jpa.database: H2
        spring.jpa.show-sql: true</screen>
<simpara>(Because of relaxed data binding hyphens or underscores should work equally well as
property keys.)  The <literal>ddl-auto</literal> setting is a special case in that it has different
defaults depending on whether you are using an embedded database (<literal>create-drop</literal>) or not
(<literal>none</literal>). In addition all properties in <literal>spring.jpa.properties.*</literal> are passed through as
normal JPA properties (with the prefix stripped) when the local <literal>EntityManagerFactory</literal> is
created.</simpara>
<simpara>See <ulink url="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaAutoConfiguration.java"><literal>HibernateJpaAutoConfiguration</literal></ulink>
and <ulink url="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/orm/jpa/JpaBaseConfiguration.java"><literal>JpaBaseConfiguration</literal></ulink>
for more details.</simpara>
</section>
<section id="_use_a_traditional_persistence_xml">
<title>Use a traditional persistence.xml</title>
<simpara>Spring doesn&#8217;t require the use of XML to configure the JPA provider, and Spring Boot
assumes you want to take advantage of that feature. If you prefer to use <literal>persistence.xml</literal>
then you need to define your own <literal>@Bean</literal> of type <literal>LocalEntityManagerFactoryBean</literal>, and set
the persistence unit name there.</simpara>
<simpara>See
<ulink url="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/orm/jpa/JpaBaseConfiguration.java"><literal>JpaBaseConfiguration</literal></ulink>
for the default settings.</simpara>
</section>
</section>
<section id="_database_initialization">
<title>Database initialization</title>
<simpara>An SQL database can be initialized in different ways depending on what your stack is. Or
of course you can do it manually as long as the database is in a server.</simpara>
<section id="_initialize_a_database_using_jpa">
<title>Initialize a database using JPA</title>
<simpara>JPA has features for DDL generation, and these can be set up to run on startup against the
database. This is controlled through two external properties:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>spring.jpa.generate-ddl</literal> (boolean) switches the feature on and off and is vendor
  independent.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>spring.jpa.hibernate.ddl-auto</literal> (enum) is a Hibernate feature that controls the
  behavior in a more fine-grained way. See below for more detail.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_initialize_a_database_using_hibernate">
<title>Initialize a database using Hibernate</title>
<simpara>You can set <literal>spring.jpa.hibernate.ddl-auto</literal> explicitly and the standard Hibernate property
values are <literal>none</literal>, <literal>validate</literal>, <literal>update</literal>, <literal>create-drop</literal>. Spring Boot chooses a default
value for you based on whether it thinks your database is embedded (default <literal>create-drop</literal>)
or not (default <literal>none</literal>). An embedded database is detected by looking at the <literal>Connection</literal>
type: <literal>hsqldb</literal>, <literal>h2</literal> and <literal>derby</literal> are embedded, the rest are not. Be careful when switching
from in-memory to a &#8220;real&#8221; database that you don&#8217;t make assumptions about the existence of
the tables and data in the new platform. You either have to set <literal>ddl-auto</literal> expicitly, or
use one of the other mechanisms to initialize the database.</simpara>
<simpara>In addition, a file named <literal>import.sql</literal> in the root of the classpath will be executed on
startup. This can be useful for demos and for testing if you are carefuil, but probably
not something you want to be on the classpath in production. It is a Hibernate feature
(nothing to do with Spring).</simpara>
</section>
<section id="_initialize_a_database_using_spring_jdbc">
<title>Initialize a database using Spring JDBC</title>
<simpara>Spring JDBC has a <literal>DataSource</literal> initializer feature. Spring Boot enables it by default and
loads SQL from the standard locations <literal>schema.sql</literal> and <literal>data.sql</literal> (in the root of the
classpath). In addition Spring Boot will load a file <literal>schema-${platform}.sql</literal> where
<literal>platform</literal> is the vendor name of the database (<literal>hsqldb</literal>, <literal>h2</literal>, <literal>oracle</literal>, <literal>mysql</literal>,
<literal>postgresql</literal> etc.). Spring Boot enables the failfast feature of the Spring JDBC
initializer by default, so if the scripts cause exceptions the application will fail.</simpara>
<simpara>To disable the failfast you can set <literal>spring.datasource.continueOnError=true</literal>. This can be
useful once an application has matured and been deployed a few times, since the scripts
can act as &#8220;poor man&#8217;s migrations&#8221; - inserts that fail mean that the data is already
there, so there would be no need to prevent the application from running, for instance.</simpara>
</section>
<section id="_initialize_a_spring_batch_database">
<title>Initialize a Spring Batch database</title>
<simpara>If you are using Spring Batch then it comes pre-packaged with SQL initialization scripts
for most popular database platforms. Spring Boot will detect your database type, and
execute those scripts by default, and in this case will switch the fail fast setting to
false (errors are logged but do not prevent the application from starting). This is
because the scripts are known to be reliable and generally do not contain bugs, so errors
are ignorable, and ignoring them makes the scripts idempotent. You can switch off the
initialization explicitly using <literal>spring.batch.initializer.enabled=false</literal>.</simpara>
</section>
<section id="_use_a_higher_level_datababse_migration_tool">
<title>Use a higher level datababse migration tool</title>
<simpara>Spring Boot works fine with higher level migration tools <ulink url="http://flywaydb.org/">Flyway</ulink>
(SQL-based) and <ulink url="http://www.liquibase.org/">Liquibase</ulink> (XML). In general we prefer
Flyway because it is easier on the eyes, and it isn&#8217;t very common to need platform
independence: usually only one or at most couple of platforms is needed.</simpara>
</section>
</section>
<section id="_batch_applications">
<title>Batch applications</title>
<section id="_execute_spring_batch_jobs_on_startup">
<title>Execute Spring Batch jobs on startup</title>
<simpara>Spring Batch autoconfiguration is enabled by adding <literal>@EnableBatchProcessing</literal>
(from Spring Batch) somewhere in your context.</simpara>
<simpara>By default it executes <emphasis role="strong">all</emphasis> <literal>Jobs</literal> in the application context on startup (see
<ulink url="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/batch/JobLauncherCommandLineRunner.java">JobLauncherCommandLineRunner</ulink>
for details). You can narrow down to a specific job or jobs by specifying
<literal>spring.batch.job.names</literal> (comma separated job name patterns).</simpara>
<simpara>If the application context includes a <literal>JobRegistry</literal> then the jobs in
<literal>spring.batch.job.names</literal> are looked up in the regsitry instead of bein autowired from the
context. This is a common pattern with more complex systems where multiple jobs are
defined in child contexts and registered centrally.</simpara>
<simpara>See
<ulink url="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/batch/BatchAutoConfiguration.java">BatchAutoConfiguration</ulink>
and
<ulink url="https://github.com/spring-projects/spring-batch/blob/master/spring-batch-core/src/main/java/org/springframework/batch/core/configuration/annotation/EnableBatchProcessing.java">@EnableBatchProcessing</ulink>
for more details.</simpara>
</section>
</section>
<section id="_actuator_2">
<title>Actuator</title>
<section id="_change_the_http_port_or_address_of_the_actuator_endpoints">
<title>Change the HTTP port or address of the actuator endpoints</title>
<simpara>In a standalone application the Actuator HTTP port defaults to the same as the main HTTP
port. To make the application listen on a different port set the external property
<literal>management.port</literal>. To listen on a completely different network address (e.g. if you have
an internal network for management and an external one for user applications) you can
also set <literal>management.address</literal> to a valid IP address that the server is able to bind to.</simpara>
<simpara>For more detail look at the
<ulink url="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/properties/ManagementServerProperties.java?source=c"><literal>ManagementServerProperties</literal></ulink>
source code.</simpara>
</section>
<section id="_customize_the_8220_whitelabel_8221_error_page">
<title>Customize the &#8220;whitelabel&#8221; error page</title>
<simpara>The Actuator installs a &#8220;whitelabel&#8221; error page that you will see in browser client if
you encounter a server error (machine clients consuming JSON and other media types should
see a sensible response with the right error code). To switch it off you can set
<literal>error.whitelabel.enabled=false</literal>, but normally in addition or alternatively to that you
will want to add your own error page replacing the whitelabel one. If you are using
Thymeleaf you can do this by adding an <literal>error.html</literal> template. In general what you need is
a <literal>View</literal> that resolves with a name of <literal>error</literal>, and/or a <literal>@Controller</literal> that handles the
<literal>/error</literal> path. Unless you replaced some of the default configuration you should find a
<literal>BeanNameViewResolver</literal> in your <literal>ApplicationContext</literal> so a <literal>@Bean</literal> with id <literal>error</literal> would be
a simple way of doing that.  Look at <literal>ErrorMvcAutoConfiguration</literal> for more options.</simpara>
</section>
</section>
<section id="_security">
<title>Security</title>
<section id="_secure_an_application">
<title>Secure an application</title>
<simpara>Web applications will be secure by default (with Basic authentication on all endpoints) if
Spring Security is on the classpath. To add method-level security to a web application you
can simply <literal>@EnableGlobalMethodSecurity</literal> with your desired settings.</simpara>
<simpara>The default <literal>AuthenticationManager</literal> has a single user (username &#8220;user&#8221; and password
random, printed at INFO when the application starts up). You can change the password by
providing a <literal>security.user.password</literal>. This and other useful properties are externalized
via <literal>SecurityProperties</literal>.</simpara>
</section>
<section id="_switch_off_the_spring_boot_security_configuration">
<title>Switch off the Spring Boot security configuration</title>
<simpara>If you define a <literal>@Configuration</literal> with <literal>@EnableWebSecurity</literal> anywhere in your application
it will switch off the default webapp security settings in Spring Boot. To tweak the
defaults try setting properties in <literal>security.*</literal> (see
<ulink url="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/SecurityProperties.java"><literal>SecurityProperties</literal></ulink>
for details of available settings).</simpara>
</section>
<section id="_change_the_authenticationmanager_and_add_user_accounts">
<title>Change the AuthenticationManager and add user accounts</title>
<simpara>If you provide a <literal>@Bean</literal> of type <literal>AuthenticationManager</literal> the default one will not be
created, so you have the full feature set of Spring Security available (e.g.
<ulink url="http://docs.spring.io/spring-security/site/docs/3.2.1.RELEASE/reference/htmlsingle/#jc-authentication">various authentication options</ulink>).</simpara>
<simpara>Spring Security also provides a convenient <literal>AuthenticationManagerBuilder</literal> which can be
used to build an <literal>AuthenticationManager</literal> with common options. The recommended way to
use this in a webapp is to inject it into a void method in a
<literal>WebSecurityConfigurerAdapter</literal>, e.g.</simpara>
<programlisting language="java" linenumbering="indent=0">        @Configuration
        @Order(0)
        public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

                @Autowired
                protected void init(AuthenticationManagerBuilder builder) {
                                builder.inMemoryAuthentication().withUser("barry"); // ...  etc.
                }

                // ... other stuff for application security

        }</programlisting>
<simpara>The configuration class that does this should declare an <literal>@Order</literal> so that it is used
before the default one in Spring Boot (which has very low precedence).</simpara>
</section>
</section>
<section id="_hot_swapping_2">
<title>Hot swapping</title>
<section id="_reload_static_content">
<title>Reload static content</title>
<simpara>There are several options. Running in an IDE (especially with debugging on) is a good way
to do development (all modern IDEs allow reloading of static resources and usually also
hot-swapping of Java class changes). The Maven and Gradle tooling also support running
from the command line with reloading of static files. You can use that with an external
css/js compiler process if you are writing that code with higher level tools.</simpara>
</section>
<section id="_reload_thymeleaf_templates_without_restarting_the_container">
<title>Reload Thymeleaf templates without restarting the container</title>
<simpara>If you are using Thymeleaf, then set <literal>spring.thymeleaf.cache=false</literal>. See
<literal>ThymeleafAutoConfiguration</literal> for other template customization options.</simpara>
</section>
<section id="_reload_java_classes_without_restarting_the_container">
<title>Reload Java classes without restarting the container</title>
<simpara>Modern IDEs (Eclipse, IDEA etc.) all support hot swapping of bytecode, so if you make a
change that doesn&#8217;t affect class or method signatures it should reload cleanly with no
side effects.</simpara>
<simpara><ulink url="https://github.com/spring-projects/spring-loaded">Spring Loaded</ulink> goes a little further in
that it can reload class definitions with changes in the method signatures. With some
customization it can force an <literal>ApplicationContext</literal> to refresh itself (but there is no
general mechanism to ensure that would be safe for a running application anyway, so it
would only ever be a development time trick probably).</simpara>
</section>
</section>
<section id="_build">
<title>Build</title>
<section id="_build_an_executable_archive_with_ant">
<title>Build an executable archive with Ant</title>
<simpara>To build with Ant you need to grab dependencies and compile and then create a JAR or WAR
archive as normal.  To make it executable:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Use the appropriate launcher as a <literal>Main-Class</literal>,
e.g. <literal>org.springframework.boot.loader.JarLauncher</literal> for a JAR file, and
specify the other stuff it needs as manifest entries, principally a
<literal>Start-Class</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
Add the runtime dependencies in a nested "lib" directory (for a
JAR) and the "provided" (embedded container) dependencies in a nested
"lib-provided" directory. Remember <emphasis role="strong">not</emphasis> to compress the entries in
the archive.
</simpara>
</listitem>
<listitem>
<simpara>
Add the <literal>spring-boot-loader</literal> classes at the root of the archive (so
the <literal>Main-Class</literal> is available).
</simpara>
</listitem>
</orderedlist>
<simpara>Example</simpara>
<programlisting language="xml" linenumbering="indent=0">        &lt;target name="build" depends="compile"&gt;
                &lt;copy todir="target/classes/lib"&gt;
                        &lt;fileset dir="lib/runtime" /&gt;
                &lt;/copy&gt;
                &lt;jar destfile="target/spring-boot-sample-actuator-${spring-boot.version}.jar" compress="false"&gt;
                        &lt;fileset dir="target/classes" /&gt;
                        &lt;fileset dir="src/main/resources" /&gt;
                        &lt;zipfileset src="lib/loader/spring-boot-loader-jar-${spring-boot.version}.jar" /&gt;
                        &lt;manifest&gt;
                                &lt;attribute name="Main-Class" value="org.springframework.boot.loader.JarLauncher" /&gt;
                                &lt;attribute name="Start-Class" value="${start-class}" /&gt;
                        &lt;/manifest&gt;
                &lt;/jar&gt;
        &lt;/target&gt;</programlisting>
<simpara>The Actuator Sample has a <literal>build.xml</literal> that should work if you run it with</simpara>
<screen>        $ ant -lib &lt;path_to&gt;/ivy-2.2.jar</screen>
<simpara>after which you can run the application with</simpara>
<screen>        $ java -jar target/*.jar</screen>
</section>
</section>
<section id="_traditional_deployment">
<title>Traditional deployment</title>
<section id="_create_a_deployable_war_file">
<title>Create a deployable WAR file</title>
<simpara>Use the <literal>SpringBootServletInitializer</literal> base class, which is picked up by Spring&#8217;s
Servlet 3.0 support on deployment. Add an extension of that to your project and build a
WAR file as normal. For more detail, see the
<ulink url="http://spring.io/guides/gs/convert-jar-to-war">&#8220;Converting a JAR Project to a WAR&#8221;</ulink> guide
on the spring.io website.</simpara>
<simpara>The WAR file can also be executable if you use the Spring Boot build tools. In that case
the embedded container classes (to launch Tomcat for instance) have to be added to the
WAR in a <literal>lib-provided</literal> directory. The tools will take care of that as long as the
dependencies are marked as "provided" in Maven or Gradle. Here&#8217;s a Maven example
<ulink url="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-samples/spring-boot-sample-traditional/pom.xml">in the Boot Samples</ulink>.</simpara>
</section>
<section id="_create_a_deployable_war_file_for_older_servlet_containers">
<title>Create a deployable WAR file for older servlet containers</title>
<simpara>Older Servlet containers don&#8217;t have support for the <literal>ServletContextInitializer</literal> bootstrap
process used in Servlet 3.0. You can still use Spring and Spring Boot in these containers
but you are going to need to add a <literal>web.xml</literal> to your application and configure it to load
an <literal>ApplicationContext</literal> via a <literal>DispatcherServlet</literal>.</simpara>
</section>
<section id="_convert_an_existing_application_to_spring_boot">
<title>Convert an existing application to Spring Boot</title>
<simpara>For a non-web application it should be easy (throw away the code that creates your
<literal>ApplicationContext</literal> and replace it with calls to <literal>SpringApplication</literal> or
<literal>SpringApplicationBuilder</literal>). Spring MVC web applications are generally amenable to first
creating a deployable WAR application, and then migrating it later to an executable WAR
and/or JAR.  Useful reading is in the <ulink url="http://spring.io/guides/gs/convert-jar-to-war/">Getting
Started Guide on Converting a JAR to a WAR</ulink>.</simpara>
<simpara>Create a deployable WAR by extending <literal>SpringBootServletInitializer</literal> (e.g. in a class
called <literal>Application</literal>), and add the Spring Boot <literal>@EnableAutoConfiguration</literal> annotation.
Example:</simpara>
<programlisting language="java" linenumbering="indent=0">        @Configuration
        @EnableAutoConfiguration
        @ComponentScan
        public class Application extends SpringBootServletInitializer {

                @Override
                protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
                        return application.sources(Application.class);
                }

        }</programlisting>
<simpara>Remember that whatever you put in the <literal>sources</literal> is just a Spring <literal>ApplicationContext</literal> and
normally anything that already works should work here. There might be some beans you can
remove later and let Spring Boot provide its own defaults for them, but it should be
possible to get something working first.</simpara>
<simpara>Static resources can be moved to <literal>/public</literal> (or <literal>/static</literal> or <literal>/resources</literal> or
<literal>/META-INFO/resources</literal>) in the classpath root. Same for <literal>messages.properties</literal> (Spring Boot
detects this automatically in the root of the classpath).</simpara>
<simpara>Vanilla usage of Spring <literal>DispatcherServlet</literal> and Spring Security should require no further
changes. If you have other features in your application, using other servlets or filters,
for instance then you may need to add some configuration to your <literal>Application</literal> context,
replacing those elements from the <literal>web.xml</literal> as follows:</simpara>
<itemizedlist>
<listitem>
<simpara>
A <literal>@Bean</literal> of type <literal>Servlet</literal> or <literal>ServletRegistrationBean</literal> installs that bean in the
  container as if it was a <literal>&lt;servlet/&gt;</literal> and <literal>&lt;servlet-mapping/&gt;</literal> in <literal>web.xml</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
A <literal>@Bean</literal> of type <literal>Filter</literal> or <literal>FilterRegistrationBean</literal> behaves similarly (like a
  <literal>&lt;filter/&gt;</literal> and <literal>&lt;filter-mapping/&gt;</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
An <literal>ApplicationContext</literal> in an XML file can be added to an <literal>@Import</literal> in your
  <literal>Application</literal>. Or simple cases where annotation configuration is heavily used already
  can be recreated in a few lines as <literal>@Bean</literal> definitions.
</simpara>
</listitem>
</itemizedlist>
<simpara>Once the WAR is working we make it executable by adding a <literal>main</literal> method to our
<literal>Application</literal>, e.g.</simpara>
<programlisting language="java" linenumbering="indent=0">        public static void main(String[] args) {
                SpringApplication.run(Application.class, args);
        }</programlisting>
<simpara>Applications can fall into more than one category:</simpara>
<itemizedlist>
<listitem>
<simpara>
Servlet 3.0 applications with no <literal>web.xml</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
Applications with a <literal>web.xml</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
Applications with a context hierarchy.
</simpara>
</listitem>
<listitem>
<simpara>
Applications without a context hierarchy.
</simpara>
</listitem>
</itemizedlist>
<simpara>All of these should be amenable to translation, but each might require slightly different
tricks.</simpara>
<simpara>Servlet 3.0 applications might translate pretty easily if they already use the Spring
Servlet 3.0 initializer support classes. Normally all the code from an existing
<literal>WebApplicationInitializer</literal> can be moved into a <literal>SpringBootServletInitializer</literal>. If your
existing application has more than one <literal>ApplicationContext</literal> (e.g. if it uses
<literal>AbstractDispatcherServletInitializer</literal>) then you might be able to squish all your context
sources into a single <literal>SpringApplication</literal>. The main complication you might encounter is if
that doesn&#8217;t work and you need to maintain the context hierarchy. See the
<link linkend="build.hierarchy">entry on building a hierarchy</link> for examples. An existing parent
context that contains web-specific features will usually need to be broken up so that all
the <literal>ServletContextAware</literal> components are in the child context.</simpara>
<simpara>Applications that are not already Spring applications might be convertible to a Spring
Boot application, and the guidance above might help, but your mileage may vary.</simpara>
</section>
</section>
</section>
</article>
