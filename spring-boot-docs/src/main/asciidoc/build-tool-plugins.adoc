[[build-tool-plugins]]
= Build tool plugins

[partintro]
--
Spring Boot provides build tool plugins for Maven and Gradle. The plugins offer a
variety of features, including the packaging executable jars. The section provides
more details on both plugins, as well as some help should you need to extend a differnt
build system. If you are just getting started, you might want to read XXX first.
--



[[build-tool-plugins-maven-plugin]]
== Spring Boot Maven plugin
The Spring Boot Maven Plugin provides Spring Boot support in Maven, allowing you to
package executable jar or war archives and run an application in-place. To use it you
must be using Maven 3 (or better).



[[build-tool-plugins-include-maven-plugin]]
=== Including the plugin
To use the Spring Boot Maven Plugin simply include the appropriate XML in the `plugins`
section of your `pom.xml`

[source,xml,indent=0,subs="verbatim,attributes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
		<modelVersion>4.0.0</modelVersion>
		<!-- ... -->
		<build>
			<plugins>
				<plugin>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-maven-plugin</artifactId>
					<version>{spring-boot-version}</version>
					<executions>
						<execution>
							<goals>
								<goal>repackage</goal>
							</goals>
						</execution>
					</executions>
				</plugin>
			</plugins>
		</build>
	</project>
----

This configuration will repackage a jar or war that is built in the `package` phase of
the Maven lifecycle, so

[indent=0]
----
	$ mvn package
	$ ls target/*.jar
	target/myproject-1.0.0.jar target/myproject-1.0.0.jar.original
----

will reveal the result. If you don't include the `<execution/>` configuration as above
you can run the plugin on its own, but only if the package goal is used as well, e.g.

[indent=0]
----
	$ mvn package spring-boot:repackage
----

will have the same effect as above.

If you are using a milestone or snapshot release you will also need to add appropriate
`pluginRepository` elements:

[source,xml,indent=0,subs="verbatim,attributes"]
----
	<pluginRepositories>
		<pluginRepository>
			<id>spring-snapshots</id>
			<url>http://repo.spring.io/snapshot</url>
		</pluginRepository>
		<pluginRepository>
			<id>spring-milestones</id>
			<url>http://repo.spring.io/milestone</url>
		</pluginRepository>
	</pluginRepositories>
----



[[build-tool-plugins-maven-packaging]]
=== Packaging executable jar and war files
Once `spring-boot-maven-plugin` has been included in your `pom.xml` it will automatically
attempt to rewrite archives to make them executable using the `spring-boot:repackage`
goal. You should configure your project to build a jar or war (as appropriate) using the
usual `packaging` element:

[source,xml,indent=0,subs="verbatim,attributes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
		<!-- ... -->
		<packaging>jar</packaging>
		<!-- ... -->
	</project>
----

Your existing archive will be enhanced by Spring Boot during the `package` phase. The
main class that you want to launch can either be specified using a configuration option,
or by adding a `Main-Class` attribute to the manifest in the usual way. If you don't
specify a main class the plugin will search for a class with a
`public static void main(String[] args)` method.

To build and run a project artifact, you do something like this:

[indent=0]
----
	$ mvn package
	$ java -jar target/mymodule-0.0.1-SNAPSHOT.jar
----



[[build-tool-plugins-maven-packaging-configuration]]
=== Repackage configuration
The following configuration options are available for the `spring-boot:repackage` goal:



[[build-tool-plugins-maven-packaging-required-params]]
==== Required parameters
[cols="1,1,4,1"]
|===
|Name |Type |Description |Default Value

|`outputDirectory`
|File
|Directory containing the generated archive.
|`${project.build.directory}`

|`finalName`
|String
|Name of the generated archive.
|`${project.build.finalName}`
|===



[[build-tool-plugins-maven-packaging-optional-params]]
==== Optional parameters
[cols="1,1,5"]
|===
|Name |Type |Description

|`classifier`
|String
|Classifier to add to the artifact generated. If given, the artifact will be attached. If
 this is not given, it will merely be written to the output directory according to the
 `finalName`.

|`mainClass`
|String
|The name of the main class. If not specified the first compiled class found that contains
 a `main` method will be used.

|`layout`
|String
|The type of archive (which corresponds to how the dependencies are laid out inside it).
 Defaults to a guess based on the archive type.
|===

The plugin rewrites your manifest, and in particular it manages the `Main-Class` and
`Start-Class` entries, so if the defaults don't work you have to configure those there
(not in the jar plugin). The `Main-Class` in the manifest is actually controlled by the
`layout` property of the boot plugin, e.g.

[source,xml,indent=0,subs="verbatim,attributes"]
----
	<plugin>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-maven-plugin</artifactId>
		<version>{spring-boot-version}</version>
		<configuration>
			<mainClass>${start-class}</mainClass>
			<layout>ZIP</layout>
		</configuration>
		<executions>
			<execution>
				<goals>
					<goal>repackage</goal>
				</goals>
			</execution>
		</executions>
	</plugin>
----

The layout property defaults to a guess based on the archive type (jar or war). For the
`PropertiesLauncher` the layout is ``ZIP'' (even though the output might be a jar file).



[[build-tool-plugins-maven-running-applications]]
=== Running applications
The Spring Boot Maven Plugin includes a `run` goal which can be used to launch your
application from the command line. Type the following from the root of your Maven
project:

[indent=0]
----
	$ mvn spring-boot:run
----

By default, any `src/main/resources` folder will be added to the application classpath
when you run via the maven plugin. This allows hot refreshing of resources which can be
very useful when web applications. For example, you can work on HTML, CSS or JavaScipt
files and see your changes immediately without recompiling your application. It is also
a helpful way of allowing your front end developers to work without needing to download
and install a Java IDE.



[[build-tool-plugins-maven-run-configuration]]
=== Run configuration
The following configuration options are available for the `spring-boot:run` goal:



[[build-tool-plugins-maven-run-configuration-required-params]]
=== Required parameters
[cols="1,1,4,1"]
|===
|Name |Type |Description |Default Value

|`classesDirectrory`
|File
|Directory containing the classes and resource files that should be packaged into the
 archive.
|`${project.build.outputDirectory}`
|===



[[build-tool-plugins-maven-run-configuration-optional-params]]
=== Optional parameters
[cols="1,1,4,1"]
|===
|Name |Type |Description |Default Value

|`arguments` or `-Drun.arguments`
|String[]
|Arguments that should be passed to the application.
|

|`addResources` or `-Drun.addResources`
|boolean
|Add Maven resources to the classpath directly, this allows live in-place editing or
 resources. Since resources will be added directly, and via the target/classes folder
 they will appear twice if `ClassLoader.getResources()` is called. In practice, however,
 most applications call `ClassLoader.getResource()` which will always return the first
 resource
| true

|`mainClass`
|String
|The name of the main class. If not specified the first compiled class found that
 contains a 'main' method will be used.
|

|`folders`
|String[]
|Folders that should be added to the classpath.
|`${project.build.outputDirectory}`
|===



[[build-tool-plugins-gradle-plugin]]
== Spring Boot Gradle plugin
The Spring Boot Gradle Plugin provides Spring Boot support in Gradle, allowing you to
package executable jar or war archives, run Spring Boot applications and remove version
information from your `build.gradle` file.



[[build-tool-plugins-including-the-gradle-plugin]]
=== Including the plugin
To use the Spring Boot Gradle Plugin simply include a `buildscript` dependency and apply
the `spring-boot` plugin:

[source,groovy,indent=0,subs="verbatim,attributes"]
----
	buildscript {
		dependencies {
			classpath("org.springframework.boot:spring-boot-gradle-plugin:{spring-boot-version}")
		}
	}
	apply plugin: 'spring-boot'
----

If you are using a milestone or snapshot release you will also need to add appropriate
`repositories` reference:

[source,groovy,indent=0,subs="verbatim,attributes"]
----
	buildscript {
		repositories {
			maven.url "http://repo.spring.io/snapshot"
			maven.url "http://repo.spring.io/milestone"
		}
		// ...
	}
----



[[build-tool-plugins-gradle-dependencies-without-versions]]
=== Declaring dependencies without versions
The `spring-boot` plugin will register a custom Gradle `ResolutionStrategy` with your
build that allows you to omit version numbers when declaring dependencies to known
artifacts. All artifacts with a `org.springframework.boot` group ID, and any of the
artifacts declared in the `managementDependencies` section of the `spring-dependencies`
POM can have their version number resolved automatically.

Simply declare dependencies in the usual way, but leave the version number empty:

[source,groovy,indent=0,subs="verbatim,attributes"]
----
	dependencies {
		compile("org.springframework.boot:spring-boot-starter-web")
		compile("org.thymeleaf:thymeleaf-spring4")
		compile("nz.net.ultraq.thymeleaf:thymeleaf-layout-dialect")
	}
----



[[build-tool-plugins-gradle-packaging]]
=== Packaging executable jar and war files
Once the `spring-boot` plugin has been applied to your project it will automatically
attempt to rewrite archives to make them executable using the `bootRepackage` task. You
should configure your project to build a jar or war (as appropriate) in the usual way.

The main class that you want to launch can either be specified using a configuration
option, or by adding a `Main-Class` attribute to the manifest. If you don't specify a
main class the plugin will search for a class with a
`public static void main(String[] args)` method.

To build and run a project artifact, you do something like this:

[indent=0]
----
	$ gradle build
	$ java -jar build/libs/mymodule-0.0.1-SNAPSHOT.jar
----



[[build-tool-plugins-gradle-running-applications]]
=== Running a project in-place
To run a project in place without building a jar first you can use the "bootRun" task:

[indent=0]
----
	$ gradle bootRun
----

Running this way makes your static classpath resources (i.e. in `src/main/resources` by
default) reloadable in the live application, which can be helpful at development time.

[[build-tool-plugins-gradle-repackage-configuration]]
=== Repackage configuration
The gradle plugin automatically extends your build script DSL with a `springBoot` element
for configuration. Simply set the appropriate properties as you would any other Gradle
extension:

[source,groovy,indent=0,subs="verbatim,attributes"]
----
	springBoot {
		backupSource = false
	}
----



[[build-tool-plugins-gradle-repackage-custom-configuration]]
=== Repackage with custom Gradle configuration
Sometimes it may be more appropriate to not package default dependencies resolved from
`compile`, `runtime` and `provided` scopes. If created executable jar file
is intended to be run as it is you need to have all dependencies in it, however
if a plan is to explode a jar file and run main class manually you may already
have some of the libraries available via `CLASSPATH`. This is a situation where
you can repackage boot jar with a different set of dependencies. Using a custom
configuration will automatically disable dependency resolving from
`compile`, `runtime` and `provided` scopes. Custom configuration can be either
defined globally inside `springBoot` or per task.

[source,groovy,indent=0,subs="verbatim,attributes"]
----
	task clientJar(type: Jar) {
		appendix = 'client'
		from sourceSets.main.output
		exclude('**/*Something*')
	}

	task clientBoot(type: BootRepackage, dependsOn: clientJar) {
		withJarTask = clientJar
		customConfiguration = "mycustomconfiguration"
	}
----

In above example we created a new `clientJar` Jar task to package a customized
file set from your compiled sources. Then we created a new `clientBoot`
BootRepackage task and instructed it to work with only `clientJar` task and
`mycustomconfiguration`.

[source,groovy,indent=0,subs="verbatim,attributes"]
----
	configurations {
		mycustomconfiguration.exclude group: 'log4j'
	}

	dependencies {
		mycustomconfiguration configurations.runtime
	}
----

Configuration we are referring to in `BootRepackage` is a normal Gradle configuration. In
the above example we created a new configuration named `mycustomconfiguration` instructing
it to derive from a `runtime` and exclude `log4j` group. If `clientBoot` task is executed,
repackaged boot jar will have all dependencies from a runtime but no log4j jars.



[[build-tool-plugins-gradle-configuration-options]]
==== Configuration options
The following configuration options are available:

[cols="1,1,4,1"]
|===
|Name |Type |Description |Default Value

|`mainClass`
|String
|The main class that should be run. If not specified the value from the manifest will be
 used, or if no manifest entry is the archive will be searched for a suitable class.
|

|`providedConfiguration`
|String
|The name of the provided configuration.
|`providedRuntime`

|`backupSource`
|boolean
|If the original source archive should be backed-up before being repackaged.
|`true`

|`customConfiguration`
|String
|The name of the custom configuration.
|

|layout
|String
|The type of archive (which corresponds to how the dependencies are laid out inside it).
 Defaults to a guess based on the archive type.
|
|===



[[build-tool-plugins-understanding-the-gradle-plugin]]
=== Understanding how the Gradle plugin works
When `spring-boot` is applied to your Gradle project a default task named `bootRepackage`
is created automatically. Boot repackage task depends on Gradle `assemble` task and when
executed, it tries to find all jar artifacts whose qualifier is empty (i.e. tests and
sources jars are automatically skipped).

Because on default every repackage task execution will find all created jar artifacts,
the order of Gradle task execution is important. This is not going to be an issue if
you have a normal project setup where only one jar file is created. However if you are
planning to create more complex project setup with custom `Jar` and `BootRepackage`
tasks, there are few tweaks to consider.

[source,groovy,indent=0,subs="verbatim,attributes"]
----
	jar.enabled = false
	bootRepackage.enabled = false
----

The above example simply disables default `jar` and `bootRepackage` tasks. This would be
all right if you are just creating custom jar files out from your project. You could also
just disable default `bootRepackage` task.

[source,groovy,indent=0,subs="verbatim,attributes"]
----
	bootRepackage.withJarTask = jar
----

The above example simply instructs default `bootRepackage` task to only work with a
default `jar` task.

[source,groovy,indent=0,subs="verbatim,attributes"]
----
	task bootJars
	bootJars.dependsOn = [clientBoot1,clientBoot2,clientBoot3]
	build.dependsOn(bootJars)
----

If you still have a default project setup where main jar file is created and repackaged
to be used with boot and you still want to create additional custom jar files out from
your project, you could simple combine you custom repackage tasks together and create
dependency to your build so that `bootJars` task would be run after the default
`bootRepackage` task is executed.

All the above tweaks are usually used to avoid situation where already created boot jar
is repackaged again. Repackaging an existing boot jar will not break anything but you may
get unnecessary dependencies in it.



[[build-tool-plugins-other-build-systems]]
== Supporting other build systems
If you want to use a build tool other than Maven or Gradle you will likely need to develop
your own plugin. Executable jars need to follow a specific format and certain entries need
to be written in an uncompressed form.

The Spring Boot Maven and Gradle plugins both make use of `spring-boot-loader-tools` to
actually generate jars. You are also free to use this library directly yourself if you
need to.



[[build-tool-plugins-repackaging-archives]]
=== Repackaging archives
To repackage an existing archive so that it becomes a self-contained executable archive
use `org.springframework.boot.loader.tools.Repackager`. The `Repackager` class takes a
single constructor argument that refers to an existing jar or war archive. Use one of the
two available `repackage()` methods to either replace the original file or write to a new
destination. Various settings can also be configured on the repackager before it is
run.



[[build-tool-plugins-nested-libraries]]
=== Nested libraries
When repackaging an archive you can include references to dependency files using the
`org.springframework.boot.loader.tools.Libraries` interface. We don't provide any
concrete implementations of `Libraries` here as they are usually build system specific.

If your archive already includes libraries you can use `Libraries.NONE`.



[[build-tool-plugins-find-a-main-class]]
=== Finding a main class
If you don't use `Repackager.setMainClass()` to specify a main class, the repackager will
use http://asm.ow2.org/[ASM] to read class files and attempt to find a suitable class.
The first class with a `public static void main(String[] args)` method will be used.
Searching is performed using a breadth first algorithm, with the assumption that the main
class will appear high in the package structure.



[[build-tool-plugins-repackage-implementation]]
=== Example repackage implementation
Here is a typical example repackage:

[source,java,indent=0]
----
	Repackager repackager = new Repackager(sourceJarFile);
	repackager.setBackupSource(false);
	repackager.repackage(new Libraries() {
				@Override
				public void doWithLibraries(LibraryCallback callback) throws IOException {
					// Build system specific implementation, callback for each dependency
					// callback.library(nestedFile, LibraryScope.COMPILE);
				}
			});
----

